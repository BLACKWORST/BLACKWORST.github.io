<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='八、线程 1.ThreadLocal 使用方法很简单
static final ThreadLocal&amp;lt;T&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;T&amp;gt;(); sThreadLocal.set() sThreadLocal.get() Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。
/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.'>
<title>Java（8）线程</title>

<link rel='canonical' href='https://haolovelin.com/post/java8%E7%BA%BF%E7%A8%8B/'>

<link rel="stylesheet" href="/scss/style.min.5be32ca3f6e1a997c75795c4359147cc6d4fbd34948c0acd51e31d237033978a.css"><meta property='og:title' content='Java（8）线程'>
<meta property='og:description' content='八、线程 1.ThreadLocal 使用方法很简单
static final ThreadLocal&amp;lt;T&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;T&amp;gt;(); sThreadLocal.set() sThreadLocal.get() Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。
/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.'>
<meta property='og:url' content='https://haolovelin.com/post/java8%E7%BA%BF%E7%A8%8B/'>
<meta property='og:site_name' content='浩&amp;琳'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2021-06-05T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-06-05T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="Java（8）线程">
<meta name="twitter:description" content="八、线程 1.ThreadLocal 使用方法很简单
static final ThreadLocal&amp;lt;T&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;T&amp;gt;(); sThreadLocal.set() sThreadLocal.get() Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。
/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu9f7a08366cc43f473c39f8f10558a931_55504_300x0_resize_box_3.png" width="300"
                            height="332" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">浩&amp;琳</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/page/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>文章分类</span>
            </a>
        </li>
        
        
        <li >
            <a href='/page/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/page/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/page/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>Dark Mode</span>
                </li>
            
        </div>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/" style="background-color: #2a9d8f; color: #fff;">
                编程学习
            </a>
        
            <a href="/categories/javase/" style="background-color: #666666; color: #fff;">
                JavaSE
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/post/java8%E7%BA%BF%E7%A8%8B/">Java（8）线程</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 05, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    10 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="八线程">八、线程</h2>
<h3 id="1threadlocal">1.ThreadLocal</h3>
<p>使用方法很简单</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ThreadLocal<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> sThreadLocal <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadLocal<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span>sThreadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>sThreadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">()</span>
</span></span></code></pre></div><p>Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This class provides thread-local variables.  These variables differ from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * their normal counterparts in that each thread that accesses one (via its
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * {@code get} or {@code set} method) has its own, independently initialized
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * copy of the variable.  {@code ThreadLocal} instances are typically private
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * static fields in classes that wish to associate state with a thread (e.g.,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * a user ID or Transaction ID).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span></code></pre></div><p>大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。</p>
<p>做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。</p>
<p><strong>这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</strong>。</p>
<p>作为一个存储数据的类，关键点就在get和set方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//set 方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>T value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//获取当前线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      Thread t <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//实际存储的数据结构类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      ThreadLocalMap map <span style="color:#f92672">=</span> getMap<span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//如果存在map就直接set，没有则创建map并set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>map <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>          map<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>          createMap<span style="color:#f92672">(</span>t<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">//getMap方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ThreadLocalMap <span style="color:#a6e22e">getMap</span><span style="color:#f92672">(</span>Thread t<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//thred中维护了一个ThreadLocalMap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">threadLocals</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">//createMap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createMap</span><span style="color:#f92672">(</span>Thread t<span style="color:#f92672">,</span> T firstValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      t<span style="color:#f92672">.</span><span style="color:#a6e22e">threadLocals</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadLocalMap<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> firstValue<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>从上面代码可以看出<strong>每个线程持有一个ThreadLocalMap对象</strong>。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。</p>
<h3 id="2thread">2.Thread</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/* ThreadLocal values pertaining to this thread. This map is maintained
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * by the ThreadLocal class. */</span>
</span></span><span style="display:flex;"><span>    ThreadLocal<span style="color:#f92672">.</span><span style="color:#a6e22e">ThreadLocalMap</span> threadLocals <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span></code></pre></div><p>Thread中关于ThreadLocalMap部分的相关声明，接下来看一下createMap方法中的实例化过程。</p>
<h3 id="3threadlocalmap">3.ThreadLocalMap</h3>
<h5 id="set方法">set方法</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//Entry为ThreadLocalMap静态内部类，对ThreadLocal的若引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//同时让ThreadLocal和储值形成key-value的关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entry</span> <span style="color:#66d9ef">extends</span> WeakReference<span style="color:#f92672">&lt;</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/** The value associated with this ThreadLocal. */</span>
</span></span><span style="display:flex;"><span>    Object value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Entry<span style="color:#f92672">(</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;</span> k<span style="color:#f92672">,</span> Object v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>k<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            value <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//ThreadLocalMap构造方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ThreadLocalMap<span style="color:#f92672">(</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;</span> firstKey<span style="color:#f92672">,</span> Object firstValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//内部成员数组，INITIAL_CAPACITY值为16的常量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        table <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">[</span>INITIAL_CAPACITY<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//位运算，结果与取模相同，计算出需要存放的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//threadLocalHashCode比较有趣
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> firstKey<span style="color:#f92672">.</span><span style="color:#a6e22e">threadLocalHashCode</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>INITIAL_CAPACITY <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        table<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">(</span>firstKey<span style="color:#f92672">,</span> firstValue<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        setThreshold<span style="color:#f92672">(</span>INITIAL_CAPACITY<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>通过上面的代码不难看出在实例化ThreadLocalMap时创建了一个长度为16的Entry数组。通过hashCode与length位运算确定出一个索引值i，这个i就是被存储在table数组中的位置。</p>
<p>前面讲过每个线程Thread持有一个ThreadLocalMap类型的实例threadLocals，结合此处的构造方法可以理解成每个线程Thread都持有一个Entry型的数组table，而一切的读取过程都是通过操作这个数组table完成的。</p>
<p><em>显然table是set和get的焦点，在看具体的set和get方法前，先看下面这段代码。</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//在某一线程声明了ABC三种类型的ThreadLocal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ThreadLocal<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> sThreadLocalA <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadLocal<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span>ThreadLocal<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> sThreadLocalB <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadLocal<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span>ThreadLocal<span style="color:#f92672">&lt;</span>C<span style="color:#f92672">&gt;</span> sThreadLocalC <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ThreadLocal<span style="color:#f92672">&lt;</span>C<span style="color:#f92672">&gt;();</span>
</span></span></code></pre></div><p>由前面我们知道对于一个Thread来说只有持有一个ThreadLocalMap，所以ABC对应同一个ThreadLocalMap对象。为了管理ABC，于是将他们存储在一个数组的不同位置，而这个数组就是上面提到的Entry型的数组table。</p>
<p>那么问题来了，ABC在table中的位置是如何确定的？为了能正常够正常的访问对应的值，肯定存在一种方法计算出确定的索引值i，show me code。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>  <span style="color:#75715e">//ThreadLocalMap中set方法。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;</span> key<span style="color:#f92672">,</span> Object value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// We don&#39;t use a fast path as with get() because it is at
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// least as common to use set() to create new entries as
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// it is to replace existing ones, in which case, a fast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// path would fail more often than not.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            Entry<span style="color:#f92672">[]</span> tab <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> tab<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//获取索引值，这个地方是比较特别的地方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">threadLocalHashCode</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//遍历tab如果已经存在则更新值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry e <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>                 e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                 e <span style="color:#f92672">=</span> tab<span style="color:#f92672">[</span>i <span style="color:#f92672">=</span> nextIndex<span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> len<span style="color:#f92672">)])</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                ThreadLocal<span style="color:#f92672">&lt;?&gt;</span> k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">==</span> key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    replaceStaleEntry<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果上面没有遍历成功则创建新值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            tab<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> sz <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>size<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//满足条件数组扩容x2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>cleanSomeSlots<span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> sz<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> sz <span style="color:#f92672">&gt;=</span> threshold<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                rehash<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>在ThreadLocalMap中的set方法与构造方法能看到以下代码片段。</p>
<ul>
<li><code>int i = key.threadLocalHashCode &amp; (len-1)</code></li>
<li><code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)</code>
简而言之就是将threadLocalHashCode进行一个位运算（取模）得到索引i，threadLocalHashCode代码如下。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#75715e">//ThreadLocal中threadLocalHashCode相关代码.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> threadLocalHashCode <span style="color:#f92672">=</span> nextHashCode<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The next hash code to be given out. Updated atomically. Starts at
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * zero.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> AtomicInteger nextHashCode <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The difference between successively generated hash codes - turns
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * implicit sequential thread-local IDs into near-optimally spread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * multiplicative hash values for power-of-two-sized tables.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> HASH_INCREMENT <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x61c88647</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns the next hash code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">nextHashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//自增
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> nextHashCode<span style="color:#f92672">.</span><span style="color:#a6e22e">getAndAdd</span><span style="color:#f92672">(</span>HASH_INCREMENT<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>因为static的原因，在每次<code>new ThreadLocal</code>时因为threadLocalHashCode的初始化，会使threadLocalHashCode值自增一次，增量为0x61c88647。</p>
<p>0x61c88647是斐波那契散列乘数,它的优点是通过它散列(hash)出来的结果分布会比较均匀，可以很大程度上避免hash冲突，已初始容量16为例，hash并与15位运算计算数组下标结果如下：</p>
<div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:center">hashCode</th>
<th style="text-align:center">数组下标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x61c88647</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">0xc3910c8e</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">0x255992d5</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">0x8722191c</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">0xe8ea9f63</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">0x4ab325aa</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">0xac7babf1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0xe443238</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">0x700cb87f</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table></div>
<p>总结如下：</p>
<ol>
<li>对于某一ThreadLocal来讲，他的索引值i是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的。</li>
<li>对于同一线程的不同ThreadLocal来讲，这些ThreadLocal实例共享一个table数组，然后每个ThreadLocal实例在table中的索引i是不同的。</li>
</ol>
<h5 id="get方法">get()方法</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//ThreadLocal中get方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    Thread t <span style="color:#f92672">=</span> Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    ThreadLocalMap map <span style="color:#f92672">=</span> getMap<span style="color:#f92672">(</span>t<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>map <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        ThreadLocalMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span> e <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">getEntry</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            T result <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>T<span style="color:#f92672">)</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> setInitialValue<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e">//ThreadLocalMap中getEntry方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> Entry <span style="color:#a6e22e">getEntry</span><span style="color:#f92672">(</span>ThreadLocal<span style="color:#f92672">&lt;?&gt;</span> key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">threadLocalHashCode</span> <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>       Entry e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> key<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> e<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> getEntryAfterMiss<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> e<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>理解了set方法，get方法也就清楚明了，无非是通过计算出索引直接从数组对应位置读取即可。</p>
<p>ThreadLocal实现主要涉及Thread，ThreadLocal，ThreadLocalMap这三个类。关于ThreadLocal的实现流程正如上面写的那样，实际代码还有许多细节处理的部分并没有在这里写出来。</p>
<h3 id="4threadlocal特性">4.ThreadLocal特性</h3>
<p>ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题，不同的点是</p>
<ul>
<li>Synchronized是通过线程等待，牺牲时间来解决访问冲突</li>
<li>ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li>
</ul>
<p>正因为ThreadLocal的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了ThreadLocal。<strong>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</strong></p>
<h3 id="5线程相关的一些问题">5.线程相关的一些问题</h3>
<h5 id="1什么是线程能解决什么问题">1.什么是线程？能解决什么问题。</h5>
<p>Thread，是程序执行的基本单位，处理并发场景的时候使用，Java虚拟机运行程序同时运行多个执行线程。</p>
<h5 id="2java中创建线程的2种方式--区别">2.Java中创建线程的2种方式 &amp; 区别？</h5>
<p>​	<strong>1.重写run方法</strong>（可以声明一个类去继承Thread，也可以不声明，直接new，但是声明了可以方便复用）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//具体的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Calendar<span style="color:#f92672">.</span><span style="color:#a6e22e">getInstance</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getTime</span><span style="color:#f92672">());</span><span style="color:#75715e">//系统时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyThread myThread<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> MyThread<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>myThread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>​	<strong>2.实现Runnable接口，实现 run 方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyRunnable</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Calendar<span style="color:#f92672">.</span><span style="color:#a6e22e">getInstance</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getTime</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>MyRunnable p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyRunnable<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>p<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h5 id="3给我说说线程的生命周期">3.给我说说线程的生命周期。</h5>
<p>新建：当使用new操作符创建新线程时，线程处于“新建“状态</p>
<p>运行(可运行):调用start()方法</p>
<p>阻塞：当线程需要获得对象的内置锁，而该锁正在被其他线程拥有</p>
<p>等待：当线程等待其他线程通知调度表可以运行时</p>
<p>计时等待：对于一些含有时间参数的方法，如Thread类的sleep()</p>
<p>终止：当run()方法运行完毕或出现异常时</p>
<h5 id="4线程死锁的原因--举个栗子--如何避免死锁">4.线程死锁的原因 &amp; 举个栗子 &amp; 如何避免死锁。</h5>
<p>死锁的四个条件：<strong>互斥、请求与保持、不剥夺、循环等待</strong></p>
<p>​       1、互斥条件：所谓互斥就是线程在某一时间内独占资源。</p>
<p>　　2、请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>　　3、不剥夺条件：线程已获得资源，在未使用完之前，不能强行剥夺。</p>
<p>　　4、循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</p>
<p>哲学家就餐问题：5个哲学家和5根筷子。</p>
<p>只要破坏死锁的四个条件之一即可。</p>
<h5 id="5synchronized放在静态方法和非静态方法上的锁对象分别是什么">5.Synchronized放在静态方法和非静态方法上的锁对象分别是什么？</h5>
<p>static的方法属于类方法，它属于这个Class（注意：这里的Class不是指Class的某个具体对象），那么static获取到的锁，是属于<strong>类的锁</strong>。而非static方法获取到的锁，是属于当前<strong>对象的锁</strong>。所以，他们之间不会产生互斥。</p>
<p>那当我们想让所有这个类下面的方法都同步的时候，也就是让所有这个类下面的静态方法和非静态方法共用同一把锁的时候，我们如何办呢？此时我们可以使用Lock。</p>
<h5 id="6如何停止掉一个线程">6.如何停止掉一个线程？</h5>
<p>1、设置标志位</p>
<p>2、调用stop方法：但官方不推荐，会可能造成出现数据不一致的问题。</p>
<p>3、调用interrupt方法：Thread.currentThread().isInterrupted()为true时调用interrupt</p>
<h5 id="7给我说说线程池的种类--特点--内部原理--平时当中使用案例">7.给我说说线程池的种类 &amp; 特点 &amp; 内部原理 &amp; 平时当中使用案例。</h5>
<p><strong>线程池种类：</strong></p>
<p>Java通过<strong>Executors</strong>提供四种线程池，分别为：
Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<strong>适用：执行很多短期异步的小程序或者负载较轻的服务器</strong>
Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<strong>适用：执行长期的任务，性能好很多</strong>
Executors.newScheduledThreadPool 创建一个周期线程池，支持定时及周期性任务执行。<strong>适用：周期性执行任务的场景</strong>
Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<strong>适用：一个任务一个任务执行的场景</strong></p>
<p><strong>使用线程池的原因：</strong></p>
<p>​	降低资源损耗</p>
<p>​	提高响应速度</p>
<p>​	提高线程可管理性</p>
<p><strong>线程池的内部原理：</strong></p>
<!-- raw HTML omitted -->
<p>先看一下ThreadPoolExecutor类的execute方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>Runnable command<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>command <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//获取clt，clt记录着线程池状态和运行线程数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//运行线程数小于核心线程数时，创建线程放入线程池中，并且运行当前任务。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//创建线程失败，重新获取clt。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//线程池是运行状态并且运行线程大于核心线程数时，把任务放入队列中。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isRunning<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">offer</span><span style="color:#f92672">(</span>command<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> recheck <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//重新检查线程池不是运行状态时，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//把任务移除队列，并通过拒绝策略对该任务进行处理。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> isRunning<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> remove<span style="color:#f92672">(</span>command<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>            reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//当前运行线程数为0时，创建线程加入线程池中。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerCountOf<span style="color:#f92672">(</span>recheck<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            addWorker<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//运行线程大于核心线程数时并且队列已满时，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//创建线程放入线程池中，并且运行当前任务。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>addWorker<span style="color:#f92672">(</span>command<span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//运行线程大于最大线程数时，失败则拒绝该任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        reject<span style="color:#f92672">(</span>command<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>在execute方法中，多次调用的addWorker方法，再看一下这个方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">addWorker</span><span style="color:#f92672">(</span>Runnable firstTask<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> core<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    retry<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取clt，clt记录着线程池状态和运行线程数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//获取线程池的运行状态。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//线程池处于关闭状态，或者当前任务为null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//或者队列不为空，则直接返回失败。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&gt;=</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">!</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">!</span> workQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()))</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//获取线程池中的线程数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> wc <span style="color:#f92672">=</span> workerCountOf<span style="color:#f92672">(</span>c<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//线程数超过CAPACITY，则返回false；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//这里的core是addWorker方法的第二个参数，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//如果为true则根据核心线程数进行比较，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//如果为false则根据最大线程数进行比较。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>wc <span style="color:#f92672">&gt;=</span> CAPACITY <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                wc <span style="color:#f92672">&gt;=</span> <span style="color:#f92672">(</span>core <span style="color:#f92672">?</span> corePoolSize <span style="color:#f92672">:</span> maximumPoolSize<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//尝试增加线程数，如果成功，则跳出第一个for循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>compareAndIncrementWorkerCount<span style="color:#f92672">(</span>c<span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span> retry<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果增加线程数失败，则重新获取ctl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            c <span style="color:#f92672">=</span> ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果当前的运行状态不等于rs，说明状态已被改变，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//返回第一个for循环继续执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>runStateOf<span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> rs<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span> retry<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    Worker w <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//根据当前任务来创建Worker对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        w <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Worker<span style="color:#f92672">(</span>firstTask<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> Thread t <span style="color:#f92672">=</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">thread</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> ReentrantLock mainLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">mainLock</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//获得锁以后，重新检查线程池状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> rs <span style="color:#f92672">=</span> runStateOf<span style="color:#f92672">(</span>ctl<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rs <span style="color:#f92672">&lt;</span> SHUTDOWN <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">(</span>rs <span style="color:#f92672">==</span> SHUTDOWN <span style="color:#f92672">&amp;&amp;</span> firstTask <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">isAlive</span><span style="color:#f92672">())</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalThreadStateException<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//把刚刚创建的线程加入到线程池中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    workers<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> workers<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">//记录线程池中出现过的最大线程数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s <span style="color:#f92672">&gt;</span> largestPoolSize<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>                        largestPoolSize <span style="color:#f92672">=</span> s<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                    workerAdded <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                mainLock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>workerAdded<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//启动线程，开始运行任务
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                t<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                workerStarted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span> workerStarted<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            addWorkerFailed<span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> workerStarted<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h5 id="8给我谈谈你是如何保证线程数据安全问题的">8.给我谈谈你是如何保证线程数据安全问题的？</h5>
<p>保证线程安全<strong>以是否需要同步手段</strong>分类，分为同步方案和无需同步方案。</p>
<p><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180315101631748.png"
	width="628"
	height="317"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180315101631748_hu627a4d190a11e65a99b4609c69e0bff5_8968_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180315101631748_hu627a4d190a11e65a99b4609c69e0bff5_8968_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="198"
		data-flex-basis="475px"
	
></p>
<p>1、互斥同步（阻塞同步）：ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性。</p>
<p>互斥同步属于一种<strong>悲观的并发策略</strong>，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p>
<p>2、非阻塞同步</p>
<p>随着硬件指令集的发展，出现了<strong>基于冲突检测的乐观并发策略</strong>，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的<strong>补偿措施</strong>。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p>
<p>​    非阻塞的实现CAS（compare and swap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p>
<p>​    CAS缺点：</p>
<p>​    ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>​    ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3A。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>​    3、无需同步方案</p>
<p>​    <em><strong>*要保证线程安全，并不是一定就要进行同步*</strong></em>，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就<strong>无需任何同步操作去保证正确性</strong>，因此会有一些代码天生就是线程安全的。</p>
<p>​    1）可重入代码</p>
<p>​    可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p>
<p>​    可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。</p>
<p>​    （类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）</p>
<p>2）线程本地存储</p>
<p>​    如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的<strong>可见范围</strong>限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。</p>
<p>​    符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。Android的Handler机制的Looper、AMS、ActivityThread用的ThreadLocal</p>
<p>tip：线程的安全程度<strong>由强到弱</strong>：</p>
<p>我们可以将java语言中各种操作共享的数据分为以下5类：<strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</strong>。</p>
<p>1、不可变</p>
<p>​    在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。如final关键字修饰的数据不可修改，可靠性最高。</p>
<p>2、绝对线程安全</p>
<p>绝对的线程安全完全满足Brian GoetZ给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的代价。</p>
<p>3、相对线程安全</p>
<p>相对线程安全就是我们通常意义上所讲的一个类是“线程安全”的。</p>
<p>​    它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p>
<p>在java语言中，大部分的线程安全类都属于相对线程安全的，例如Vector、HashTable、Collections的synchronizedCollection（）方法保证的集合。</p>
<p>4、线程兼容</p>
<p>线程兼容就是我们通常意义上所讲的一个类不是线程安全的。</p>
<p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下可以安全地使用。Java API中大部分的类都是属于线程兼容的。如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p>
<p>5、线程对立</p>
<p>线程对立是指无论调用端是否采取了同步错误，都无法在多线程环境中并发使用的代码。由于java语言天生就具有多线程特性，线程对立这种排斥多线程的代码是很少出现的。</p>
<p>一个线程对立的例子是Thread类的supend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都有死锁风险。正因此如此，这两个方法已经被废弃啦。</p>
<h5 id="9wait和sleep的区别">9.wait()和sleep()的区别？</h5>
<p>sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法。例如，当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。并且可以调用notify方法或者notifyAll方法通知正在等待的其他线程。notify方法仅唤醒一个线程（等待队列中的第一个线程）并允许他去获得锁。notifyAll方法唤醒所有等待这个对象的线程并允许他们去竞争获得锁。</p>
<p><strong>wait()方法必须放在同步控制方法和同步代码块中使用</strong>，sleep()方法则可以放在任何地方使用。<strong>sleep()方法必须捕获异常</strong>，而wait、notify、notifyAll不需要捕获异常。在sleep的过程中，有可能被其他对象调用他的interrupt，产生InterruptedException。由于sleep不会释放锁标志，容易导致死锁问题的发生，因此一般情况下，推荐使用wait方法。</p>
<h5 id="10什么是公平锁非公平锁区别">10.什么是公平锁&amp;非公平锁&amp;区别？</h5>
<p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
<strong>优点</strong>：所有的线程都能得到资源，不会饿死在队列中。
<strong>缺点</strong>：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p>
<p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
<strong>优点</strong>：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
<strong>缺点</strong>：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p>
<h5 id="11给我讲讲线程间通信">11.给我讲讲线程间通信</h5>
<p><strong>①同步</strong></p>
<p>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</p>
<p><strong>②while轮询的方式</strong></p>
<p>不停地通过while语句检测条件是否成立。</p>
<p><strong>③wait/notify机制</strong></p>
<p>在同步代码块使用。</p>
<p>Thread.join<strong>把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</strong></p>
<p>比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
<p>t.join();   //调用join方法，等待线程t执行完毕
t.join(1000); //等待 t 线程，等待时间是1000毫秒。</p>
<h5 id="12volatile关键字是如何使用的原理是什么">12.volatile关键字是如何使用的？原理是什么</h5>
<p>volatile通常被比喻成&quot;轻量级的synchronized&quot;，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p>
<p>volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p>
<p>如以下代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> <span style="color:#f92672">{</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">static</span> Singleton singleton<span style="color:#f92672">;</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Singleton</span> <span style="color:#f92672">(){}</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Singleton <span style="color:#a6e22e">getSingleton</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>singleton <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span>Singleton<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>singleton <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> singleton <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton<span style="color:#f92672">();</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#f92672">}</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#f92672">}</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#f92672">}</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#66d9ef">return</span> singleton<span style="color:#f92672">;</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#960050;background-color:#1e0010"> </span> <span style="color:#f92672">}</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#960050;background-color:#1e0010"> </span>
</span></span></code></pre></div><h6 id="volatile的原理">volatile的原理</h6>
<p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p>
<p>但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p>
<p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</p>
<p>缓存一致性协议：每个处理器通过嗅探在<strong>总线上传播的数据来检查自己缓存的值是不是过期了</strong>，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成<strong>无效状态</strong>，当处理器要对这个数据进行修改操作的时候，会<strong>强制重新从系统内存里把数据</strong>读到处理器缓存里。</p>
<p>所以，如果一个变量被volatile所修饰的话，**在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。**这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p>
<p>volatile与可见性</p>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p>
<p>前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的<strong>可见性</strong>。</p>
<p>volatile与有序性</p>
<p>有序性即程序执行的顺序按照代码的先后顺序执行。</p>
<p>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p>
<p>而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。</p>
<p>普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。</p>
<p>volatile可以禁止指令重排，这就**保证了代码的程序会严格按照代码的先后顺序执行。**这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt;add-&gt;save 的执行顺序就是：load、add、save。</p>
<p>volatile与原子性</p>
<p>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</p>
<p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</p>
<p>为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。</p>
<p>所以，<strong>volatile是不能保证原子性的</strong>。</p>
<p>在以下两个场景中可以使用volatile来代替synchronized：</p>
<p>1、运算结果并不依赖变量的当前值，或者能够<strong>确保只有单一的线程会修改变量的值。</strong></p>
<p>2、<strong>变量不需要与其他状态变量共同参与不变约束。</strong></p>
<p>除以上场景外，都需要使用其他方式来保证原子性，如<strong>synchronized或者concurrent包</strong>。</p>
<h5 id="13说说使用5个线程去计算一个数组之和的思路">13.说说使用5个线程去计算一个数组之和的思路。</h5>
<p>五个线程交替累加计算数组之和，这种方法其实不如单线程直接累加快，因为交替累加需要前一个线程计算的结果。</p>
<p>将数组分为5等分，让每个线程计算自己负责的那份，并发计算，最后汇总结果。这种方式比上面的速度会快些。因为线程独立计算，不依赖其他线程的结果。最后几个线程将总数累加即可。</p>
<h5 id="14谈谈线程阻塞的原因有哪些">14.谈谈线程阻塞的原因有哪些？</h5>
<p>资源不足，线程获取不到资源，又不允许抢占剥夺其他线程的资源。</p>
<h5 id="15谈谈你对notify的理解">15.谈谈你对notify的理解？</h5>
<p>会唤醒等待线程队列的其他一个线程。notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
<h5 id="16你觉得lock和synchronized的区别是什么">16.你觉得Lock和Synchronized的区别是什么？</h5>
<p>synchronized和lock的区别</p>
<p><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180904143958577.png"
	width="945"
	height="414"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180904143958577_hu5c606ae75718355405ab8e724f49bead_39851_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180904143958577_hu5c606ae75718355405ab8e724f49bead_39851_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="区别"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="547px"
	
></p>
<p>区别如下：</p>
<ol>
<li>来源：
lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；</li>
<li>异常是否释放锁：
synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</li>
<li>是否响应中断
lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li>
<li>是否知道获取锁
Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</li>
<li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li>
<li>synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，</li>
</ol>
<h5 id="17谈谈你对reentrantlock的认识">17.谈谈你对ReentrantLock的认识。</h5>
<p>ReentrantLock在Java中是可重入锁
<strong>可重入锁</strong>：即递归锁，指的是在同一线程，外层函数获得锁之后，内层递归函数仍然有获得该锁的代码，但不受影响
<strong>ReentrantLock公平锁和非公平锁：</strong>
ReentrantLock锁实现了Lock接口，里面具体锁的实现使用了抽象内部类Sync。Sync有两个实现类，NonfairSync和FairSync，即公平锁和非公平锁。</p>
<h5 id="18调用run和start的区别">18.调用run()和start()的区别？</h5>
<p><strong>线程的run()方法是由java虚拟机直接调用的，如果我们没有启动线程（没有调用线程的start()方法）而是在应用代码中直接调用run()方法，那么这个线程的run()方法其实运行在当前线程（即run()方法的调用方所在的线程）之中，而不是运行在其自身的线程中，从而违背了创建线程的初衷；</strong></p>
<h5 id="19transient关键字的用法--作用--原理">19.transient关键字的用法 &amp; 作用 &amp; 原理。</h5>
<p>1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</p>
<p>2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</p>
<p>3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</p>
<p>第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的。</p>
<p>transient用于修饰不需要序列化的字段，如果一个引用类型被transient修饰，则其反序列化的值为<strong>null</strong>，如果一个基本类型被transient修饰，则其反序列化的值为<strong>0</strong>
，如果字段的引用类型是不可序列化的类，则也应该使用transient修饰，它在序列化时会被直接跳过。</p>
<h5 id="20threadpoolexecutor的工作策略有哪些">20.ThreadPoolExecutor的工作策略有哪些？</h5>
<ol>
<li>任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</li>
<li>*有界队列。*当使用有限的 maximumPoolSizes 时，有界队列（如 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>ArrayBlockingQueue</code></a>）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</li>
</ol>
<p>被拒绝的任务</p>
<p>当 Executor 已经关闭，并且 Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>execute(java.lang.Runnable)</code></a> 中提交的新任务将被 <em>拒绝</em>。在以上两种情况下， <code>execute</code> 方法都将调用其 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>RejectedExecutionHandler</code></a> 的 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</code></a> 方法。下面提供了四种预定义的处理程序策略：</p>
<ol>
<li>在默认的 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>ThreadPoolExecutor.AbortPolicy</code></a> 中，处理程序遭到拒绝将抛出运行时<a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>RejectedExecutionException</code></a>。</li>
<li>在 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>ThreadPoolExecutor.CallerRunsPolicy</code></a> 中，线程调用运行该任务的<code>execute</code> 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li>
<li>在 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>ThreadPoolExecutor.DiscardPolicy</code></a> 中，不能执行的任务将被删除。</li>
<li>在 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>ThreadPoolExecutor.DiscardOldestPolicy</code></a> 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。</li>
</ol>
<p>定义和使用其他种类的 <a class="link" href="https://blog.csdn.net/ioy84737634/article/details/43940977"  target="_blank" rel="noopener"
    ><code>RejectedExecutionHandler</code></a> 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时。</p>
<h5 id="21threadlocal了解吗说说原理">21.ThreadLocal了解吗？说说原理。</h5>
<p>Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。见上面。</p>
<h5 id="22权衡多线程的性能">22.权衡多线程的性能。</h5>
<p>多线程一般需要注意同步问题，但是同步必定会牺牲性能，权衡性能不同场景需要采取不同的锁。</p>
<h5 id="23如何理解同步和异步阻塞和非阻塞">23.如何理解同步和异步，阻塞和非阻塞。</h5>
<p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>而异步则是相反，<em><strong>调用*在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在</em>调用*发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<h5 id="24比较一下线程和协程">24.比较一下线程和协程。</h5>
<p>协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局部变量，有自己的指令指针（IP，instruction pointer），但与其它协同程序共享全局变量等很多信息。</p>
<p>协程(协同程序): 同一时间只能执行某个协程。开辟多个协程开销不大。协程适合对某任务进行分时处理。</p>
<p>线程: 同一时间可以同时执行多个线程。开辟多条线程开销很大。线程适合多任务同时处理。</p>
<p>1.协程，即协作式程序，其思想是，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component</p>
<p>2.线程，多线程是阻塞式的，每个IO都必须开启一个新的线程，但是对于多CPU的系统应该使用thread，尤其是有大量数据运算的时刻，但是IO密集型就不适合；而且thread中不能操作unity的很多方法和component</p>
<p>线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。</p>
<h5 id="25从源码角度讲讲你对thread类中run方法的理解">25.从源码角度讲讲你对Thread类中run方法的理解。</h5>
<p>如果直接调用run方法会在调用线程执行，如果调用start会在子线程执行。</p>
<p>线程的实现有两种方法，第一种是继承Thread类，重写run()方法，并调用start()方法;第二种是实现Runnable接口，并实现接口中run()方法，然后调用start方法。那么从源码上来看，这两种方法有什么不同呢？</p>
<p>首先，分析下Thread类中的run（）方法到底做了什么事情？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            target<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><p>run（）方法很简单，只是做了一个if判断，如果target不等于null，就调用target的run（）方法，那么target又是什么东东？我们点进去看一下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#75715e">/* What will be run. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Runnable target<span style="color:#f92672">;</span>
</span></span></code></pre></div><p>target 就是runnable，那么runnable又是什么呢？点进去瞅瞅：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Runnable</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Runnable就是一个接口，在这个接口中只定了一个抽象的run()方法。</p>
<p>在分析完Thread类的run()方法之后，我们回头再来分析线程的第一种实现方式——继承Thread类。</p>
<p>当用继承Thead类这种方式实现线程时，必须要重写run()方法，那么为什么一定要重写run()方法呢?因为通过上面我们对Thread类的run()方法分析可知，如果不对run()方法进行重写，此时target等于null（因为没有传入target接口），跳过if判断，那就等于run()方法内什么都没有做，那我们继承Thread类有什么意义呢？只有当我们对run()方法进行重写，写入我们想让线程执行的代码，继承Thread这种方式才会有效果。</p>
<p>第二种实现Runnable接口这种方式，与第一种方式的不同点就在与我们传入了一个Runnable接口，因为此时的Runnable target不再是null，所以进入if判断以后，会调用Runnable 接口中的run()方法，根据接口的定义，当我们实现一个接口时，必须要实现接口中的抽象方法，所以run()方法也必须要重写。</p>
<p>通过以上的总结，大概明白了两种实现方式的区别，无非就是第一种方式调用了Thread类的参数为空的构造方法，此时targer的值为null，而第二种调用了传递参数为Runnable接口的构造方法，此时的target不等于null，进而调用Runnable接口的run()方法。</p>
<p>打开Thread类源码，注意观察这两个构造函数中init方法的第二个参数target：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Thread</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//target的值为null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        init<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Thread-&#34;</span> <span style="color:#f92672">+</span> nextThreadNum<span style="color:#f92672">(),</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Thread</span><span style="color:#f92672">(</span>Runnable target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         <span style="color:#75715e">//传递进来了Runnable ，所以target的值不再是null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        init<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> target<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;Thread-&#34;</span> <span style="color:#f92672">+</span> nextThreadNum<span style="color:#f92672">(),</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><h5 id="26谈谈java内存模型">26.谈谈Java内存模型。</h5>
<p>在Java语言中，采用的是共享内存模型来实现多线程之间的信息交换和数据同步的。</p>
<p>　　线程之间通过共享程序公共的状态，通过读-写内存中公共状态的方式来进行隐式的通信。同步指的是程序在控制多个线程之间执行程序的相对顺序的机制，在共享内存模型中，同步是显式的，程序员必须显式指定某个方法/代码块需要在多线程之间互斥执行。</p>
<p><strong>主内存和工作内存：</strong></p>
<p>　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p>
<p>　　JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>
<p>​                                  <img src="/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxgAAAFdCAIAAAAPFVzFAAAABmJLR0QA/wD/AP&#43;gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nO3dvXaqThuH4Wfe9T8UTZGVI8AjwN1Ypd0dlNrsLqVdGiilS5vKJnIEegQui8C58BYI8uUHI4rgfRV77aggMhP55ZkBVBRFAgAAgPr&#43;1/YGAAAAdBVBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQNN/bW8AAAA9oZRqexNwqSiKGlkPQQoAgMY0dXjGTTUYeRnaAwAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0PRf2xsAAPemlGp7E24liqK2NwF4LgQpAM&#43;ol4GjxwEReFgM7QEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGj678rllVKNbMfTiqKo7U0AAACarg1SQhS4Qo9jaI8/WoP43QGArmsgSAGVSAmnkTUBoAeYIwUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCpN0HKt5UauWHugZEbxk8oVXgyWUIpZfv33VA0IGlcEQndUbltL1u0sVciFv&#43;mtb0VAHBXdwtSoTu6YWgJ3blnOF/TQe7RzS4QMRdRFEVRtN4/mQQrNZZVFEXRwgzdkapS2trQHXFkbVbaGmfk28Jfesb7n4GISPjzvbE&#43;Cg3fzKYtPXl7uXTFj9837pNyoihKG&#43;3W7wUAj6AfFSn/cybO13Tg24Uj7m8&#43;I9l&#43;EqxWVn4N1irKCRwj9wa2UkoNZ5vbf5bnksTcg5VVbo0oWpiZhTI5yv&#43;cbcQbV2Wv&#43;rkmn6jHnhxZcz7bPX7fiLc3iqL7vF3aaMQpAM/gv7Y3oAG&#43;Pd46wWIg/ufWeRWlxulTs28niNZXlit8W81fgygKbDXeXrmtnRIfBe92AL5Q6M496yMaxP/dOkE0FXc03H3k09aeb6uxV3p0qGa5n61VtDBlMF1H0&#43;RNRsPv92B9rtT14H3jyha8MgbF7/uYvQgAmtJaRSr313/uj/tsTSl0Ryo3G6Y81uPb463zNR1I6M7lYzpNShyBY4i1Kh0J92NJh3JDvKJi6SFbYDAX0dkD6v0960hN&#43;POdNI3/OXu7YFTPcIJ8xSv/QKH4mKz5sgHDR&#43;4bcRWqkGCOV9gqSKa8dKHyxmSrUw/TiwCgMS0FKd/&#43;K1&#43;HA5k3jsOSObFEtr/pkEz4872R/SjOkUX8pSeb2VApNdx9FEsSmVUlMiN71uowaHRmaO&#43;hPPVIjf&#43;ZRFzfHm&#43;dfxVFqJPC3&#43;3ZmU&#43;&#43;PfYM5595YgLXo56ikM1P5R5yZSS6xmP1IgBoTktBylwc/o4f/Hk3ZPP9kySp/X9FRILdRpLCwJFF9pNsVo4T5GPU4OVtn7DKx7/wNzsMM5iuS6NCVY&#43;171iZodbitQoSWQ9wIAzduWcYhoiIv9zmzi4o1BSPzJAKf743Vfk6I45RX9NBeQJXEq&#43;tVe/6xt08QC8CgCa1Ptnct/PDaNkk5S89sSalQ1ZhEZHQHS1fiiflxVNj8qM4&#43;2y0Hx3azke2f/LEsQepO6TbUz5M1g1GtWoSlYfk7IHwzsfC0P07e1t9vYtIPliLlGqK1QNucT1rMxsebVrfrphSFT&#43;h1PD7PTh0o0fRlQiVRZwC0ButDe0lB&#43;LlJH8KXSZJ5XPU0UV8ezjbJPWI0e&#43;/9Fi6spJhwcKbf84krmqINx65w0PdIZ5XVcxdN3X6QJI9RpYPk1dGomukq73nsTDYSf2xvIPQHY29OFkHznZcUbQK3dHYsyyrcnGR8gU2oKmL4Q8AKrUSpOLBk6A6q5gTK74AVC5HHV/EX3pyqEdkCxHDV2OzC&#43;L/h&#43;4oKUL4S894f38TeftYB44cBhJbcexA0pUjzT3jVLEIVYdvq&#43;FMnP15eIPpOnCkWJjyP2fiBIuJiEhQvLjY2CuMFD/MZaO6Vd3pSscGgAvdLUgFu40Yr0OR/QylzITfOAqlzIkl3tLP5agTi8QTWapqR4OXN/GWvm&#43;reFBmYUpy8vz0Zf&#43;S6Xo9DdJa1zB3UaI2jpTpYbpbR5oHOJYXz7vMRKTd5yi&#43;/Go2hw2m62hleWP7J30oewrecLrOV/RKZ/s92Nl6N2oCVdPZ9XSrYwPAWXcKUqE799Jp44OXNxFvmV7yoDgpxZxY4s3n28y43rlFDldGyKYfc2KJNx57VnwM9W01cn92b8WZwoc5xfmhvTaOlB09xjzAMbJ43mWmkV/raujtrmIosWfO27kzWXjVDnW1I1EFSPEJ1VuUrZvdLR7A8AJNw9ScbVnOHtbHQ5l5iJwjKSCMH8NipcZNyeWbDab7Dzzo4vsryu9&#43;8imnyRX7fPW9jfcZ7m3l&#43;mi9sSnZHbW2JPD6M7t5qE/QHWnhgeIUFcKdldck/zOfeNCaWop96Lrg9GFKEEBeBZ1/&#43;gsf9VeuYZGHc5PLz&#43;WO4UvvRFJMcTlFU76a9rZvddIG2VX1VT3uOQFZzep1sW60qYonhFQ/VCiNCJX8d6FF&#43;QWyfSPpjtDUy17yRtJUuy89RtFjXba23n8LdTT18/VITRBVzTYUtde11Hd8cqQTfJtNZZV2&#43;exX7j30qJC4cV1S1Z1W6py89Rld/y4XccIy/eDqXioA&#43;78u3Nhwz34WzSlq19c5/T1c3UITdAVDbbUswapx1B37xUOVLfe&#43;dn1HwtzlyyLSuyiFvV15/f1c3UITdAVDbZUH25a/DyiNu4C26EyAwAAd0aQ6p5snLo1/roCAOAEglRX3SHfEKEAADit9XvtAQAAdBVBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQFMDlz/oxL11AQAAGndtRaqpe/49rUZa8TEpnNR2&#43;&#43;BKvp005cgN00dDd3RoY9vPvDT5IX1VsljlIgC6gqE93ETbAbUb2m4laPNtNfasVdyOX/KTJqa/8rVv3cAxvHEclsyJJbL9TeNW&#43;PO9EeP9z&#43;D4IgC6ghuAAHg66sp7H4XuaDh7W0UL89yLxAnW04H4thpv4/9KHMOkaunsIjqu/Vy4Gk3QFQ22FBUpAKhp8PIm4o1PjMP5thrONumP5sSSzfdPXGvyl55Yk1KKKiwCoBsIUgBQl7kIHEO8cWGK1GHe1HISRSsrs8AhSeVz1PFFAHQCQQoA6htM1/GsJtnMhnGW8u2xZzhBFEVRedjOnFiy2QWFHHVyEQBdQJACAF2D6TpwjLjWFP5uRd5e0tlN/tLLvtScWOIt/VyOOrMIgA4gSAFATaFrp&#43;N5wW5/Bl48cWqZnsA3LoQic2KJN59vM&#43;N65xYB8PgIUgBQ02A62Q33U5sOZ&#43;OZi8Ax4nlTSs1fg&#43;KEJ3NiyWazyc4zP7cIgIfHiZoAnk5fz1Hv6&#43;fqEJqgK7j8AQAAQPsIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgCgLXRHSimlRm7Y9qYAaAVBCgBq8m21N/x&#43;D6IoitbTQRqqcmy/7Y0FcFMEKQCoyVxEURRFgWMUn7FW0UHF8wD6hiAFAACgiSAFAPUkI3vD2UY2syFjeMAzI0gBQD3ZkT3DCeJxvIXZ9mYBaANBCgB0hD/fm7a3AUDr/rtyeaVUI9vxtKIoansTAGjwP2cbEZHvvyP5Wk8HbW8PgHZcG6SEKHAFYijQVf7SMyxLPG&#43;zkc1Q7VbRYtj2NgFoAUN7AFBX6M496&#43;Pf636O1Mryxkw2B54TQQoA6gndvzNx/h1ml5sLJpsDz6qBoT2gjFHLSzAs3lHBTpyv6UC4KwwAKlK4mQgntd0&#43;0Gcujk4u98aZ28MMZ5zWhxsK3VHN65f59qW3hbz8lSBIAUBjuEUM7mcw/bjV7Dx/6cnbC&#43;eiXkRd&#43;ZexUteu4Zn1eO/1&#43;KM1hV3Uor7u/L5&#43;rg65exP4tpq/Bpdef&#43;PEq0N3VKOEaq26PiuwwZYiSLWpx3uvxx&#43;tKeyiFvV15/f1c3XILZvAt9XYu&#43;iVScy5bIlSKArd0fD7/eJ01k0NthRDewAAPL79rYmyAsc43KXoIJOL8s&#43;urMIDVcPP/udsY330OkU1iyAFAMAzCH&#43;3Z2c&#43;&#43;fbYM5x/ZnJr7gpcMy2PIAUAwBMIf743sv09dS5eHKO&#43;poNy/SspXlmrjs&#43;OahxBCgCA/otvD7mZDY&#43;WlHz7yJQq31Zq&#43;P0eFMYNISIEKQAAuqE03DacbWQzG14w8ha6o7EXz48KnO244iJRoTsae5ZlHXnvuE6FCr0JUr6t8h0juZpY0vFKvWb/BIO9AIAuqBxuK002L5eMfFsNZ&#43;Lsz8MbTNeBI8XClP85EydYTEREAneUz2Zjr5DXuFhnxt2CVOiObhhaQnfulePyZhccOl5yImea6MeyirtcWOwy5VSfewnRCwDQDbvPUXy4y17NYDBdx7fa/kkfMheHVwyn63w2K53t1&#43;9LI9TUj4qU/zkT52s68O1CyvnNZyTbT4LVqlC9zF2OuHBKaOiO/srX4QlvTJYCgLuJv8Db3oqOev23rp7XZC6iaPHn/hvUP324abFvj7dOsBiI/7l1XkWpcfrU7NsJovWVwXkwXa8zP3xYs7G39BcmE&#43;4AII440Y0vBBpFUZqlbv1ezyTYcT/Iq7VWkaocLPPtwshZ6I4OY7HV42u&#43;Pd7GN2J35/IxnS4yNSVrVSo/7kf2xl5yd9F4Rbk7jaqTNxsdvnL7LECEOsHTizvA3WJNOmLwnB2v8rpOlZPNz09BORxN42tGnX3PsWe8/2Ew75joOhevIXCMzADayjoMtwaOkV58dWXlrsOaf6pykcwYXX547sgFX5P3z7w&#43;jlzlzS0&#43;Vt6ma12/2/nyu7R/EfLjNGfbNvTizb2yuvduvUb&#43;QU/&#43;xZR5iB60/dqVre29nJ3&#43;1yFFq/7vo0cqh6z1z3gJqFSgy3VUpAqP1WZpFbWkWVKaWbllA5/xWlQmawVz4Cq3pozchHsWtoN&#43;fjHyBOLVDVMlfxeLuSoWk1wcTw62uEKcndV0O0Nt2vBtMnu00nK7/v4rt/Owh99Dbn277Q7tHhlK1/2K51z601qy&#43;NsCU5rsKVan2zu27lhNHNiyeb7Jx7L85eeWJPqEzmzI2&#43;hO1q&#43;FE/Ki2/VWPhKiifchT/fGxHZzke2f6ReWl0cDd3R2Gv3sq49qKWX7xdVnV9ye9lfppVl/3O2KY3FxuqfkZs/ZfMw4nuiQzzyyQdp99DrIcc/ebXC4o13FTyObNcq965aR51mN&#43;wW31FALS0FqUN4WU7yJYpMksrnqKOL&#43;PZwtkmOfqPff9nDc&#43;Worv85EyOuKHjjkTs8HNeLpY58YPLt4WxjOEFLMeqZj5GhO/f299AM3fnWCY6UpeIpcaVoXLoEilJJSh4czvK9YMBwYcaLHKbeDaYfloi3bDdJpR&#43;q3D3qNnqdA2J1V8x2lVZ6C5p1rGs9mna/o/DMWglS8c18goqsIvsktQsKOer4Iv7Sk0M9Izu5fPhqbHZB/P/QHSVlA3/pGe/vbyJvH&#43;vAkaT8dUZyVdjmLp5x4W87x8i0hCgi4n/O3i64K/kdb3je7skH2b5RbrIrm/sa6Wo5sHVXVyJUFr0O93e3IBXsNmK8DkXi&#43;09nb0AdR6GUObHEW/q5HHVikXigqKpKNHh5E2/p&#43;7aKbxK0MCWtbbzsXzJdr6dBWsAY5saMDuNEoTsazjYV5wBe4&#43;x3E8fIvfgGUSL7UzSPn2FyxE1veB7&#43;fKc9&#43;666cpB7mgNbrusUOsupK/pmlnuYIeIO68rvBXql1vG48gh9ycuK5&#43;zJ4af9IF1u5rglYhi5kZszixwqDLnKw/6F&#43;&#43;VWlhiOY1mr6NisnOpZzI3OL885tvcaaZqbrvDsymu93ck53oFjJL2hdOZmXvJkoQBVMX&#43;32NAnJg4fbnh&#43;dNM1O4d2i9yoNW/aSe72Fhe6fjNyfWZlSfEsmdyP1Scpl15Z8WVYUyc6Rnc78IWb0fYm4CINttTNg1Qyl6l8bYLD0a90GIu/Ty5aJJ&#43;Vyq9Nv5fKWe6yIFU1CtRUrirsvXTtTay7&#43;EZ3PkY2FaTiJqlomBOn7uWD1GE63eHl&#43;YXjV1QcvQrHw8qNa&#43;GsvS52kgc5yKUaDVIVpyQfD9jZJFVe8FyXO6cTLVjxhXqBs2trZNuu9zhbgtMabKmbX9l8EUWL8qOD6Tqa5n5Hck&#43;bFUsdWWSQe2k8Bhd/N5mZx4ZqJiKG81V1CuA4N7IoY3X42XCCdeF9byjKXLq3Q9Qtr2sc7MT5Z8rPXG/xzNS20B0N1ag0yy254bm3rVzBiRuet3byQbyrb7rbG9SV7dQXj&#43;6&#43;50Z3zYkl3vY3FDPXe5KvG&#43;PYgo97ud9sr5NSg9b94qrbHyrX3/&#43;uhY5o/fIHzUrOwcoe2w7nZVVNcSqfi5919/syxm/blQkld5iOYC702&#43;CWNzxv/uSDum7UVY5OETvi7Hpu2j0eR9UkvORcl&#43;MnKR9Z8HGlX43l1q/1F/w12/BsXQuPrw/32tNhLh75F/BGJYem/mo89lfp3XnZ6qGIWKs0Qu8&#43;R8p7yxQmReJM/WKrsf3qJA&#43;Zi8gUEV8kvuF5rvjo22r&#43;WpGVkpMPovbvf06d4EGUq0&#43;yPwdhf8Zx2o36MaG8lbLoc3YtPL6eVaR6JfuXX/mIVbdsUOvvxRMRSh0/kfDuinNQMoXIG97w3LfjFNXiZVmL0j1AnaAFgz/vRlp92vOX3r7YdOKM48HLW&#43;EaZJkLfXRC2uvu8F7P2LXQEQSpR8cx8gauuOF56M49KV3/FHOWz/WVW7qweL1/Q2mH5Z448PAr28f7oCQT0u&#43;nZ2Saf5zDPHGSe8J3b/Hb5b&#43;wO7Q7s/atdANBKnO6McxMizOQ1Lq&#43;J1Z6t/x5cL3vuKG55lLoWc8UHVKqBPcn7mI4gl4&#43;46zdYK0T5iL&#43;D5CSiml5q9Bdo7UYLrOPPlXvqpPEgbwyK69a5u6433f&#43;kd776nbzxW48i2a7RihOxruPnJxpeKhjuF3p0V93fl9/VwdQhN0RYMtRZBqU4/3Xo8/WlPYRS3q687v6&#43;fqEJqgKxpsKYb2AAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANDVwi5h7XtYIAADgcVwbpDjPEwAAPC2G9gAAADQRpAAAADQ1MEcKqMTkOQBA7xGkcBNMngMAPAOG9gAAADQRpABAQ&#43;iOlO3XXMi31cgN0&#43;WT/wPoLoIUAFzLt1WFUk7yl57x/mcgIhL&#43;fG&#43;sj&#43;mgja0F0CCCFAA0wHCCKGtllV6SyVH&#43;52wj3vii&#43;AXgkRGkAKAe31ZKDZMktB/f28yGuTw09gpLhe7c29egQne&#43;dYIoChxDrFWUt6ZMBXQJZ&#43;0BQD3mIooWoTsa7j6ihSkiIosoWpxeKPz53sibiIj4n7O3j2ggQukJ6D4qUgBwjdAd5cflchOmkvno/udss/&#43;fPd46/8z2NhhAkwhSAHCteHwucIzcz4d5UqE79wzDEBHxl1vnKzN6V5goxQwpoGMY2gMAXUtbzaU8q7wgdP/O3lbB63y4EzEX61w1ylolw4MAuoiKFADU5tvD2UY8mUTrf69JWWmYjN4lZab9hPNgJ4zlAX1FRQoA6vFttZwEzna4m5giMl1H0&#43;Sp0B2p5Udx5vlibTKzHOgpKlIAUI&#43;5yIzG5a/FOSxfHurM5c&#43;LF5OqfbV0AK0iSAHAFcxFxUU4sxeHOjMDqngdKSZMAd1CkAKABvi2UstJfInN4HVOZQl4EgQpALiObyullpNDNWkwXUeTJdcyAJ4BQQoA6nFH8Wwoa2KG7ijOUKUhOXMRRV/ylzQF9JyKoqjtbQCAu1Kqn199ff1cHUITdEWDLUVFCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQNN/169CKXX9Sp4ZV28DAKCjGghSQhS4AjEUAIDuYmgPAABAUzMVKaCASttpFHEBoB8IUrgJgsIJpEwA6A2G9gAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADT1Jkj5tlIjN8w9MHLD&#43;AmlCk8mSyilbP&#43;&#43;GwoAAHrjbkEqdEc3DC2hO/cM52s6yD262QUi5iKKoiiK1vsnk2ClxrKKoihamKE7UlUyW5t9CckLAADE&#43;lGR8j9n4nxNB75diDm/&#43;Yxk&#43;0mwWln5NVirKCdwjMzq7b/ylT7ujUvFLQAA8JT&#43;a3sDGuDb460TLAbif26dV1FqnD41&#43;3aCaD04sfAlzMXa3P938OfdmM2&#43;f8Lp9Nq1Ap2jlBKRKIra3hAAeBStVaRy42lJGcm3C0NnoTs6zG6qXCSOUV/TgYTuXD6m00WmpmSt1sW8sx/ZG3si3viwovj/B8PZ5sTGv72QovBw4q5763eJoij9Nbn1ewHA42spSGUGy7KjZebEEtn&#43;pgNn4c/3Roz3P4Pji/hLTzazoVJquPtYmPm3yawqkRnZs/ZzpETODO0dhO7f2cZw/plVT&#43;KmkrMHJI7UdcZXM4s29sqHEseauxWK0l8T4hQASHS1y1YSOEY5rmSeMpwgiuKEs/v/qfKZbKLxK90Mj8cFi7aryyOSdVbUyldV41lTmq2CW7kRptX1TBV8vt6ZaUNHhcb672jUeofxzbtkjVnc7ZGl2hwrxbaqO6a63xVHO2uD96NK3Vugy/U18/VITRBVzTYUq1PNvft3DCaObFk8/0T1wT8pSfWpFT9KSwiErqj5UvxpDw19kSKx8&#43;4/BT&#43;fG9EZDsf2X52iePn7SWn/kWTpc6Je&#43;U1Z9tST3fHcdKdmarOL7n6or/09qVJ8T9nm9JYbKx&#43;NSl/yuZhxPdUh3iAkw8KHanyqUtI/a&#43;S8sbEjzfeTwCgG&#43;p&#43;jVZ&#43;sV7wqnxF6lCUsFaFMtThh/zh9egiuQJHrkp1pA6xssQwDNn/k33FJaWOUjHsMsd2u0YTpGtopPlOv1Hl&#43;zbubCEo0zCBYxhOcLKtLit5lRYOHKN&#43;w2p1h2t2Y4OtcKMGvV0/adDjb6Gevn6uDqEJuqLBlmqlIuXbYy859hSnNcU1qV1QqEcdX8RfenI4KmYnlw9fjc0uiP8fuqOkjuQvPeP9/U3k7WMdOJKUvy41eHnbX6GqlsJ&#43;1/vz/VgRotbitcoV5Y/QRtVhX0IUEfE/Z28f58&#43;YzEebUqSumgLnf8421gWrrnCfkw&#43;ubP27aa&#43;fAEAL7hakgt1GjNehiEj4u80de&#43;IolDInlnhLP5ejTiwSDxSV8pjEkcdb&#43;r6tlBp&#43;vwcLU&#43;JLd1of05f9S6br9TRIx/aGuTGj6hGb8HcrySfRlx7SL3lxmmzKi9QNRnWD9rEtPxa2bsL/TEZyfXu8rT/VP/zdns06cVL/Z14y0JtZ831OPuhKhMoiTgF4EncKUqE79yT5c3/w8ibiLdNLHoy9/IvNiSXefL7NzI86t8hhpks2/ZgTS7zx2LNWUbSeDnxbjdyf3duqkLoOc3byw0X76lbojg6H0ND9O9uIZuGivuwRtHwQvTISXSNd7e2PlKE79wzDEBHxl9vc5esL05mOzFUKf743VSdwZsQx6ms6KE/gSopXVrbbJHFruPvIV0GR6GL4AwANNw9S8RFnOHtbHapG5iJwjOQgOH8NinNazIklm80mO8/86CLxIW24&#43;8imnyRX7fPW9jfcZ7m3l&#43;miqnh1ymC6jqeYpx&#43;ksv7VsK4ch47FqaYCVuj&#43;nb2tvt5FRMRc5ENLYZpTdaKJ61mb2fDoOQLlYJ4&#43;Edcyo6jQ5leefFBXt6o7Xem6ANCMWlWNY6WO61fSkEP5oPxYbuJMOr359MTk&#43;pPK65KqCd232KU3Wm0jb3FisvnKMpygamb56cnm2Ssl7H/ITgvPT14XsazKExMuuWyCzmzzaxqiwXZs9hvjdl33FrqynXX19XN1CE3QFQ22VOuXP2jWYLqOoihfPkgeq65YlM/Fz7r7qE3UzT/ib1eEKBah6vBtNZyJE8RrGEzXgSPFwpT/ORMnWExERILi3avHycVeTwweap58oC3eyekWFZ5VdUgTc&#43;bk3AA0APRbH&#43;61p8NcPOwXfnwoUh25qVmr2&#43;mNVW5MzjqMH&#43;8&#43;R8p7W0VRdkRuMF1HL7Ya269O8pC5iEwR8UVEhtN1NM2uz7fV/DU4neSaOfmgrnSHl/f/3doijXGP30sB4HZ6VpHqj2zhocHV1qpYnHjr9AWtFiGKQ3uZQuTrv3X1XDZzEUWLP1e8aZsnH5TdqJ&#43;cRgkKAFLPWpHqiGx1Skp/&#43;tc9dtY95lWuvyulspOC3al7Up82mK4ntlLj/Y/WKlq3fuvFQj&#43;5KXXHm/oBwOMjSHVAn8ZxQneUv79PqjBMJyJiOGfG1fTf23CCo/HHt5PzPcVwgor3NxdRtGhssxpzh85AhAKAggb&#43;uOQv1Gto7L00Tt16z8frf4QSVOiOhruP3FBdxUOdwa9M6/raBH39XB1CE3RFgy1FkGqZ9t67Q755hAjVS4AeGBcAAAJqSURBVPzKtK6vTdDXz9UhNEFXNNhSDO11FeM4AAC0jrP2AAAANBGkAAAANBGkAAAANDUzR&#43;qeFwMEAAB4EA0EKaYkAwCA58TQHgAAgCYuf4CGMc4LAHgeBCk0jKFeAMDzYGgPAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABA039tbwAAtEAp1fYmAOgDghSApxNFUdubAKAnGNoDAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQ9F/bGwAAQH8opdreBNyViqKo7W0AAADoJIb2AAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANP0f7j3Q9KJELeYAAAAASUVORK5CYII="
	
	
	
	loading="lazy"
	
		alt="img"
	
	
></p>
<p>　　线程1和线程2要想进行数据的交换一般要经历下面的步骤：</p>
<p>　　1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。</p>
<p>　　2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。</p>
<p>Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：</p>
<p>　　<strong>原子性（Atomicity）</strong>：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。</p>
<p>　　基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。</p>
<p>​		**可见性：**一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。</p>
<p>　　Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。</p>
<p>无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。</p>
<p>　　除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。</p>
<p>　　使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</p>
<p>　　使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</p>
<p>　　final关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。</p>
<p>　　**有序性：**对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。</p>
<p>Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，</p>
<p>在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。</p>
<h5 id="27两次调用thread对象的start方法会发生什么为什么">27.两次调用Thread对象的start方法会发生什么？为什么？</h5>
<p>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</p>
<p>关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：</p>
<ul>
<li>
<p><strong>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</strong></p>
</li>
<li>
<p><strong>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</strong></p>
</li>
<li>
<p><strong>在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来。</strong></p>
</li>
<li>
<p><strong>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</strong></p>
</li>
<li>
<p><strong>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。</strong></p>
</li>
<li>
<p><strong>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：</strong></p>
</li>
</ul>
<p>public final native void wait(long timeout) throws InterruptedException;</p>
<ul>
<li><strong>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</strong></li>
</ul>
<p>在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</p>
<h5 id="28thread的sleep方法会清除中断的状态吗">28.Thread的sleep方法会清除中断的状态吗？</h5>
<p>Thread类的sleep(),wait()等方法，在接收到interrupt()方法中断时，会抛出异常，同时会将中断标志置为false,如果确实需要中断该线程，则应该在捕捉到异常后，继续调用interrupt()方法进行中断。</p>
<h5 id="29为什么线程通信的方法waitnotifynotifyall被定义于object中而sleep方法被定义在thread类中">29.为什么线程通信的方法wait,notify,notifyAll被定义于Object中，而sleep方法被定义在Thread类中？</h5>
<p>wait是用来释放锁的。wait、notify、notifyAll被设计在Object类中的原因是，JAVA提供的锁是<strong>对象级</strong>的而不是线程级的，<strong>每个对象都有个锁，而线程是可以获得这个对象的。因此线程需要等待某些锁，那么只要调用对象中的wait()方法便可以了</strong>。而wait()方法<strong>如果定义在Thread类中的话，那么线程正在等待的是哪个锁就不明确</strong>了。这也就是说wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中是因为<strong>锁是属于对象的原因</strong>。</p>
<p>对于sleep为什么被定义在Thread中，我们只要从sleep方法的作用来看就知道了，sleep的作用是：<strong>让线程在预期的时间内执行，其他时候不要来占用CPU资源。<strong>从上面的话术中，便可以理解为sleep是</strong>属于线程级别的，它是为了让线程在限定的时间后去执行。而且sleep方法是不会去释放锁的</strong></p>
<h5 id="30说说thread类中提供的getstate方法作用然后说说线程的状态有哪些以及转换过程">30.说说Thread类中提供的getState()方法作用，然后说说线程的状态有哪些以及转换过程。</h5>
<p>新建、就绪、（运行,api中没有表示，与就绪并称Runnable）阻塞、等待、计时等待、终止</p>
<p>从源码中可以看出, 线程一共有6种状态, 其状态转换关系如下图所示:
<img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/1242012032-5b76ed6074ab1_articlex.png"
	width="800"
	height="404"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/1242012032-5b76ed6074ab1_articlex_huf98870c7eae293cb2cc40fd4e77e5c53_122772_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/1242012032-5b76ed6074ab1_articlex_huf98870c7eae293cb2cc40fd4e77e5c53_122772_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="线程状态转换"
	
	
		class="gallery-image" 
		data-flex-grow="198"
		data-flex-basis="475px"
	
></p>
<p>值得一提的是，从状态的定义中可以看出，RUNNABLE状态包含了我们通常所说的<code>running</code>和<code>ready</code>两种状态。</p>
<h5 id="31用至少2种方式手写生产者消费者模式代码">31.用至少2种方式手写生产者消费者模式代码。</h5>
<p><strong>这种设计模式需要满足以下三点要求：</strong>
（1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。
（2）如果缓冲区已经满了，则生产者线程阻塞；
（3）如果缓冲区为空，那么消费者线程阻塞。
<strong>编写之前分析：</strong>
（1）定义一个缓存队列，选择一个集合当做缓存，给予缓存上限，缓存队列只有两种行为（生产数据和消费数据）；
（2）定义一个生产者线程，调用缓存队列中的生产行为；
（3）定义一个消费者线程，调用缓存队列中的消费行为；
<strong>开始编写代码：</strong>
<strong>第一种方式:</strong>
<em>(双向链表LinkedHashMap和synchronized结合)</em>
定义一个缓存队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 公共缓存队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 只做两件事：（1）生产；（2）消费
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PublicQueue</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> putIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span><span style="color:#75715e">//数据插入的角标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span><span style="color:#f92672">;</span><span style="color:#75715e">//缓存区最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> LinkedHashMap<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;</span> linkedHashMap <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedHashMap<span style="color:#f92672">&lt;&gt;();</span><span style="color:#75715e">//缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>T msg<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> maxCount<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果缓存区达到最大数量，则阻塞生产者线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                wait<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            notifyAll<span style="color:#f92672">();</span><span style="color:#75715e">//唤醒所有线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>putIndex<span style="color:#f92672">,</span> msg<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;生产一个产品，当前商品角标为：&#34;</span><span style="color:#f92672">+</span>putIndex<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===文本为：&#34;</span><span style="color:#f92672">+</span>msg<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===缓存长度为：&#34;</span><span style="color:#f92672">+</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        putIndex <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>putIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> maxCount<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#f92672">(</span>putIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxCount <span style="color:#f92672">:</span> putIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> T <span style="color:#a6e22e">remove</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果缓存区没有数据，则阻塞消费线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                wait<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            notifyAll<span style="color:#f92672">();</span><span style="color:#75715e">//唤醒所有线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Iterator it <span style="color:#f92672">=</span> linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">entrySet</span><span style="color:#f92672">().</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>it<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">()){</span>
</span></span><span style="display:flex;"><span>            Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;</span> entry <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;)</span> it<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> entry<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> entry<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;消费一个产品，当前商品角标为：&#34;</span><span style="color:#f92672">+</span>index<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===文本为：&#34;</span><span style="color:#f92672">+</span> t <span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===缓存长度为：&#34;</span><span style="color:#f92672">+</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>定义一个生产者线程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 生产者线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProducerThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> PublicQueue publicQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ProducerThread</span><span style="color:#f92672">(</span>PublicQueue publicQueue<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">publicQueue</span> <span style="color:#f92672">=</span> publicQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">60</span><span style="color:#f92672">;</span>i<span style="color:#f92672">++){</span>
</span></span><span style="display:flex;"><span>            publicQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>定义一个消费者线程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 消费者线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConsumerThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> PublicQueue publicQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConsumerThread</span><span style="color:#f92672">(</span>PublicQueue publicQueue<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">publicQueue</span> <span style="color:#f92672">=</span> publicQueue<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(;;){</span>
</span></span><span style="display:flex;"><span>            publicQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>启动：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProducerConsumerTest</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>        PublicQueue publicQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PublicQueue<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        ProducerThread producerThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ProducerThread<span style="color:#f92672">(</span>publicQueue<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        ConsumerThread consumerThread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConsumerThread<span style="color:#f92672">(</span>publicQueue<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        producerThread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span><span style="color:#75715e">//启动生产者线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        consumerThread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span><span style="color:#75715e">//启动消费者线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>代码分析：</strong>
（1）生产者/消费者设计模式顾名思义就是两个互斥线程，一个负责生产，一个负责消费，两者是线程不安全的；
（2）这里选择使用LinkedHashMap作为缓存队列，LinkedHashMap是一个双向链表，用来处理线程不安全的数据，可以保证取出第一个数据，it.next()就是取出第一个数据。（LinkedHashMap可以保证遍历的顺序）
（3）为了保证互斥线程的安全性，需要做对应的处理，以上代码使用了synchronized 、wait()、notifyAll()来保证。</p>
<p>第二种方式：
双向链表LinkedHashMap和lock结合</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 公共缓存队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 只做两件事：（1）生产；（2）消费
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PublicQueue</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> putIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span><span style="color:#75715e">//数据插入的角标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span><span style="color:#f92672">;</span><span style="color:#75715e">//缓存区最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Lock lock<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Condition addCondition<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Condition removeCondition<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">PublicQueue</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        addCondition <span style="color:#f92672">=</span> lock<span style="color:#f92672">.</span><span style="color:#a6e22e">newCondition</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        removeCondition <span style="color:#f92672">=</span>lock<span style="color:#f92672">.</span><span style="color:#a6e22e">newCondition</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> LinkedHashMap<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;</span> linkedHashMap <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedHashMap<span style="color:#f92672">&lt;&gt;();</span><span style="color:#75715e">//缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>T msg<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> maxCount<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果缓存区达到最大数量，则阻塞生产者线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                addCondition<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span><span style="color:#75715e">//等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>putIndex<span style="color:#f92672">,</span> msg<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;生产一个产品，当前商品角标为：&#34;</span><span style="color:#f92672">+</span>putIndex<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===文本为：&#34;</span><span style="color:#f92672">+</span>msg<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===缓存长度为：&#34;</span><span style="color:#f92672">+</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            putIndex <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>putIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> maxCount<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> <span style="color:#f92672">(</span>putIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">%</span> maxCount <span style="color:#f92672">:</span> putIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            removeCondition<span style="color:#f92672">.</span><span style="color:#a6e22e">signalAll</span><span style="color:#f92672">();</span><span style="color:#75715e">//唤醒所有线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">remove</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果缓存区没有数据，则阻塞消费线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                removeCondition<span style="color:#f92672">.</span><span style="color:#a6e22e">await</span><span style="color:#f92672">();</span><span style="color:#75715e">//等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Iterator it <span style="color:#f92672">=</span> linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">entrySet</span><span style="color:#f92672">().</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>it<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">()){</span>
</span></span><span style="display:flex;"><span>                Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;</span> entry <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;)</span> it<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> entry<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> entry<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>                linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;消费一个产品，当前商品角标为：&#34;</span><span style="color:#f92672">+</span>index<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===文本为：&#34;</span><span style="color:#f92672">+</span> t <span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===缓存长度为：&#34;</span><span style="color:#f92672">+</span>linkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            addCondition<span style="color:#f92672">.</span><span style="color:#a6e22e">signalAll</span><span style="color:#f92672">();</span><span style="color:#75715e">//唤醒所有线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>第三种方式：（最简单的）
直接使用阻塞队列BlockingQueue</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 公共缓存队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 只做两件事：（1）生产；（2）消费
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PublicQueue</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> BlockingDeque<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> blockingDeque <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedBlockingDeque<span style="color:#f92672">&lt;&gt;(</span><span style="color:#ae81ff">50</span><span style="color:#f92672">);</span><span style="color:#75715e">//缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>T msg<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            blockingDeque<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>msg<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;生产一个产品，当前商品角标为：&#34;</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===文本为：&#34;</span><span style="color:#f92672">+</span>msg<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">remove</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        T t <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> blockingDeque<span style="color:#f92672">.</span><span style="color:#a6e22e">take</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;消费一个产品，当前商品角标为：&#34;</span><span style="color:#f92672">+</span><span style="color:#e6db74">&#34;===文本为：&#34;</span><span style="color:#f92672">+</span>t<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h5 id="32interruptinterrupted和isinterrupted方法的区别">32.interrupt、interrupted和isInterrupted方法的区别？</h5>
<p>1、interrupt()</p>
<p>interrupt方法用于中断线程。调用该方法的线程的状态为将被置为&quot;中断&quot;状态。</p>
<p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>2、interrupted() 和 isInterrupted()</p>
<p>首先看一下API中该方法的实现：</p>
<p>该方法就是直接调用当前线程的isInterrupted(<strong>true</strong>)的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">interrupted</span> <span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> currentThread<span style="color:#f92672">().</span><span style="color:#a6e22e">isInterrupted</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>然后再来看一下API中 isInterrupted的实现：</p>
<p>该方法却直接调用当前线程的isInterrupted(<strong>false</strong>)的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isInterrupted</span> <span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> isInterrupted<span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span></code></pre></div><p>因此这两个方法有两个主要区别：</p>
<ol>
<li>interrupted 是作用于当前线程，isInterrupted 是作用于调用该方法的线程对象所对应的线程。（线程对象对应的线程不一定是当前运行的线程。例如我们可以在A线程中去调用B线程对象的isInterrupted方法。）</li>
<li>这两个方法最终都会调用同一个方法&mdash;&ndash;<code>isInterrupted( Boolean 参数````)，</code>，只不过参数固定为一个是true，一个是false；        注意： <code>isInterrupted( Boolean 参数````)是isInterrupted( )的重载方法。</code></li>
</ol>
<p>由于第二个区别主要体现在调用的方法的参数上，让我们来看一看这个参数是什么含义</p>
<p>先来看一看被调用的方法 isInterrupted(boolean arg)（Thread类中重载的方法）的定义：</p>
<p>原来这是一个本地方法，看不到源码。不过没关系，通过参数名ClearInterrupted我们就能知道，这个参数代表是否要清除状态位。</p>
<p>如果这个参数为true，说明返回线程的状态位后，要清掉原来的状态位（恢复成原来情况）。这个参数为false，就是直接返回线程的状态位。</p>
<p><strong>这两个方法很好区分，只有当前线程才能清除自己的中断位</strong>（对应interrupted（）方法）</p>
<h5 id="33分别讲讲jvm内存结构java内存模型java对象模型">33.分别讲讲JVM内存结构,Java内存模型,Java对象模型。</h5>
<p>在说Java内存模型之前，我们先说一下<strong>Java的内存结构，也就是运行时的数据区域：</strong></p>
<p>　　Java虚拟机在执行Java程序的过程中，会把它管理的内存划分为几个不同的数据区域，这些区域都有各自的用途、创建时间、销毁时间。</p>
<p>​                                             <img src="/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAE4CAIAAACi29zwAAAABmJLR0QA/wD/AP&#43;gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nO3de1xT9/0/8FdCCIEEIdyigBIQ6w0sRVpQi1hqb7b1J9of9eeq22&#43;1dZvbartrt06n7X5u3/bb2m292Xbfre7rr&#43;NXL9PVdm2/OKQqtGj5aryVW1BuuUASISEkgfz&#43;OBBDEsLFJCfJeT8fffRxkpzzOe9Efb8/5/M5F57dbgchhBDu4bMdACGEEHZQASCEEI6iAkAIIRxFBYAQQjiKCgAhhHAUFQBCCOEoKgCEEMJRVAAIIYSjqAAQQghHUQEghBCOogJACCEcRQWAEEI4igoAIYRwFBUAQgjhKCoAhBDCUVQACCGEo6gAEEIIR1EBIIQQjqICQAghHEUFgBBCOIoKACGEcBQVAEII4SgB2wH42JU2g9U2pGjVA2hR9RnNNgBW29CVNgPboRFCQkDm9FixaDgxikWCTJkkLTFGKhHmyKXsBuYPPLvdznYMN8Votp1t7L5wVa9Q6tq0JrbDIYSErZR4UY5celtWQo5cKpUI2Q7HB0K1AOj6LLWXNf8829HS1ev8fub0WKlEeEvatHixMD0pxvF&#43;WFZvQojPtXT1MiMHAIxmW4uqr73bpOuzfN1msNiGHKulJ8XcuVBWeuuMlHgRS5H6QOgVgGqF6vOL6trLGsc7c9PjcuTxd9ySNDc9jsXACCHhrU1r&#43;qqxW3FV/1Vjt6MYZE6PvS8/tTRvhlAQelOqoVQAFErdu580Orr8OXJp6aLphfOSHQN2hBASGLWXNUxPlKkEUonw0eWZ9xeksR3X5IRGAWjp6t1X2Xy2sRuAVCJ86I6ZxTmykD7yIoSEAaPZVntZc/BUKzMBmZ4Us7F0duG8ZLbjmqhgLwBqvXlfZVO1QgVAKOCvXZbxcOFM6vITQoLKx3XtfzvRouuzAMiRSzeWZoXEiHTwFgCj2fb&#43;iZZ/1rUzR1j3F6Q9ujwzPGbeCSHhx2IbOniy9WjtNWYOuXBe8ndWzQ3ylBWkBaBNa/ptxTnmqKpwXvLG0tnOp/QQQkhw0vVZDp5qPVpzDYBYJHi2PDeYT0EMxgKgUOp2V5w3mm3pSTE/WD0/JI6kCCHEQa03/7IJYVSB&#43;A7q&#43;YG7eRw0BWAj&#43;va3zx2BUCOXPpseS4N9xNCQtSbx658XNcO4P6CtG/fOycIzxMNrgLg/Ht9Z9VctsMhhJCb8nFd&#43;58&#43;abDYhoKzRxssBcBotu2uOB/8R0yEEDIpjjHtlHjR9g15QTWdGRQFwGi2/exPdW1aU/DPmRBCyGSp9ebdFedbunrFIsELm27LnB7LdkTD2B&#43;TstiGdlecb9OaUuJFv/t2AWV/EpZ4PJ6fVva&#43;ofM7Hpud8r7IxKXEi17YdFt&#43;diIz1MFcLhAM2C8Af/qkQaHUiUWCFzblB9XBESE&#43;ZLfbHamWN5rLmjze8HH5WKt52dalHY/LXtb3uEf39ycYAHEmFgl&#43;Xp47Nz1OrTf/tuK8833lWMRyAThac&#43;3junahgP9seS7d2oGEN8dwq30053Uc2d/7au7veNmdy7L3TbzszqOJNEsYQgH/R2sXSiXCK22GPxy5xHY4ALsF4Gxj97ufNAD49r1zaOQnRDS&#43;uszR&#43;Vv2auMUNr&#43;x1UdbeLwtH/koGO9NjdqvVx9tGacpP3Lu&#43;09qK&#43;f&#43;uOP/zu&#43;4d&#43;ed3/fY2Xffy7jvkHGlxIt&#43;Xp4rFPCrFaoDn7eyHQ57BaBNa/r3gxcAPFw0k875CSlL9zTY7Xa7/VjOtjk3lSkfeMtuf&#43;sB3wRjb9ijWDWVkjRa46svKJ58cunew76tAO5p1&#43;NAiiP7M&#43;NFExxvcemPO/7vciTBNOtxHZc14ekIw3kIC6OPVMikzE2P&#43;8Hq&#43;QD2VTY539aeFewUAKPZtmt/vdFsy89OfPzeOazEQG7WA2ueHF76aMuNPrNj&#43;aMtvC2vjnTRt3wEoPHVZXO2nTq1bc7wwcNIt/yjLctefXWLY8WPtow&#43;vrjRz/dWbrKfOnnsyVPbXvwIGGlhpBmX/bp86txI44cVKP/JT8pHVYDGV5ct27JlmWNtT/F4aRPwlI6d86xzJnUuBu5rOq82bgecN/p4wiWDj7UJz&#43;2gwflbOD71nv137tzpfUccV5wjW3dnBoDfH7nE7nMM2SkA759oUevN6UkxP1q7kJUAiA98dHjv0gVeq/febRefs9vt9mNP7l215SNkP3WyYc/SpXsa7PaTT2U7r3hqW8WChuEVeS8saLDbG/aASeaNr36zonz4kAOrvB5xPLDmSSi&#43;bmQOLYYdy9n2zQ8fHLVfl0&#43;d0nXjhxUofzA7&#43;6nnnhx9DHBqL56zM1t7jmfsNsfgMYdOvFs9Vtnw2NS4qd&#43;l6ri377xfyv4&#43;wdw12mi2MQMhbGGhALRpTf&#43;sawfwo7ULg&#43;26ODIBp7bN4fF4PN4LCxpc8rirJ48xIzw3jhXGXPO5p7IBzFmwdHgx&#43;8HypYqvG9H4YcWpkR2u2svkd29ybsmGcyd91V73dcb6dDj/MwHvfcEpiy/d85MHHOt4jMf7Hl0451Dn1DzlQRX3FG93Gk0aq2VHN985GC9HAHAanhorEkf2pzIwru&#43;smisWCVq6elkcCGKhAOyrbLLYhgrnJQfP1RBkMphh94Y9mEhP1xeePOboXnutOCOHJI2vfnNbzvA2DXuWuqw15qcfvbjNObefqvhwjG/nHo/3PY7G8zRJO/6PMEnjpnKM0c13H5VybtNRTsZqc8eOHS4LZCxSiXD98kwA759QshVDoAsAU&#43;6EAj4N/Ye47Kf&#43;MjJKAwDDQyaNr74wfgd4Urt5sHyCU7IfbVm1d2n5g9lAw8VTI2NTH7247ZTLemN9&#43;tHhvY4ZZbvdfuxJjxXAczze9zia3c0Evpwr97Rud5uzhVuK9zKAM&#43;7AjssKE6kBZFz3FaRJJcKWrl7m9tGBF&#43;gC8O4njQDuK0ijs/5DXvZTzw0PlDzw1rEn967i8Xi8b6Lc62hP9oPlcEwCT3Avf9mjWDXm/OpIl53HW4Vjwx3yB946ljPSk8eTT7rs18OnAJP/mfEfxgNrxqgAnuIZo01nXgZPplADJlI57COnEjmP8ExkPmCsGeBx33GgGjBBQgH/0eWZAA6eamXl0rCAnstVe1mzu&#43;K8UMB/64dLg/xBOYT40FiD/g4uM7ruKzPv6M16APGiePdlqVQKMwDo&#43;nUApNFS52W73c6L5ul0OmZ9xzKPx4MIAOz9duf3XdcZWyATSLh6eu&#43;XLV29j9875&#43;GimQHedUCPAJihLnqyI&#43;Eal8ET76NAHldmXir1yrK/lenNer1ZX/a3MuflFW&#43;u0PXrdP065n2XZb1Zv&#43;LNFY71Hcu6ft2KN1eseHOFy/vMslKvHCvgmxm/Ii7WL5cD2FfZFPh7BAXuJJxqhaqlq1cqEQa&#43;yhESHvKm571y3ytlfysD8Mp9rwDw63Le9LyAf0UuKpyXPDc97kqb4eCp1gBPjgZuCOi5975SKHWsHOYQEk7qu&#43;oBMNnZ38skMBRK3XPvfSWVCN/64dJAPjgsQAVA12f53y9/TqP/hBDi0ZO/P6XWm7dvuDU/OzFgOw1Qqams7wSQI5dS9ieEEHfFOTIAx891BXKnASoAX3ytBXDXoumB2R0hhISWuxbNAFB7WRPI80EDUQCMZtuVNoNQwC&#43;clxyA3RFCSMhJT4pJT4qx2Ia&#43;auwO2E4DUQCYO13kyKWBnNwghJDQclt2IgDFVX3A9hiIjMx8n9uyEgKwL0IICVFMklQow6wAKHUYKW6EEEI8YoZJWrp6jWZbYPbo9wJgNNvUerNUIqQHvhNCiBdCAf&#43;W9DgAV9oMgdmj3wtAm9YIICU&#43;2t87IoSQUMd0lNV6c2B25/cC0NLVByBzusTfOyKEkFCXlhADoL0nQM&#43;J9HsB0Fw3A0ieRjd/JoSQcTD3yQ&#43;fIwDmkcc0AUAIIeNKSxIjnAoAM51Nz/4lhJBxMRdLGc3WwOzO7wXAahsCEEmXgBFCyHjiJUKMpM0A8Hte1vUNAJBKovy9I0IICXXMEUDAngxDHXNCCOEovxcAZjaDHgFPCCHBho4ACCGEo6gAEEIIR1EBIIQQjqICQAghHEUFgBBCOIqLF&#43;jWnGtRNHX0GEytnT1sxzJpsTFR2bOSM2YklCyeI4wM7T&#43;&#43;lprTnQqFqaenp7WV7VgmLSpWkpw9JyFDnl1SIhAK2Q7nhsstX7R2XOw19qh7rrIdS5iIjpKkpmSnJMzKnXOnQBBEf9Y3L7QzyKS0dva8e&#43;hUzbnmXtMA27HclKozDcxCyeI55fcuzp8/k914JqunVXn63XdaamoGenvZjuWmNFZVMQvZJSX55etn5uezGIy6&#43;&#43;o/T/35cvMX/QN9LIYRrs43fM4s5M65s3jxI9mz8tiNx1c4UQC6DcY3Kk58WK1gXkZEikTiuMhoCY8viIiMjBCExlXK9qFB60A/AEv/dYup12ruqzrTUHWmoWhR5rZvlGbMCIEnbhq7uz9/43XFh/9gXooEgrgoYaxQGMHjR0XwhRER7IY3QYP2IZN1EECvZcBgsRgt1saqqsaqqsyiJSu2bUvIkAc4nl5jz4cn9n5x/mPmpVAkiJ0WFS2JiojgC6MiIoWh8asGp8HBIbPJBsDUN9B3faDfaDnf8Pn5hs/nZd6xpvT7KYmz2A7wZvHsdrtfd7BmVyWAw9tL/boXLxpa1T979XCn1gAgelqiOGFGqGR874YGrSa92qRX2&#43;1DwkjB8997aPniOWwH5Y264esjP/upobMTQFJ0dKpEHCoZ3zvr4JCq36Q2mobsdoFQ&#43;ODzL2QvLwnY3tvVjf9x6LkeQxeA&#43;MSY5BmxlPH9x2Yd6tH0dauN9iG7QCDc&#43;PD23Dl3&#43;nwvgcyZEb/&#43;9a/9uoP3q1oArC/J9OtexnLiTMPTLx0w9PVHRsVIU7Oj45L5/DA56OHxI4Qx06LjkoasAwNm02e1l4WRgltvSWc7Ls8aT1QdfHpbv8EQEymYkyBNjomO4IfJCQgRfN40oTApOnpgaNA0YLny2acCoTDt1kAMEZxv&#43;HzvBz819htE0ZGz5iRKk8QREWHyqwYnfgRPHBslTRRbLbZ&#43;00D95UpBhDArPde3ewlkzgznvy6Kxo5fvf4Pi9Umik1ISJ8riArDZxLwIyLjZswWJ8wA8EbFiU9rLrEdkQedCsWHv3rOZrEkRIvmJSTGCMKkBjuLjOBnx8enSsQAqt94/fKnn/p7j60dF/cd3WWzWaYlRGfOTRJFR/p7j4QhiOSnZyUkz4gF8OGJvV9dqmQ7oqkL2wLQbTBuH8n&#43;cbJM8ML2mwKQJKRKEtMAvPD2x4rGDrbDGcXY3f3h9uHsnxUXx&#43;exHZA/pUok6RIJgH&#43;&#43;sKtTofDfjnqNPY7sny6X8sL7Zw1KyTNiU1KnAfi/H/22teMi2&#43;FMUdimxRf/Gmn1hApksSlZLAdSyCIpdNFsQkWq&#43;3Fv/i97zkpn734O0Nnp1gYKZ8Wx3YsgTBdIk6IFtksls9e/J3/9vLBJy/3GLqixcK0WfH&#43;2wvxLmm6ZFpCtM1m&#43;eCTl9mOZYrCswA0tKqrzjTwePxpyTPDu&#43;/vLC4lgx8R&#43;XWrOngGgtQNXzdWVfF5vIxp07jTSZVPi4uM4Ku/tpPA0Ht6sbzDZ/z&#43;LwZs&#43;Ko78&#43;utFnxgkh&#43;u7oxRAeCwjM5vnv4FICYuOSwHPcfE48vlsoAvFFRzXYow06/&#43;w6A5JjosBz3Hwufh&#43;liMYDP33jNH&#43;1/cvLPABKSYmjcn3U8Pi9RNjwZwHYsUxGGBcBitZ0&#43;1wIgRipjO5ZAi4lL5kdEdmoNDa1qtmOBzWJRnj4NYHqMmO1YAi05OiYygm/o7FQ3fO3blm02y6WWLwAweYewLiEpRhDJ7zF0tasb2Y5l0sKwANSca7FYbZFRMfwI7vWPePwo8TQAVWcb2A4FyprTNoslJlIQyb1zE/k8xAmj4HS1sK9cavnCZrOIoiMFkZz7VYMTj8&#43;TTBMBUIxcLRxCwvDvUM15JQChmBNTju5EkgQAF5o62Q4EypoaAPFR4XDZ3RRIRVEAui5c8G2zV1q&#43;ABBLj9gLJtOk0QBC8VygMCwAPQYjAKFIwnYg7IgQRgHo1BjYDgTGnm4A4kjuHYcBAKIFAgDMlc8&#43;1GvsARAtDqtbkoW6KJEAQM/1LrYDmbQwLADMXR/4ERyadXTG3OiiU3ud7UBwvbMTQGRY3O9hCpgbXVzv9PFlGcxdH2j8J6gwt99g/mhCSxj&#43;Neo1DgCIiOToyAOACEGUxWpjOwowN/uM4t4EgENURITNYvFtm8zNPumGP8EmUhhhs/n4zzoAwvYfJ49P/0KCQgRnrsMIJLrnD/EJ&#43;mtECCEcRQWAEEI4igrARHm/PbfLpyw&#43;/4AQQiaIo6fKTMGaXZWHt5cyz2qY7KcO3gvDuJsTQogPUQHwxj1fu7zjnLInmL4pyxNCggQVAG8cyXoivXuMLg&#43;OZfcN3VubYPuEEOJDVAB8wJG&#43;J1gwXMaLKPsTQlhBBWCi3IeDHFl7ghMALtsym1D2J4SwhQrARLkP2rh86uVEII8pnrI/IYRdVAB8ZgoTBlQDCCEsousAxjeFGeCx3nFv0/3QgRBCAoMKgG84ErpztRgrubtUFKoBhBBWUAEYxwQv73Jkf&#43;b/jv/gdfbYyzvE30oOHXF/6fJmGNu8cv/EP53UylNuyuOa3hsnN4nmALzxeMI&#43;s&#43;DxEjCPeXzid4mgMsC6qrLVJYeOVJWtZjuQUPLOZxs2r9z/zmcbpvDpTTZObhIVAG980lWfwtXChBXh3f1370q7vOMxyTonX2Z95uWkWpty&#43;qbuv79RASAhQr7p9ldmKst&#43;o7nplhyJnunsO16Gd8ffJQtPtlvNrO/IyM5VYSLtOKdyj41438toy1au3Co3Hjlw&#43;n3d8MvC5s9ebvawZkbBkh/g/I/r&#43;gAga9H&#43;Urz2zrmT40bLHVQACOcwid4x1ON4yXJYAeQYXnfPsC65GKM7/lPYEbOh94Lh2JHzyl67/x16rF4se/8z1SSCaT63wVOR4DQqACTk3LXg0NPJw8vtrU9/17j&#43;iLztqS/2gIg5rE3bk&#43;vqPotXNZRKkc14THdc&#43;RQwNHL9ji87pyLHal/spPAjjYnPoLvcRdeDgWU6rq83GeyVM4d/2UrV26VDy931Nf8Abm788RA0f4845EDp9/H7Jfuxh/OinfnG5/9oKkVgHT2S&#43;vEh945d1I6&#43;6V1makAoObWIQIVABJyjl8sOz68WPLLkh9v&#43;vL/1cb8z&#43;KYv7aYkJlShNaXjgNwWUf9/fdMbg1xaghoCsZN/Y7VnF&#43;6TwZ4ORHI48DUeENAAADVy5Xi/fmzM5qbHG&#43;d/Oyzkdwte2Zz7pIDp5&#43;F0xCQFADQrKorzVoibWrVIWN2CurPn4Rk/d0pdQc&#43;e18HZC3av1J2clIHFiGNCgAJPTGPvXH7urThF&#43;3XUHVKs608Rf6eEsXJOH1B6WkdJ4687z4EFPanALn0xyd1js2Up2THnTBwORxxHgLyEl5z85H8onVZTbWOd2505AEYxxjTU9Uqc8tmS96vwxI56v6rD9LZBfHi1HUrh/c9cYMqFqn8j1DEBUAEmrkmxaua7tY9l0NAPmm238M4Lim9mn5nZlqLEHNv5k8r3PDWCmea9mfMfEa4HHCYILDO96noMdqZJz2&#43;94/q96fP7tDz7yUrL87s6Pysx83A5CsfyR3rM1ONqu35ssymlAA9R90zJEBx0Z&#43;HOhCMBJqMmbGtF8zAgCS1z8SAwDQvP8BijbIi6D5vGWsdcYV3rPBjl428x/zDvOfx6EejwM1UzgIcJ5MdpkbGHfbcWeDm5uPIHO1nHkhTo03dugAAFlZq&#43;PHbra5&#43;QhS1i1OgVLVCkCnqtOnFGZN7OuEGToCIMFveNbXdOApDYCq31xccuT2Q48AQG3t8FmhymoNXs3AB18qgbHWGZvLoFBY8n42jseT/b2bSPff5VQi98kA733/8XfR9/5Z9erSFACA6uVK2f7hkRx1nRIAWpvUWOeYBL6x1WkldufhyIG&#43;4Ub&#43;q&#43;WldSv3lwJAR33N8JwBF1AB8As7ZL/Ynnxql6LK/1txgNOsLwBA89vVbj9Ri/L7q5XjrAOB1QrAFhkJAHq9wGpd9o&#43;PAJx86AHByGXAzPvD63CP&#43;0lBY52fM9bcr8e6MtbQv7DPAsAiEQKAXi/ss2xa8wGA9w4/InTsXa8X9lmYdYR9FuD4jcne0Sd3ejjRs&#43;nH7zTdWP5geKm17vSGOqe1dM6rcQkVAA/sEG/6XuG6JOOBt2r3qRxvyn6xfWEh1K&#43;MkaDtEG/6Xg4O3NiEBBuRqX/2ecWFwtsB6OdkLwROPvQAgIW1XwK4UHj7yYceWFj75ULgQuHt4V0DJn5ev8c1xzqXf7IxJKqMRW&#43;c/fTXxQA6V8y9B3gPjwC459fVAD79dfF7hx&#43;559fV9wDMOvf8urrmu/ndTMEgN40KwFiMtZdRtEC8T2UcfiMnuVBrbE9iNShyc/ripjXl5jDpvik3ByOp3&#43;Ny2NeAYNA9W1rz3Xwm3dd8Nx8jqd/LcvdsKYsBhxkqAGNqu6hJX5tZclxRxfTul4sPnNAUrR2eUJTfVbinWAwAly&#43;sqVCNHDQAW0rXaZXbXjcCmHVX4eFiMYDag5W7FQBgz8n5&#43;1pmwNLTm5fVta5REB9jagCzgJF073FZZOrvi6MC4HdMDWAWMJLuvS8TX6ECMDaNqkZbuDQHVQpAJiuC5kUNigAAdlnWT&#43;Zrtu2qVQIl5aXP5qh2K4zvvV6LkSEgO2RAyrrkC2t2qew5OX9fm1OiUPxLlvX6WvGBtyr3qWCXZb2&#43;pXCjpvY9lewXI2/K7yrcM894it1vzQFMip/4MvE357Q&#43;kWXiK3QaqBfG906oCxfIAKwokbedaG4Z&#43;SBzQXJaknzP9tLD20ufnof0ZLGnzdWvVKgAQKEZ7tcnx6RdVjIzBDxVc8VlcdECMXKSC7WaahUAtBxX0hEAISRg6AjAK4Wmdq18owzp89SnKgCZ00eXL6ypuNnZ3jaNcfyVCCHEP&#43;gIwBseVKcui9dtWZhe3eJ85k/LRU37vOSSyTanMbXPk2&#43;UAYBdllU&#43;z9imATSm9qTkYhkAZN4lL/RR5IQQMi46AhjHv6qU5fOSay6O6qrzVM0vVhfu2V76NAAMny3Kg7H6EvY4TQK74Kmav3cw5u9bStcBAGoPVu5TgYfmF6uT92wpXQe0V184oE1235AQQvyBCoAHPBj3vT48Gs9TNW/d1ey0PLyO8njtmuOuGzq/uXuXaqQ11Y1lhWKNwttWOE4XEQSPuxYcWqrxxSNoOMbLE1p8vlXg2wwrNAREgox80&#43;2HfumT46Dknx8pOXSk5NCR2x/LBABkyv/4hlzui6ZH/CtvsS&#43;bCwoZBUv2b175UoHE&#43;c1lK1fu37zymbFvmJNRsMRlEx/IWjR8t6JHZmf4aS/tJ&#43;f6srlQQwWAhKmSXy5I/&#43;DLstVVZauV6RtoZG0yOpRqyGUZN96QFcqNIzfdDBjZM6XiIwc&#43;2/DOZxvOitdx82Zt/kZDQCRo&#43;eDJXwzNb38DZMr/&#43;GpGGvDKkYz2D778/jW5&#43;4YlvyzZVuipqbsWHHoae1ZfrAKAf&#43;UtXlF/xvdfN5joVXXxueuympjBk4yCrNT65jp57vCt9t2en5VRsMT52VvXACTMfqk0MxWA8vyG4eeryJ7ZnFvAtODhzeHbt3nWfO5l970sHvX8rx/X9TnvwuWebstWrtyKkZ22n5ybtuzKTf9I4YAKAAlaN/fkr5EbgpoOMDWjRfn9p/DHn&#43;Kl4czutuE1&#43;bb01qdXu5UQ1&#43;zvx28cPIynlcbdWTI0qwDJEjnq/ssIOfORh&#43;dntdaNevbWMqAgT/zaO5&#43;dhOyZzcyDGyXrH8lNra/ZUNcHSNY/UvRSgfHHdX3LVo68KZ390jp0jBqsH7m7p76FeYKjy14w&#43;vlf65tOX1vs2MUortnfnz9ciKECQILXTT75S/Pb1VXIlP/x1ZJ1Hg4OXDcsWZrcfvrL0esAhQsOFWrcsr9jIXwPBVrrmus2y5ZBdTIra7W&#43;eYMO65kPpLKJPD&#43;rrpJ5voqqVplbCADi1Hj1obqR2y&#43;fVa/Ol2XUiQvlxjrmnsy6pkPKTNezoJvPbWhGRsGS3ZszPdyl2fX5X7IbrTkpKF1ZoHTL/o4Fjh8KUAEgweqmn/wFgLlNtPHnR&#43;R3Zo4qAONvyKi9uAcLtv0yueo3GmBF/Rkm9Ydv3neiqlXmlhVIEJ9S13wOcJ569cXzs/R9E3zsYmvd6Q09i/bnyzJGFYCJPv&#43;rrvI8SkceH5&#43;27AqT&#43;jme9x1oEpgEq5t78lfMY28sGL5UL1OcDuO1Fjhz37D1miltSYrcLYyq33x5IH3BHzcxjXMi9Q872axOzSvaGt9ywHlkZorPzzJ26FPKhk/gkazPT&#43;nQGwFjh15cMFsCANLZZfLRW0hnv7Ry&#43;Nr7jASxW8Fwf/6XU2ujqF4&#43;0JJaumQ9cy8hSv3O6AiABA9fPvnL9NcKHDpSsg0AUPtKVRWAFnUNbh&#43;eBHbbUPnehQNLbn/lSAbgMgls&#43;ut3L6YfWfhYNTP/zJ0a0Nx8JD&#43;lQOkywuP5&#43;VnOz9665qGtvvc/OJ&#43;6uWh/HgBAeZ4ZqX/v1oK1hXtzwP0La/VG0cNAemaDmHl/s1M11792jsql724Pf&#43;r70ZrLpPAuqYfV4r33z379AdNraAa4IRnt9v9uoM1uyoBHN5e6te9OFv7zN5OrUGWzY3JOk&#43;0SsWgbeD0ez9hN4x31q4xdHYWTJeNv2qYOq/RDgwO/ui0L2/x98Jb63sMXQvyU8dflQRQg0JltQy&#43;/NN/3XxTgcyZNAQ0FXbInt1eerjc96ntNnu1z9skhBCPqABMReZd8vTL6qncD44QQoIGzQFMmh3i4vmoOdCCpJHHxYw8EDhdi8J54vbq2q3HjS6PDMONpwozbjxw&#43;DZ79Ve8Yna&#43;DCGEw6gATB7zdDCVseWE&#43;u8LZFA4bt8mLsSFNbtU8ATQznMAAB8ISURBVPzIsFF3hbPn5Px9XVb1681SGvMhhLCECsCkZS5IxiWFEo7Hxaj2DWd144EqlWOdtCTxnu1y5mW7RgwY4fwkYQBapSP7O4b&#43;6VCAEBIwVAAmxw7Z/yoWp6Hw8EiiTl8g3qfy9GAvt0eG2WVZPyk2vrKrtgqwy7JeXwcdr5ipAZT3CSGBRwVgknKSC7XKba83KwEwIznLZfLjzaOvMkLLRU37luQSqJyfI4bkmDStiTmnekWJPA1KAF/xiunMH0IIK6gATM6KBSntl2qVjtcKTe1aebGsuWX0c1w8PzJMoXhlQenwuNBltePkcOr&#43;E0JYQQVgcqoqKp079Y55XeeHiDE8PjLMZXNCCGERXQdACCEcRQWAEEI4igoAIYRwFBUAQgjhqPAtAPYhtiNgjT2YvvuQf&#43;82G9SG4K8vb&#43;fyzxqU/H1bZT8JwwIQK44CMDhoZTsQ1gwFx3ePio0FYBsaZDsQ1lgHfV&#43;Jo6MkAGy2IKrxBIDNGpJ/ImFYABLixAAGrUGRBAOPyf4zkuLYDgTihEQAA35IgiGByf5xM2b4ttlYcQIAywB3y2oQYrJ/Qtx0tgOZtDAsAIlMAbD0sx0IOwatAwAS48Xjrulv4sREAGabje1A2GEZHAQQk5jo22anSZgCwNFfNThZLTaM1ObQEoYFYOHsGQAsputsB8KOAdN1AHNmpbAdCKYvXAjAYBlgOxB2MF88Zc4tvm121owFAIzXzb5tltyMvusDANJSstkOZNLCsAAULcoEYDZd5&#43;Y8sMVoALA8n/2/i5lFSwBcHxjg5oSlfmAAwOzly33b7LzMOwD0Xh&#43;geeDg0as3A8iZcyfbgUxaCBeAnTt3enx/RlLcLRkpsA&#43;ZDBqPK4Qxq7nPOmASRgry589kOxZMmzEj5ZZbhuzQ9JvYjiXQjBaryWoTCIUz8338bOqEuOlpKdn2IXuPlnO/anDqN1rM/VaBQJg9M4/tWCYthAuAF4&#43;vWQrAqFNx7SCgV3MNwNrSPGFkUNzlacnjmwF0GY1c66229l4HcOvatQKh0OeN37vsWwC6Vb10EBAMOq8aACzLWy0Q&#43;P7P2t9CrACM1et3sXzxnFsyUoYGrX3dHf4OKXj0GzTWAVNinPixh&#43;5gO5Zh2ctLUm65xTo41N7Xy3YsgaMx9ZusNnFi4u2PbfJH&#43;7lz7kxLybZZh9QdHJ3oCh46rcncb40VJ5QWbmA7lqkIpQIwwezPeGpDKQCjXtXPjYEgq7mvV9sG4PGypcx5UEFixVNPA1AZTRoTJ87LMlqs13p7ASx5fLPY16cAOfyP0u8D6FYbdTQQxJ5&#43;o6WrzQDgvmXfCsVTgBBCBcCR/XeO2LFjh5f18&#43;fP3PaNuwD0atvMvT2BCJE9VnOfvqPRbh8qK80rKw2ugciZ&#43;fkrtj0N4Fpvb09/mJ&#43;7YrRYv9brh&#43;z2W8vW3lq21n87yp6Vx9SArjbD9R5OVNZg02&#43;0XG3ssQ/Zl&#43;atXpq3mu1wpigoRoonYseOHUwN8J73nT16X0Frp&#43;5QZb1B1WKz9EsS0/wZIGv6r3f3aq7a7UNFizKZmhdsFj&#43;6Xtfa&#43;t&#43;HDjYbDKZBW7pEwnZEftHd3996vXfIbs8sWsLUPL8qKXhE03P1VP2RNqUuyWxNSZ3m7z0SB323qfOawT5kn5d5x5rS77MdztSFzBEAJpP6HX76rXu&#43;W74cgFHXpW29MGDU&#43;yEu1ljNfbr2r6&#43;rlXb70IPFOb97ak2QzP26W/nTnxV/93sAuvqMCm03c4pk2DBarFd6dC2G60N2e86DD63&#43;3b/5Y&#43;7X3SP3PvPg8icBaLv6Gi&#43;qr&#43;vD/AArGPQbLa0N2o5WvX3Ifkfu/d8ueyEU534dgjRfjGUKNWDTQ4XyGQn/9udPuw1GfWdTRKRIJImPnpYYESnyR4QBMGgbGOjTm/v0VnMfgNiYqMfLlj56XwHbcY3jjk3fTJDLP/u33xm7uxt1epFAEC&#43;KShKJRIIQ&#43;0voYBkc1A0M9JjNRosVQFRs7JLHNy9&#43;dH0gY7i7aENK4qwPPnm519jT1twjFAmmxYviE2KEolD9VYOT1TJ4XW&#43;&#43;ruvvN1oAREdJ7l32rZKCR9iO62bx/H0TuzW7KgEc3l7q172My2K1vf/PM3/9R22vaVTfMyJSFCGIZCuqybINmIac7q0mjBSsLc177KE7gmrW1zubxXL2/f/7xV/3DfSOOi9IJBBE8kPmeNRksw0O3TjDWCAU3rp27e2PbfLfrK93Npulqu6Dytr9/QN9zu8LRYLIyJD5VYOT2WQbdLqflUAgXJa3urRwg/9mfQOZM7lSABxqzrWcONvY2tmjaOywWEPyhio52akZMxIKc&#43;VLFmVJYqLYDmeKWmpON5040dPa2qk4b7NY2A5nKmbk5CRmyDMKizKXFEVJYtkOBwAut3yhaPhc3XNV2XHRZgvJXzU4ZaQukCXOmiu/Y17WHcwNWf0nkDmTc8eJRYsymXtFEHZlFi1h7hVBfGhe5h3MvSIImQg6PCSEEI6iAkAIIRxFBYAQQjiKCgAhhHAUFQBCCOEoKgCEEMJRVAAIIYSjqAAQQghHUQEghBCOogJACCEcRQWAEEI4igoAIYRwVPjfDK7mXIuiqaPHYGrtDL0HQ8bGRGXPSs6YkVCyeE7QPuyFEBKiwjantHb2vHvoVM25ZpcHAIScqjMNzELJ4jnl9y7Onz&#43;T3XgIIWEjDAtAt8H4RsWJD6sVzMuISJFIHBcZLeHxBRGRkRGC0LiBvn1o0DrQD8DSf91i6rWa&#43;6rONFSdaShalLntG6UZM/z1MApCCHeEWwFoaFX/7NXDnVoDgOhpieKEGaGS8V3w&#43;BHCaAkAYbQECRgatJr0apNeXXOuZdOlvzz/vYeWL57DdoyEkNAWVpPAJ840bN71n51aQ2RUTOLM&#43;dNS5CGa/d3xIyIliWlJ8hyRON5itf3s1cPv/aOW7aAIIaEtfAqAorHjV6/w2K1iWITEtLnCqJi2I7I9/gRkXEzZosTZgB4o&#43;LEpzWX2I6IEBLCwmQIqNtg3D6S/eNkYf7ER0lCKo/H7&#43;tuf&#43;Htj2ckxeVkp7Id0RSdq7vSePnqdV1fxzUN27EQAgAxEtGsrBmp6SmLly6MFIZJevQiTL7hi3/&#43;tFNriBRJ4lIy2I4lEMTS6TZLv7m358W/fPqX57/JdjiT03FNfeg/PztX97Wpr5/tWAhxdebUBWZh8dKF9625c/6iLHbj8atwKAANreqqMw08Hn9a8kzwwmdQy7u4lAyLqffrVvWnNZfuKZrPdjgTYtD1Vvzp4xOf1jEvhZFRMSJJdJSYz4&#43;IjBAKBJHshke4bGhocMBqBtA/YDT195ktpjOnLpw5dWFRwdxvbHkodWYK2wH6RTgUgHcPnwIQE5ccluP&#43;Y&#43;LxxVJZr7btjYrqkCgArU0dr&#43;56T6PSAZgmliZMS6GMT4IHnx8RHSUGEB0lTpiWMjhk0/d263u15&#43;quXDrXtPXnGxYvXch2jL4X8v1li9V2&#43;lwLgBipjO1YAi0mLpkfEdmpNTS0qtmOZRxnTl3Y&#43;fRrGpUuSiiaKctOSUij7E&#43;CWQRfkBgnk6fOFUdPs1pse3a9d/Rvx9kOyvdCvgDUnGuxWG2RUTH8CO4lFB4/SjwNQNXZBrZD8abx8tXXfrvfarFJxHHpKbOjhCK2IyJkQiL4ghlJsxLiUgBU/MfHNf/6b7Yj8rHQLwDnlQCE4ji2A2GHSJIA4EJTJ9uBjMmg631993D2n54wk8fjsR0RIZOTMC0lMU4GYO/LFY2Xr7Idji&#43;FfAHoMRgBCEUStgNhR4QwCkCnxsB2IGP6jz8c0qh0ImGMTJrOdiyETJF0WrJEHGe12P78h0Nsx&#43;JLIV8AmLs&#43;8CPCYTZ7CphLnTu119kOxLPWpo4zpy7weLxkaSr1/UlIk0nTI/iC1qaOcBoICvkC0GscABARGSa3fJiCCEGUxWpjOwrPDv3nZwDiJAk07k9CHY/Hk05LBlDxHx&#43;xHYvPhHwBYPD4EWyHQFxZLbZzdVcAMP9sCAl1cZKECL5Ao9K1NnWwHYtvhEkBIEHoXN0Vq8UWJRRF8Dk6QEfCDI/HE0fHAjhz&#43;gLbsfgGFQDiL&#43;fPfA1AHD2N7UAI8RlJzDQATZevsR2Ib1ABIP6i1/UCEAmj2Q6EEJ8RCkQAtCod24H4BhUA4i/MP5IIPvcu0CPhi7mCXaMKvQeMe0QFgPgLc7PPSLrlAwkvkYJIqyVIz7ubLCoAxL/4dIIWIcGKCgAhhHAUFQBCCOEoKgCEEMJRVAAIIYSjqAAQQghHUQEghBCOogJACCEcRQWAEEI4igoAIYRwFBUAQgjhKCoAhBDCUVQACCGEo6gAEEIIR1EBIIQQjqICQAghHEUF4IbD20tdlp3fIYSQMEMFwJs1uyqpBhBCwhUVAA8c3X86DiCEhDEqAICnXL9mV&#43;WaXZXOCw52iDd&#43;r3CjbOSlLOu17Tklvg7pNnu1r5skhJBRqAAAo9M99fcJIRwhYDuA4HJ4eylTAxxlgFlwOQgYi/yuwj3FYgC4fGFNhQqAHbJfbF9YOPy58cBbte&#43;pZL/YntxWLV5XLAbQXl279biR&#43;fg2e/VXvGLffiNCCBkLFYBRHImeWWDqgacVxeu2lK678VINwC7L&#43;sl8zbZdtUqgpLz02RzVbgV4UO3epWJWsufk/H1dVvXrRiClCLVrdhntkP1ie87Gi7X7VDTm42rH2xt3PrFvx9sbnd/c&#43;cQ&#43;7&#43;tP5P2x1nT5yONqzvG4hOclNkKCExWAqTEeeKt2nwoA7LKs17fEAMhckJyWJN6zXc6s0a4RA0Y4HxYA0CoBAOqK40YAPKhOXV64NBm3dQ1nf0cZ4OyhgCOlOvKpc0b2uKbHd5w395Lxnbf1nvpdWnaJ0z0YQoIfFQDPpjYE5Bj5cbDLsn5SbHxlV20VUyrWed7uK14xk/o5m/cdJpVPJ9jpnshqzut4X3/cOkRIqKACMIpjzGe8ISAPWi5q2rckl0BV5fxuckya1tQKAFhRIk&#43;DEgCQUn6XuOq40S7LKp9nrKkCnGoAceE9w3r8dLKjMc6NMMseu/kuLTsOFMY7wogvff7h4unDL7THjr52SD&#43;p8Pwkd&#43;vGtXkAgK7zb/6qXjXO6uOKL31&#43;Od46Utk2hQ0dv4&#43;heufkWsjdunEtqne&#43;pvRRMCPSm9GWNdWNQwYVAGCy3fwx8FTNL1YX7tle&#43;jTgGCPiKRSvLCgdHhe6rK4dXlddg5zD28UAag9W7hv5l0fdfzjlXCarjpvKvY/vu2dwL424pP6JJffhzcdd7dI7&#43;ypqAcjL3364vINZZtNw3nxCCQCFJVvL4lktSyN5v7Bkx44SzRNV5ye85fnX9k18ZeKCCgDgKfV7GQLiwbjv9Rv/fHmq5q27hpeVx2vXHHdtvKqi0vmYwA4ZgKue1iTwlH/dP3XhSNzuWdi5EfduPkZPMDAtOAqPx9ljj7t2bmG876e8VF&#43;8PDUeQOnzy5O6MD8vbviYoLBkx&#43;ZZzEoj1cKpkw6mn65cOGqr&#43;PK3i&#43;cPf8zkUHn58/HartziPABXDz7ROv/t4vnuhx3pecvzrh5ksj&#43;A2qrXmAUPMcjL3864NJyRHcvy8rcztMfiilfFjaw50ovfsbG46/ybv6pH2ervrIoDgHpH9zze9Su7q229tDmDWZR5aMH9B6lH2epHcOK1Q3A&#43;jNB2xSVNIRhu9PqdUQHw4CYPBchNcuRrxxHABGdlJ9LN97im8zteuvPu4z8TS/pO0vOW5xku/V0PxANx8x198PS8rZvjqnfuq2wD0vO27lhd2n6kEnnLp59/84l6FeTlby/SvlWvQvxC562gr3Ak8cKSHVvyLvxKj&#43;m5888e3fmaPnfrxrVvx1Xv3LcTeVt33Jp7yKlbnRaX1GVQu8XmIYYxh1BmFadW73xCicKSHZtLcmurKn91FI5Rl/S8rflX33yiXgXkbt1YXqgcOeJxDt6Twoz5XYYqAOl5j7i3kO7&#43;g2D4iszCW4u7qnf&#43;ytGy0xDQBINJbx4zqvBFBSDQnE8MJV5MJL16mY&#43;dVF52KSET2aljTeeXXszfvHHHZgC49M6&#43;kaxqqP67cvjjtLik&#43;nPD77fVn6jPXX57fOWXHlty2sq5mwygi8nwV08c0gNQdxgApk3lpa7lyemA9wFxjzGMucnVg0xX2qnPfiOq22clTY/7ztu5zEttRzygdw/eSVzxjo3FuDEbMXYLY6htvbS5eMfbGQfdho8mFIwj&#43;zsWuHEoQAWABBfn0/&#43;dT7T3mGc9TsnC01gNvB4ieN&#43;Ly2peRpm8lAHHqM4EaTr0aNNrphczmUt77GiFey5Oz3tkleHgE0fOA0jP27plwq23G7TT41IA7z0RTQdzpDIl9e4Ts14w41fxpc8/EiZcnhAxr0Fbz&#43;IsuIJJSAvf3vjWlw9&#43;MR/Ty6Ytqzh1M&#43;NvO9At4IgwcU9vTr62hPs1I91Ade4g0guu3A/BHHkeuY/l&#43;WbuhCs3aDNW1SaDmB4mEjbDhRmJB87ykTlecTcaSQn93/kJk18d23KS12z1m6VD79Mz9u6Ve45BgCYNb8QAGRli&#43;Z7aMsD1ZdXtXkZuROPZ5i&#43;8q3zWHVr7lgtjPuDQFnxxNHqruGAJxcMx1I/g44ASLgZd/h&#43;rK1c8vhYo/x&#43;uRCsrf61d&#43;J2MMMgN4aJDNj88I5Vw6t4OIaorTpYsHF4cKP&#43;6qVJ7E9f&#43;aujeP7hHW8zO7x68Il6AJ5iUFa8k7Fj88Ydm6E9dv4S4ry0eeEsvjMy7/rBsdXfeXvjWmByZ3a21Z&#43;o37i8LP78IU8ttI/5g4waCquv3lmrl6VOPhju1QCe3W736w4cJ9T7qf21z&#43;zt1Bpk2Yv91H7w0yoVg7aB0&#43;/9hO1AXD3zzd9qVLrsmTlT2NbjfSAYHqd8J9UHH&#43;v0HueWx7owOJC3gsjdunF5x8gJKoUlOwpaJzOoEoaC5Adp7bxitVn3ffw7P7Xv75zpjApAyAvLAkAA5lQcx8DOVffpTc4Jjh8knAoADQEREqza6l97op7tIIIJ/SC&#43;RpPAhBDCUVQACCGEo6gAEEIIR1EBIIQQjqICQAghHEUFgBBCOIoKACGEcBQVAEII4SgqAIQQwlFUAAghhKP8XgDEIgEAXZ/F3zsihBAyKQEqAFbbkL93RAghZFL8XgCkkigARrPV3zsihJBQZzTbMNJvDgC/F4BIAR8j34oQQogX4VYAUuJFACz&#43;HgKyc3eIyc7h705ImGFSpVAQoNNzAjQH0K41&#43;an9WHEUgMFB7g4xDXH4uxMSZtT6fgAp8dGB2Z3fC0BaQgyA9h5/FYCEODGAQStHkyCT/WckeXlSKyEkZKj1ZowMnARAgIaAmG/lD4lMAbD0&#43;6n9IDdoHQCQGC9mOxBCiA8wfWWm3xwAfi8A6UliAG1ao5/aXzh7BgCL6bqf2g9yA6brAObMSmE7EEKID4ThEYBQwFfrzX46CChalAnAbLrOzXlgi9EAYHl&#43;NtuBEEJ8oKWrF0Dm9NjA7C4Qc805cikAhVLnj8ZnJMXdkpEC&#43;5DJoPFH&#43;8HMau6zDpiEkYL8&#43;TPZjmVMdrud7RAI8aWhIX/9lW7TmtR6c0q8KHyOAADclpUAQHFV76f2H1&#43;zFIBRp&#43;LaQUCv5hqAtaV5wsgAnTU8KTGSaACDg3QJCAkrg0P&#43;&#43;iv9VWM3RnrMgRGYI4B4ALWX/dVDX754zi0ZKUOD1r7uDj/tIgj1GzTWAVNinPixh&#43;5gOxbP4qSxAKyDdBsoEj6Y7J8s80uO/qq5B0DOrHh/NO5RIApA5vRYqURoNNv8NAoE4KkNpQCMelU/NwaCrOa&#43;Xm0bgMfLljLnQQWheGksAIt1gO1ACPEZq82Ckc6Nbzky5G3ZiT5vfCwBut6scF4ygM8vqv3Ufv78mdu&#43;cReAXm2bubfHT3sJElZzn76j0W4fKivNKyvNYzucMWXNmwnAZO5jOxBCfIb5&#43;5wxO9XnLdde1lhsQzlyqVQi9HnjYwlQAbhzQQqAaoXKf/eEePS&#43;grLSPLt9yKBq6etu99NeWNd/vVvX3jA0NFi0KJOpeUHr1oK5AEzmXpoHJmHD2H8dQP6SBT5vufJcF0ZSZcAEqADkyKUp8SK/jgIB&#43;Om37vlu&#43;XIARl2XtvXCgNFf086ssJr7dO1fX1cr7fahB4tzfvfUmuCc&#43;3VIkkkzZqfa7XZDX5gfkxGOMFtMAxZzpFAwf9Fs37as1psVSp1QwGcGSwImcE8EK86RATh46qpf97LpocLfPbUmMU48aDXrO5u0rRf6utsHrf66DjkABm0DJr2qp&#43;1KT9sVS39vbEzUtm/c9dwTDwR59meUfWMlAN11DR0EkDCg0XUAuPvBokihj/1Hf3iGoDbshMDOf4DIHBJ5KE7Zh6tuaZQ6mova/xa5ZYvnlO0KPP9f5756z9qe01mo67LqOtiPoqIFEUIIv23a9&#43;yDZiGhgYdL4WRgrWleY89dEfQzvq6W7x0Ycbs1Namjm5DV1L8DLbDIWTqDH09AxZznDT2ofIVvm1Z12f5Z107gPXL5b5teVy8QHbNDnzeuq&#43;yKXN67CtP3h6YPdacazlxtrG1s0fR2GGxhuQJ6TnZqRkzEgpz5UsWZUliotgOZ9IunWv&#43;Pz99C0CyNDVOksB2OIRMhdliale32O32b/2g7O4Hi3zb&#43;O6K80y3&#43;NnyXN&#43;2PK6AFgCLbWjL70/p&#43;izfWTX3/oK0gO2XsOvjQ5/51tHeTyeTJouEdONS0mIMVtMHdrWocHBux8s&#43;tYPynzbeEtX79N7vxQK&#43;C8/eUd6UoDuAecQuDkAAEIBf&#43;3SDAB/O9Hi90fEkKBxf9mddz9YZLfbu3qudRtUbIdDyCT0GnXt6pahwcFFBXO/seVhn7e/r7IZwH0FaYHP/ghwAQDwcNHMzOmxjjEvwhHf&#43;kFZ&#43;f&#43;&#43;H4DuuuZqVwNzLh0hwcxsMbWrlaqedrvdvvyegm3bN/l87rf2suZsY7ejZxx4gS4AGJno2FfZpOujmwRwyMOP3rVt&#43;6Y4aazFOtCpvXq1q6HboKLrhEmwsdms&#43;t7uNlVzm6q5f6AvRhL9jS0PP/Gj/&#43;nz7A/g/RNKAI8uzwzwyT8OAZ0DcPjZn85caTMU58h&#43;tHZh4PdOWGS12D4&#43;VP2P/1dl6hv1DB9hZFQEP2RO0CJhacDa73zeXaRQcPeDRQ&#43;Vr/DHjR8AHK259u4nDVKJ8K0fLg3YQ4BdsFMAWrp6f/anMxbb0MbS2evuZOfYh7DrXN2Vs6cvdlzTNF5utVpC8gQtEpay581KnZmSu/iWRQW3MHe09Yezjd279v83gB&#43;unl&#43;ax9oZ0uwUAADVCtW/H7wAYPuGW/MDePMjQghhl1pvfnrvF0az7eGimY/fO4fFSNg57gBQnCNj&#43;v7/fvBCm9Zfj4wnhJCgYjTbdu2vN5pt&#43;dmJ7GZ/sFgAAGwsnV04L9nxc7AYCSGEBAbT5U2JFwXDDCibBQDAD1fPT0&#43;KUevNuyvO05UBhJDwtq&#43;y6Wxjt1gk2L4hTyxi/3ZeLBcAxw&#43;hUOrePHaF3WAIIcR/Kus7D3zeCuBHaxeyctmXO5YLAICUeNGz5blCAb&#43;yvnN3xXkaCyKEhJ99lU2/P3IJwMbS2cFz2gtrZwG5qL2s&#43;f2RS0azLT0pZvuGvJR4EdsREUKIDxjNtt8fucQ8FD3YTnwPlgIAoE1r2rW/Xq03i0WCZ8tzc&#43;R&#43;eewyIYQEjFpv3rW/vk1rEosEP1w9P8DPexlXEBUAAEazbXfFeeapYXTHUEJISFModcywdkq8aPuGvCAZ93cWXAWA8eaxKx/XtQO4vyDt2/fOYesiaUIImTLmTg8AcuTSZ8tzg&#43;GcH3fBWAAAfFzX/qdPGiy2IalEuLF0NouXShNCyKQolLp3P2ls6eoFwPq1vt4FaQEAoFDqfn/kklpvBpA5PXZjaVbwTJ0TQoi7lq7efZXNZxu7AYRE5zV4CwDjaM21g6damRtH58ilj9&#43;bnTndL3fmI4SQKdP1WfZVNlXWd4J58tWyjIcLZwbnsI&#43;zYC8AACy2oYMnW4/WXmMuESicl7yxdHYQTqcQQjhI12f5xxfXjtZcY&#43;5lcH9BGov395&#43;sECgADF2f5eCp1qM115iXmdNj78tPLZyXHCo/NCEknFhsQ58rVLVfa5kT/BGafdOQKQAMtd68r7Kp9rLGceOg/OzE27ISbstODK3fnRASitq0JoVS91Vzz1eN3c5ZaO3SWaF46VKIFQCG0Wyrvaz5/KKamWxhSCXCW9LjMmWSeLEwPSkmJT6aLicmhNwkhVJnNNtaVH3t3aYrbQbmtBRGelLMfflphfOSQzfVhGQBcND1WZhqrFDqnP9gCCHEH8QiQY5celtWQo5cGgajDqFdAJyp9eY2rfHr9ut6o6VNa2rXGumh84SQmyEU8G9JjxOLBJkySUqcKC0pZm56HNtB&#43;VL4FABCCCGTQndZIIQQjqICQAghHEUFgBBCOIoKACGEcBQVAEII4SgqAIQQwlFUAAghhKOoABBCCEdRASCEEI6iAkAIIRxFBYAQQjiKCgAhhHAUFQBCCOEoKgCEEMJRVAAIIYSjqAAQQghHUQEghBCOogJACCEcRQWAEEI4igoAIYRwFBUAQgjhKCoAhBDCUVQACCGEo/4/ZR1sHMe75bYAAAAASUVORK5CYII="
	
	
	
	loading="lazy"
	
		alt="img"
	
	
></p>
<p>　　Java运行时数据区分为下面几个内存区域：</p>
<p><strong>1.PC寄存器/程序计数器：</strong></p>
<p>　　严格来说是一个数据结构，用于保存当前正在执行的程序的内存地址，由于Java是支持多线程执行的，所以程序执行的轨迹不可能一直都是线性执行。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存,这在某种程度上有点类似于“ThreadLocal”，是线程安全的。</p>
<p><strong>2.Java栈 Java Stack：</strong></p>
<p>　　Java栈总是与线程关联在一起的，每当创建一个线程，JVM就会为该线程创建对应的Java栈，在这个Java栈中又会包含多个栈帧(Stack Frame)，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向该地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧被创建，这个新创建的栈帧被放到Java栈的栈顶，变为当前的活动栈。同样现在只有这个栈的本地变量才能被使用，当这个栈帧中所有指令都完成时，这个栈帧被移除Java栈，刚才的那个栈帧变为活动栈帧，前面栈帧的返回值变为这个栈帧的操作栈的一个操作数。</p>
<p>　　由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。</p>
<p>　　在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。在Hot Spot虚拟机中，可以使用-Xss参数来设置栈的大小。栈的大小直接决定了函数调用的可达深度。</p>
<p>​                          <img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/871886-20170103212909316-559443487.png"
	width="766"
	height="478"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/871886-20170103212909316-559443487_hub291fcfdf252a4fc9178835d0431a7ea_29405_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/871886-20170103212909316-559443487_hub291fcfdf252a4fc9178835d0431a7ea_29405_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="160"
		data-flex-basis="384px"
	
></p>
<p><strong>3.堆 Heap:</strong></p>
<p>　　堆是JVM所管理的内存中最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。</p>
<p><strong>4.方法区Method Area:</strong></p>
<p>　　方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，不像Java堆中其他部分一样会频繁被GC回收，它存储的信息相对比较稳定，在一定条件下会被GC，当方法区要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation，大小可以通过参数来设置,可以通过-XX:PermSize指定初始值，-XX:MaxPermSize指定最大值。</p>
<p><strong>5.常量池Constant Pool:</strong></p>
<p>　　常量池本身是方法区中的一个数据结构。常量池中存储了如字符串、final变量值、类名和方法名常量。常量池在编译期间就被确定，并保存在已编译的.class文件中。一般分为两类：字面量和引用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定为到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。</p>
<p><strong>6.本地方法栈Native Method Stack:</strong></p>
<p>　　本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<p>在jvm的内存结构中，对象保存在堆中，而我们在对对象进行操作时，其实操作的是对象的引用。</p>
<h6 id="java对象包含三个部分">Java对象包含三个部分</h6>
<p>一个Java对象可以分为三部分存储在内存中，分别是：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</p>
<ol>
<li>对象头（包含锁状态标志，线程持有的锁等标志）</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<h6 id="oop-klass-modelhotspot-jvm中的对象模型">oop-klass model（hotspot jvm中的对象模型）</h6>
<p>Java虚拟机的底层是使用c++实现，而jvm并没有根据一个Java的实例对象去创建对应的c++对象，而是设计了一个oop-klass model ;</p>
<ol>
<li>OOP(Ordinary Object Pointer）：普通对象指针; 表示一个<strong>实例信息</strong></li>
<li>Klass：描述对象实例的具体类型, 含了<strong>元数据和方法信息</strong></li>
<li>创建目的：不想让每个对象中都含有一个vtable（虚函数表）</li>
</ol>
<p>类就是一类事物的抽象概括。</p>
<h6 id="oop体系">OOP体系：</h6>
<ol>
<li>OOPs模块中包含了多个子模块，每个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。</li>
<li>在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应的创建一个对应类型的OOP对象。</li>
</ol>
<p>在Java中，JVM中的对象模型包含两部分：Oop和Klass，在类被加载的时候，JVM会给类创建一个instanceKlass，其中包含了类信息、常量、静态变量、即时编译器编译后的代码等，存储在方法区，用来在JVM层表示该Java类。而使用new一个对象后，JVM就会创建一个instanceOopDesc对象，该对象包含对象头和实例数据，对象头中保存的是锁的状态标志等信息，元数据则实际上是一个指针，指向instanceKlass。</p>
<h6 id="java对象模型---对象头mark-word"><strong>Java对象模型&mdash;对象头(Mark Word)</strong></h6>
<p><strong>对象自身的运行时数据</strong></p>
<p>这部分存储包括哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据被官方称为<code>Mark Word</code>，在32位和64位的虚拟机中的大小分别为32bit和64bit。</p>
<p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，<code>Mark Word</code>被设计成一个非固定的数据结构以提高存储空间的利用率。即这部分数据会根据对象的状态来分配存储空间。</p>
<p><strong>对象的类型指针</strong></p>
<p>即指向对象的类元数据的指针。虚拟机可以通过该指针判定对象实例属于哪个类。</p>
<p>在Java对象中比较特殊的是Java数组，一个数组实例的对象头中必须记录数组的长度。JVM可以通过对象头中的数组长度数据来判定数组的大小，这是访问数组类型的元数据无法得到的。</p>
<p><strong>对象的实例数据</strong></p>
<p>前面提到对象头是对象的额外开销，只有实例数据才是一个对象实例存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。这部分内容同时记录了子类从父类继承所得的各类型数据。</p>
<p><strong>填充</strong></p>
<p>对齐填充在对象数据中并不是必然的，只是起着占位符的作用，没有特别含义。HotSpot要求对象起始地址必须是8字节的整数倍。对象头的大小刚好符合要求，因此当实例数据没有对齐时，就需要通过填充来对齐数据。</p>
<p><strong>获取类的元数据</strong></p>
<p>虚拟机在加载类的时候会将类的信息、常量、静态变量和即时编译器编译后的代码等数据存储在方法区(Method Area)。类的元数据，即类的数据描述，也被存在方法区。我们知道对象头中会存有对象的类型指针，通过类型指针可以获取类的元数据。因此，对象的类型指针其实指向的是方法区的某个存有类信息的地址。</p>
<p>但是，并不是每个对象实例都存有对象的类型指针。根据对象访问定位方法的不同，对象的类型指针被存放在不同的区域。</p>
<ul>
<li>通过句柄访问对象
<ul>
<li>对象的类型指针被存放在句柄池中；</li>
</ul>
</li>
<li>通过Reference指针直接访问对象
<ul>
<li>对象的类型指针被存放在对象本身的数据中。</li>
</ul>
</li>
</ul>
<p>比较来说：</p>
<ul>
<li>使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，当对象被移动（垃圾收集时会经常移动对象）时智慧改变句柄中实例数据执政，而reference本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度快，节省了一次指针定位的时间开销（对象的访问在java中也非常频繁）</li>
</ul>
<p>因此，Java的对象数据存储可以理解为：</p>
<ul>
<li>引用类型（指向对象的Reference）
<ul>
<li>存储在栈中</li>
</ul>
</li>
<li>对象的类的元数据 （Class MetaData）
<ul>
<li>存储在方法区中</li>
</ul>
</li>
<li>对象的实例数据
<ul>
<li>存储在堆中</li>
</ul>
</li>
</ul>
<h6 id="对象内存布局"><strong>对象内存布局</strong></h6>
<ul>
<li>存储的是与对象本身定义的数据无关的额外存储成本，其数据结构不固定。</li>
<li>32位JVM中，对象不同装填的mark word各个比特位区间图示如下：</li>
<li><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145739352.png"
	width="554"
	height="178"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145739352_hucd0dc259a15cdb273c85d38115dad536_105051_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145739352_hucd0dc259a15cdb273c85d38115dad536_105051_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="311"
		data-flex-basis="746px"
	
></li>
</ul>
<p>对象五种状态：无锁态、轻量级锁、重量级锁、GC标记和偏向锁。</p>
<p><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145801724.png"
	width="580"
	height="152"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145801724_hua89fb80cae381e48c3f1c43c882c08bf_30541_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145801724_hua89fb80cae381e48c3f1c43c882c08bf_30541_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="381"
		data-flex-basis="915px"
	
></p>
<p>HotSpot中对象头主要包含两部分</p>
<p>第一：</p>
<p>用于存储对象自身的运行时数据，如上表中的对象哈希码，对象分代年龄，偏向线程id，偏向时间戳等。</p>
<p>第二：</p>
<p>类型指针了，我们看表中也有指针字样，那么这部分主要就是杜希昂指向它的类元数据的指针了，虚拟机就是通过这个指针来确定这个对象时那个实例。</p>
<p>偏向锁和重量级锁</p>
<ul>
<li>
<p><strong>偏向锁：</strong></p>
<p>主要解决无竞争下的锁性能问题</p>
<ul>
<li>按照HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作，CAS操作会延迟本地调用</li>
<li>偏向锁会偏向第一个访问锁的程序，如果接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不需要触发同步。</li>
<li>但是如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁</li>
<li>只能在单线程中起作用</li>
</ul>
</li>
<li>
<p>****轻量级锁：****为了在无多线程竞争的环境中使用CAS来替代synchronized。减少传统的重量级锁使用操作系统互斥量产生的性能消耗，是为了减少多线程进入互斥的几率。并非替代互斥。</p>
</li>
</ul>
<p><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145947709.png"
	width="2097"
	height="3350"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145947709_hu8c99443b729113bd82a718c3fa1c187c_1353877_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180723145947709_hu8c99443b729113bd82a718c3fa1c187c_1353877_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="62"
		data-flex-basis="150px"
	
></p>
<h5 id="34什么是happens-before它的规则有哪些">34.什么是happens-before?它的规则有哪些？</h5>
<p><strong>happens-before原则：</strong></p>
<p>　　Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>　　下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。</p>
<p>　　a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。</p>
<p>　　b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</p>
<p>　　c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。</p>
<p>　　d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</p>
<p>　　e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。</p>
<p>　　f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。</p>
<p>　　g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。</p>
<p>　　h.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
<p>　　一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生 “呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与happens-before原则之间基本没有什么关系，所以衡量并发安全问题一切必须以happens-before 原则为准。</p>
<h5 id="35什么是jmm谈谈工作内存和主内存的关系">35.什么是JMM?谈谈工作内存和主内存的关系。</h5>
<p>在Java语言中，采用的是共享内存模型来实现多线程之间的信息交换和数据同步的。</p>
<p>　　线程之间通过共享程序公共的状态，通过读-写内存中公共状态的方式来进行隐式的通信。同步指的是程序在控制多个线程之间执行程序的相对顺序的机制，在共享内存模型中，同步是显式的，程序员必须显式指定某个方法/代码块需要在多线程之间互斥执行。</p>
<p><strong>主内存和工作内存：</strong></p>
<p>　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p>
<p>　　JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</p>
<p>​                                  <img src="/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxgAAAFdCAIAAAAPFVzFAAAABmJLR0QA/wD/AP&#43;gvaeTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAgAElEQVR4nO3dvXaqThuH4Wfe9T8UTZGVI8AjwN1Ypd0dlNrsLqVdGiilS5vKJnIEegQui8C58BYI8uUHI4rgfRV77aggMhP55ZkBVBRFAgAAgPr&#43;1/YGAAAAdBVBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQNN/bW8AAAA9oZRqexNwqSiKGlkPQQoAgMY0dXjGTTUYeRnaAwAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0ESQAgAA0PRf2xsAAPemlGp7E24liqK2NwF4LgQpAM&#43;ol4GjxwEReFgM7QEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGgiSAEAAGj678rllVKNbMfTiqKo7U0AAACarg1SQhS4Qo9jaI8/WoP43QGArmsgSAGVSAmnkTUBoAeYIwUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCJIAUAAKCpN0HKt5UauWHugZEbxk8oVXgyWUIpZfv33VA0IGlcEQndUbltL1u0sVciFv&#43;mtb0VAHBXdwtSoTu6YWgJ3blnOF/TQe7RzS4QMRdRFEVRtN4/mQQrNZZVFEXRwgzdkapS2trQHXFkbVbaGmfk28Jfesb7n4GISPjzvbE&#43;Cg3fzKYtPXl7uXTFj9837pNyoihKG&#43;3W7wUAj6AfFSn/cybO13Tg24Uj7m8&#43;I9l&#43;EqxWVn4N1irKCRwj9wa2UkoNZ5vbf5bnksTcg5VVbo0oWpiZhTI5yv&#43;cbcQbV2Wv&#43;rkmn6jHnhxZcz7bPX7fiLc3iqL7vF3aaMQpAM/gv7Y3oAG&#43;Pd46wWIg/ufWeRWlxulTs28niNZXlit8W81fgygKbDXeXrmtnRIfBe92AL5Q6M496yMaxP/dOkE0FXc03H3k09aeb6uxV3p0qGa5n61VtDBlMF1H0&#43;RNRsPv92B9rtT14H3jyha8MgbF7/uYvQgAmtJaRSr313/uj/tsTSl0Ryo3G6Y81uPb463zNR1I6M7lYzpNShyBY4i1Kh0J92NJh3JDvKJi6SFbYDAX0dkD6v0960hN&#43;POdNI3/OXu7YFTPcIJ8xSv/QKH4mKz5sgHDR&#43;4bcRWqkGCOV9gqSKa8dKHyxmSrUw/TiwCgMS0FKd/&#43;K1&#43;HA5k3jsOSObFEtr/pkEz4872R/SjOkUX8pSeb2VApNdx9FEsSmVUlMiN71uowaHRmaO&#43;hPPVIjf&#43;ZRFzfHm&#43;dfxVFqJPC3&#43;3ZmU&#43;&#43;PfYM5595YgLXo56ikM1P5R5yZSS6xmP1IgBoTktBylwc/o4f/Hk3ZPP9kySp/X9FRILdRpLCwJFF9pNsVo4T5GPU4OVtn7DKx7/wNzsMM5iuS6NCVY&#43;171iZodbitQoSWQ9wIAzduWcYhoiIv9zmzi4o1BSPzJAKf743Vfk6I45RX9NBeQJXEq&#43;tVe/6xt08QC8CgCa1Ptnct/PDaNkk5S89sSalQ1ZhEZHQHS1fiiflxVNj8qM4&#43;2y0Hx3azke2f/LEsQepO6TbUz5M1g1GtWoSlYfk7IHwzsfC0P07e1t9vYtIPliLlGqK1QNucT1rMxsebVrfrphSFT&#43;h1PD7PTh0o0fRlQiVRZwC0ButDe0lB&#43;LlJH8KXSZJ5XPU0UV8ezjbJPWI0e&#43;/9Fi6spJhwcKbf84krmqINx65w0PdIZ5XVcxdN3X6QJI9RpYPk1dGomukq73nsTDYSf2xvIPQHY29OFkHznZcUbQK3dHYsyyrcnGR8gU2oKmL4Q8AKrUSpOLBk6A6q5gTK74AVC5HHV/EX3pyqEdkCxHDV2OzC&#43;L/h&#43;4oKUL4S894f38TeftYB44cBhJbcexA0pUjzT3jVLEIVYdvq&#43;FMnP15eIPpOnCkWJjyP2fiBIuJiEhQvLjY2CuMFD/MZaO6Vd3pSscGgAvdLUgFu40Yr0OR/QylzITfOAqlzIkl3tLP5agTi8QTWapqR4OXN/GWvm&#43;reFBmYUpy8vz0Zf&#43;S6Xo9DdJa1zB3UaI2jpTpYbpbR5oHOJYXz7vMRKTd5yi&#43;/Go2hw2m62hleWP7J30oewrecLrOV/RKZ/s92Nl6N2oCVdPZ9XSrYwPAWXcKUqE799Jp44OXNxFvmV7yoDgpxZxY4s3n28y43rlFDldGyKYfc2KJNx57VnwM9W01cn92b8WZwoc5xfmhvTaOlB09xjzAMbJ43mWmkV/raujtrmIosWfO27kzWXjVDnW1I1EFSPEJ1VuUrZvdLR7A8AJNw9ScbVnOHtbHQ5l5iJwjKSCMH8NipcZNyeWbDab7Dzzo4vsryu9&#43;8imnyRX7fPW9jfcZ7m3l&#43;mi9sSnZHbW2JPD6M7t5qE/QHWnhgeIUFcKdldck/zOfeNCaWop96Lrg9GFKEEBeBZ1/&#43;gsf9VeuYZGHc5PLz&#43;WO4UvvRFJMcTlFU76a9rZvddIG2VX1VT3uOQFZzep1sW60qYonhFQ/VCiNCJX8d6FF&#43;QWyfSPpjtDUy17yRtJUuy89RtFjXba23n8LdTT18/VITRBVzTYUtde11Hd8cqQTfJtNZZV2&#43;exX7j30qJC4cV1S1Z1W6py89Rld/y4XccIy/eDqXioA&#43;78u3Nhwz34WzSlq19c5/T1c3UITdAVDbbUswapx1B37xUOVLfe&#43;dn1HwtzlyyLSuyiFvV15/f1c3UITdAVDbZUH25a/DyiNu4C26EyAwAAd0aQ6p5snLo1/roCAOAEglRX3SHfEKEAADit9XvtAQAAdBVBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQFMDlz/oxL11AQAAGndtRaqpe/49rUZa8TEpnNR2&#43;&#43;BKvp005cgN00dDd3RoY9vPvDT5IX1VsljlIgC6gqE93ETbAbUb2m4laPNtNfasVdyOX/KTJqa/8rVv3cAxvHEclsyJJbL9TeNW&#43;PO9EeP9z&#43;D4IgC6ghuAAHg66sp7H4XuaDh7W0UL89yLxAnW04H4thpv4/9KHMOkaunsIjqu/Vy4Gk3QFQ22FBUpAKhp8PIm4o1PjMP5thrONumP5sSSzfdPXGvyl55Yk1KKKiwCoBsIUgBQl7kIHEO8cWGK1GHe1HISRSsrs8AhSeVz1PFFAHQCQQoA6htM1/GsJtnMhnGW8u2xZzhBFEVRedjOnFiy2QWFHHVyEQBdQJACAF2D6TpwjLjWFP5uRd5e0tlN/tLLvtScWOIt/VyOOrMIgA4gSAFATaFrp&#43;N5wW5/Bl48cWqZnsA3LoQic2KJN59vM&#43;N65xYB8PgIUgBQ02A62Q33U5sOZ&#43;OZi8Ax4nlTSs1fg&#43;KEJ3NiyWazyc4zP7cIgIfHiZoAnk5fz1Hv6&#43;fqEJqgK7j8AQAAQPsIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgAAAJoIUgCgLXRHSimlRm7Y9qYAaAVBCgBq8m21N/x&#43;D6IoitbTQRqqcmy/7Y0FcFMEKQCoyVxEURRFgWMUn7FW0UHF8wD6hiAFAACgiSAFAPUkI3vD2UY2syFjeMAzI0gBQD3ZkT3DCeJxvIXZ9mYBaANBCgB0hD/fm7a3AUDr/rtyeaVUI9vxtKIoansTAGjwP2cbEZHvvyP5Wk8HbW8PgHZcG6SEKHAFYijQVf7SMyxLPG&#43;zkc1Q7VbRYtj2NgFoAUN7AFBX6M496&#43;Pf636O1Mryxkw2B54TQQoA6gndvzNx/h1ml5sLJpsDz6qBoT2gjFHLSzAs3lHBTpyv6UC4KwwAKlK4mQgntd0&#43;0Gcujk4u98aZ28MMZ5zWhxsK3VHN65f59qW3hbz8lSBIAUBjuEUM7mcw/bjV7Dx/6cnbC&#43;eiXkRd&#43;ZexUteu4Zn1eO/1&#43;KM1hV3Uor7u/L5&#43;rg65exP4tpq/Bpdef&#43;PEq0N3VKOEaq26PiuwwZYiSLWpx3uvxx&#43;tKeyiFvV15/f1c3XILZvAt9XYu&#43;iVScy5bIlSKArd0fD7/eJ01k0NthRDewAAPL79rYmyAsc43KXoIJOL8s&#43;urMIDVcPP/udsY330OkU1iyAFAMAzCH&#43;3Z2c&#43;&#43;fbYM5x/ZnJr7gpcMy2PIAUAwBMIf743sv09dS5eHKO&#43;poNy/SspXlmrjs&#43;OahxBCgCA/otvD7mZDY&#43;WlHz7yJQq31Zq&#43;P0eFMYNISIEKQAAuqE03DacbWQzG14w8ha6o7EXz48KnO244iJRoTsae5ZlHXnvuE6FCr0JUr6t8h0juZpY0vFKvWb/BIO9AIAuqBxuK002L5eMfFsNZ&#43;Lsz8MbTNeBI8XClP85EydYTEREAneUz2Zjr5DXuFhnxt2CVOiObhhaQnfulePyZhccOl5yImea6MeyirtcWOwy5VSfewnRCwDQDbvPUXy4y17NYDBdx7fa/kkfMheHVwyn63w2K53t1&#43;9LI9TUj4qU/zkT52s68O1CyvnNZyTbT4LVqlC9zF2OuHBKaOiO/srX4QlvTJYCgLuJv8Db3oqOev23rp7XZC6iaPHn/hvUP324abFvj7dOsBiI/7l1XkWpcfrU7NsJovWVwXkwXa8zP3xYs7G39BcmE&#43;4AII440Y0vBBpFUZqlbv1ezyTYcT/Iq7VWkaocLPPtwshZ6I4OY7HV42u&#43;Pd7GN2J35/IxnS4yNSVrVSo/7kf2xl5yd9F4Rbk7jaqTNxsdvnL7LECEOsHTizvA3WJNOmLwnB2v8rpOlZPNz09BORxN42tGnX3PsWe8/2Ew75joOhevIXCMzADayjoMtwaOkV58dWXlrsOaf6pykcwYXX547sgFX5P3z7w&#43;jlzlzS0&#43;Vt6ma12/2/nyu7R/EfLjNGfbNvTizb2yuvduvUb&#43;QU/&#43;xZR5iB60/dqVre29nJ3&#43;1yFFq/7vo0cqh6z1z3gJqFSgy3VUpAqP1WZpFbWkWVKaWbllA5/xWlQmawVz4Cq3pozchHsWtoN&#43;fjHyBOLVDVMlfxeLuSoWk1wcTw62uEKcndV0O0Nt2vBtMnu00nK7/v4rt/Owh99Dbn277Q7tHhlK1/2K51z601qy&#43;NsCU5rsKVan2zu27lhNHNiyeb7Jx7L85eeWJPqEzmzI2&#43;hO1q&#43;FE/Ki2/VWPhKiifchT/fGxHZzke2f6ReWl0cDd3R2Gv3sq49qKWX7xdVnV9ye9lfppVl/3O2KY3FxuqfkZs/ZfMw4nuiQzzyyQdp99DrIcc/ebXC4o13FTyObNcq965aR51mN&#43;wW31FALS0FqUN4WU7yJYpMksrnqKOL&#43;PZwtkmOfqPff9nDc&#43;Worv85EyOuKHjjkTs8HNeLpY58YPLt4WxjOEFLMeqZj5GhO/f299AM3fnWCY6UpeIpcaVoXLoEilJJSh4czvK9YMBwYcaLHKbeDaYfloi3bDdJpR&#43;q3D3qNnqdA2J1V8x2lVZ6C5p1rGs9mna/o/DMWglS8c18goqsIvsktQsKOer4Iv7Sk0M9Izu5fPhqbHZB/P/QHSVlA3/pGe/vbyJvH&#43;vAkaT8dUZyVdjmLp5x4W87x8i0hCgi4n/O3i64K/kdb3je7skH2b5RbrIrm/sa6Wo5sHVXVyJUFr0O93e3IBXsNmK8DkXi&#43;09nb0AdR6GUObHEW/q5HHVikXigqKpKNHh5E2/p&#43;7aKbxK0MCWtbbzsXzJdr6dBWsAY5saMDuNEoTsazjYV5wBe4&#43;x3E8fIvfgGUSL7UzSPn2FyxE1veB7&#43;fKc9&#43;666cpB7mgNbrusUOsupK/pmlnuYIeIO68rvBXql1vG48gh9ycuK5&#43;zJ4af9IF1u5rglYhi5kZszixwqDLnKw/6F&#43;&#43;VWlhiOY1mr6NisnOpZzI3OL885tvcaaZqbrvDsymu93ck53oFjJL2hdOZmXvJkoQBVMX&#43;32NAnJg4fbnh&#43;dNM1O4d2i9yoNW/aSe72Fhe6fjNyfWZlSfEsmdyP1Scpl15Z8WVYUyc6Rnc78IWb0fYm4CINttTNg1Qyl6l8bYLD0a90GIu/Ty5aJJ&#43;Vyq9Nv5fKWe6yIFU1CtRUrirsvXTtTay7&#43;EZ3PkY2FaTiJqlomBOn7uWD1GE63eHl&#43;YXjV1QcvQrHw8qNa&#43;GsvS52kgc5yKUaDVIVpyQfD9jZJFVe8FyXO6cTLVjxhXqBs2trZNuu9zhbgtMabKmbX9l8EUWL8qOD6Tqa5n5Hck&#43;bFUsdWWSQe2k8Bhd/N5mZx4ZqJiKG81V1CuA4N7IoY3X42XCCdeF9byjKXLq3Q9Qtr2sc7MT5Z8rPXG/xzNS20B0N1ag0yy254bm3rVzBiRuet3byQbyrb7rbG9SV7dQXj&#43;6&#43;50Z3zYkl3vY3FDPXe5KvG&#43;PYgo97ud9sr5NSg9b94qrbHyrX3/&#43;uhY5o/fIHzUrOwcoe2w7nZVVNcSqfi5919/syxm/blQkld5iOYC702&#43;CWNzxv/uSDum7UVY5OETvi7Hpu2j0eR9UkvORcl&#43;MnKR9Z8HGlX43l1q/1F/w12/BsXQuPrw/32tNhLh75F/BGJYem/mo89lfp3XnZ6qGIWKs0Qu8&#43;R8p7yxQmReJM/WKrsf3qJA&#43;Zi8gUEV8kvuF5rvjo22r&#43;WpGVkpMPovbvf06d4EGUq0&#43;yPwdhf8Zx2o36MaG8lbLoc3YtPL6eVaR6JfuXX/mIVbdsUOvvxRMRSh0/kfDuinNQMoXIG97w3LfjFNXiZVmL0j1AnaAFgz/vRlp92vOX3r7YdOKM48HLW&#43;EaZJkLfXRC2uvu8F7P2LXQEQSpR8cx8gauuOF56M49KV3/FHOWz/WVW7qweL1/Q2mH5Z448PAr28f7oCQT0u&#43;nZ2Saf5zDPHGSe8J3b/Hb5b&#43;wO7Q7s/atdANBKnO6McxMizOQ1Lq&#43;J1Z6t/x5cL3vuKG55lLoWc8UHVKqBPcn7mI4gl4&#43;46zdYK0T5iL&#43;D5CSiml5q9Bdo7UYLrOPPlXvqpPEgbwyK69a5u6433f&#43;kd776nbzxW48i2a7RihOxruPnJxpeKhjuF3p0V93fl9/VwdQhN0RYMtRZBqU4/3Xo8/WlPYRS3q687v6&#43;fqEJqgKxpsKYb2AAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANDVwi5h7XtYIAADgcVwbpDjPEwAAPC2G9gAAADQRpAAAADQ1MEcKqMTkOQBA7xGkcBNMngMAPAOG9gAAADQRpABAQ&#43;iOlO3XXMi31cgN0&#43;WT/wPoLoIUAFzLt1WFUk7yl57x/mcgIhL&#43;fG&#43;sj&#43;mgja0F0CCCFAA0wHCCKGtllV6SyVH&#43;52wj3vii&#43;AXgkRGkAKAe31ZKDZMktB/f28yGuTw09gpLhe7c29egQne&#43;dYIoChxDrFWUt6ZMBXQJZ&#43;0BQD3mIooWoTsa7j6ihSkiIosoWpxeKPz53sibiIj4n7O3j2ggQukJ6D4qUgBwjdAd5cflchOmkvno/udss/&#43;fPd46/8z2NhhAkwhSAHCteHwucIzcz4d5UqE79wzDEBHxl1vnKzN6V5goxQwpoGMY2gMAXUtbzaU8q7wgdP/O3lbB63y4EzEX61w1ylolw4MAuoiKFADU5tvD2UY8mUTrf69JWWmYjN4lZab9hPNgJ4zlAX1FRQoA6vFttZwEzna4m5giMl1H0&#43;Sp0B2p5Udx5vlibTKzHOgpKlIAUI&#43;5yIzG5a/FOSxfHurM5c&#43;LF5OqfbV0AK0iSAHAFcxFxUU4sxeHOjMDqngdKSZMAd1CkAKABvi2UstJfInN4HVOZQl4EgQpALiObyullpNDNWkwXUeTJdcyAJ4BQQoA6nFH8Wwoa2KG7ijOUKUhOXMRRV/ylzQF9JyKoqjtbQCAu1Kqn199ff1cHUITdEWDLUVFCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQBNBCgAAQNN/169CKXX9Sp4ZV28DAKCjGghSQhS4AjEUAIDuYmgPAABAUzMVKaCASttpFHEBoB8IUrgJgsIJpEwA6A2G9gAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADQRpAAAADT1Jkj5tlIjN8w9MHLD&#43;AmlCk8mSyilbP&#43;&#43;GwoAAHrjbkEqdEc3DC2hO/cM52s6yD262QUi5iKKoiiK1vsnk2ClxrKKoihamKE7UlUyW5t9CckLAADE&#43;lGR8j9n4nxNB75diDm/&#43;Yxk&#43;0mwWln5NVirKCdwjMzq7b/ylT7ujUvFLQAA8JT&#43;a3sDGuDb460TLAbif26dV1FqnD41&#43;3aCaD04sfAlzMXa3P938OfdmM2&#43;f8Lp9Nq1Ap2jlBKRKIra3hAAeBStVaRy42lJGcm3C0NnoTs6zG6qXCSOUV/TgYTuXD6m00WmpmSt1sW8sx/ZG3si3viwovj/B8PZ5sTGv72QovBw4q5763eJoij9Nbn1ewHA42spSGUGy7KjZebEEtn&#43;pgNn4c/3Roz3P4Pji/hLTzazoVJquPtYmPm3yawqkRnZs/ZzpETODO0dhO7f2cZw/plVT&#43;KmkrMHJI7UdcZXM4s29sqHEseauxWK0l8T4hQASHS1y1YSOEY5rmSeMpwgiuKEs/v/qfKZbKLxK90Mj8cFi7aryyOSdVbUyldV41lTmq2CW7kRptX1TBV8vt6ZaUNHhcb672jUeofxzbtkjVnc7ZGl2hwrxbaqO6a63xVHO2uD96NK3Vugy/U18/VITRBVzTYUq1PNvft3DCaObFk8/0T1wT8pSfWpFT9KSwiErqj5UvxpDw19kSKx8&#43;4/BT&#43;fG9EZDsf2X52iePn7SWn/kWTpc6Je&#43;U1Z9tST3fHcdKdmarOL7n6or/09qVJ8T9nm9JYbKx&#43;NSl/yuZhxPdUh3iAkw8KHanyqUtI/a&#43;S8sbEjzfeTwCgG&#43;p&#43;jVZ&#43;sV7wqnxF6lCUsFaFMtThh/zh9egiuQJHrkp1pA6xssQwDNn/k33FJaWOUjHsMsd2u0YTpGtopPlOv1Hl&#43;zbubCEo0zCBYxhOcLKtLit5lRYOHKN&#43;w2p1h2t2Y4OtcKMGvV0/adDjb6Gevn6uDqEJuqLBlmqlIuXbYy859hSnNcU1qV1QqEcdX8RfenI4KmYnlw9fjc0uiP8fuqOkjuQvPeP9/U3k7WMdOJKUvy41eHnbX6GqlsJ&#43;1/vz/VgRotbitcoV5Y/QRtVhX0IUEfE/Z28f58&#43;YzEebUqSumgLnf8421gWrrnCfkw&#43;ubP27aa&#43;fAEAL7hakgt1GjNehiEj4u80de&#43;IolDInlnhLP5ejTiwSDxSV8pjEkcdb&#43;r6tlBp&#43;vwcLU&#43;JLd1of05f9S6br9TRIx/aGuTGj6hGb8HcrySfRlx7SL3lxmmzKi9QNRnWD9rEtPxa2bsL/TEZyfXu8rT/VP/zdns06cVL/Z14y0JtZ831OPuhKhMoiTgF4EncKUqE79yT5c3/w8ibiLdNLHoy9/IvNiSXefL7NzI86t8hhpks2/ZgTS7zx2LNWUbSeDnxbjdyf3duqkLoOc3byw0X76lbojg6H0ND9O9uIZuGivuwRtHwQvTISXSNd7e2PlKE79wzDEBHxl9vc5esL05mOzFUKf743VSdwZsQx6ms6KE/gSopXVrbbJHFruPvIV0GR6GL4AwANNw9S8RFnOHtbHapG5iJwjOQgOH8NinNazIklm80mO8/86CLxIW24&#43;8imnyRX7fPW9jfcZ7m3l&#43;miqnh1ymC6jqeYpx&#43;ksv7VsK4ch47FqaYCVuj&#43;nb2tvt5FRMRc5ENLYZpTdaKJ61mb2fDoOQLlYJ4&#43;Edcyo6jQ5leefFBXt6o7Xem6ANCMWlWNY6WO61fSkEP5oPxYbuJMOr359MTk&#43;pPK65KqCd232KU3Wm0jb3FisvnKMpygamb56cnm2Ssl7H/ITgvPT14XsazKExMuuWyCzmzzaxqiwXZs9hvjdl33FrqynXX19XN1CE3QFQ22VOuXP2jWYLqOoihfPkgeq65YlM/Fz7r7qE3UzT/ib1eEKBah6vBtNZyJE8RrGEzXgSPFwpT/ORMnWExERILi3avHycVeTwweap58oC3eyekWFZ5VdUgTc&#43;bk3AA0APRbH&#43;61p8NcPOwXfnwoUh25qVmr2&#43;mNVW5MzjqMH&#43;8&#43;R8p7W0VRdkRuMF1HL7Ya269O8pC5iEwR8UVEhtN1NM2uz7fV/DU4neSaOfmgrnSHl/f/3doijXGP30sB4HZ6VpHqj2zhocHV1qpYnHjr9AWtFiGKQ3uZQuTrv3X1XDZzEUWLP1e8aZsnH5TdqJ&#43;cRgkKAFLPWpHqiGx1Skp/&#43;tc9dtY95lWuvyulspOC3al7Up82mK4ntlLj/Y/WKlq3fuvFQj&#43;5KXXHm/oBwOMjSHVAn8ZxQneUv79PqjBMJyJiOGfG1fTf23CCo/HHt5PzPcVwgor3NxdRtGhssxpzh85AhAKAggb&#43;uOQv1Gto7L00Tt16z8frf4QSVOiOhruP3FBdxUOdwa9M6/raBH39XB1CE3RFgy1FkGqZ9t67Q755hAjVS4AeGBcAAAJqSURBVPzKtK6vTdDXz9UhNEFXNNhSDO11FeM4AAC0jrP2AAAANBGkAAAANBGkAAAANDUzR&#43;qeFwMEAAB4EA0EKaYkAwCA58TQHgAAgCYuf4CGMc4LAHgeBCk0jKFeAMDzYGgPAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABAE0EKAABA039tbwAAtEAp1fYmAOgDghSApxNFUdubAKAnGNoDAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQRJACAADQ9F/bGwAAQH8opdreBNyViqKo7W0AAADoJIb2AAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANBGkAAAANP0f7j3Q9KJELeYAAAAASUVORK5CYII="
	
	
	
	loading="lazy"
	
		alt="img"
	
	
></p>
<p>　　线程1和线程2要想进行数据的交换一般要经历下面的步骤：</p>
<p>　　1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。</p>
<p>　　2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。</p>
<p>Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：</p>
<p>　　<strong>原子性（Atomicity）</strong>：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。</p>
<p>　　基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。</p>
<p>​		**可见性：**一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。</p>
<p>　　Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。</p>
<p>无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。</p>
<p>　　除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。</p>
<p>　　使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</p>
<p>　　使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</p>
<p>　　final关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。</p>
<p>　　**有序性：**对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。</p>
<p>Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，</p>
<p>在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。</p>
<h5 id="36java重排序了解吗谈谈重排序的3种情况">36.Java重排序了解吗？谈谈重排序的3种情况。</h5>
<p>首先我们先来了解一下什么是重排序:重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示</p>
<p><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180326170243607.png"
	width="1021"
	height="154"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180326170243607_hu4a528ffeaa11698ff2e2147279c4b74b_65508_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180326170243607_hu4a528ffeaa11698ff2e2147279c4b74b_65508_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="662"
		data-flex-basis="1591px"
	
></p>
<p>上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<p>1）<strong>数据依赖性（*<em>针对单个处理器而已*</em>）</strong></p>
<p>关于重排序，这里要先讲一个概念就是数据依赖性问题。如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型，如下表所示。</p>
<p><img src="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180326192837446.png"
	width="1015"
	height="279"
	srcset="/post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180326192837446_hu0f7d5083aeb15f8e44ab0aa1a5cbdd43_69495_480x0_resize_box_3.png 480w, /post/java8%E7%BA%BF%E7%A8%8B/index.assets/20180326192837446_hu0f7d5083aeb15f8e44ab0aa1a5cbdd43_69495_1024x0_resize_box_3.png 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="363"
		data-flex-basis="873px"
	
></p>
<p>上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的<strong>数据依赖性仅针对单个处理器中</strong>执行的指令序列和单个线程中执行的操作，<strong>不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</strong></p>
<p>**2）*<em>as-if-serial语义*</em></p>
<p>**</p>
<p>as-if-serial语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器**不会对存在数据依赖关系的操作做重排序。**as-if-serial语义把单线程程序保护了起来，as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<p><strong>3）happens-before</strong></p>
<p>​    如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p>对happens-before关系的具体定义如下。</p>
<p>① 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
②两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p>
<p>上面的①是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！上面的②是JMM对编译器和处理器重排序的约束原则。正如前面所言，其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。因此，happens-before关系本质上和as-if-serial语义是一回事。</p>
<p>·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
·as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。
as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</p>
<h5 id="37什么是可见性为什么存在可见性问题怎样解决可见性带来的问题">37.什么是可见性？为什么存在可见性问题？怎样解决可见性带来的问题？</h5>
<p>导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p>
<p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p>
<p>Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及六项 <strong>Happens-Before 规则</strong>，这也正是本期的重点内容。掌握这些方法，我们就可以按需地禁用缓存和编译优化了，也就掌握了Java内存模型最核心的东西。</p>
<p>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作，即被volatile修饰的变量写对读是可见的，确保线程在执行读操作时始终拿到的是新值。同时volatile禁止重排序功能，被volatile修饰的变量在进行读写时，这些变量是不能重排序；volatile变量前后的读写操作不能重排序</p>
<h5 id="38管程是什么谈谈它的重要性">38.管程是什么？谈谈它的重要性。</h5>
<p><strong>管程</strong>是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。</p>
<p>管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p>
<p><strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。但是<strong>管程利用OOP的封装特性解决了信号量在工程实践上的复杂性问题</strong>，因此java采用管理机制。</p>
<p>管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。所谓<strong>管程，指的是管理共享变量以及对其操作过程，让它们支持并发访问</strong>。</p>
<p>在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。所以今天我们重点介绍一下 MESA 模型。</p>
<p>在并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//此处自动加锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// x是共享变量,初始值=10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">12</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span><span style="color:#f92672">;</span> 
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>  
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#75715e">//此处自动解锁
</span></span></span></code></pre></div>
</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2023 浩&amp;琳
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
