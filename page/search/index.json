[{"content":"\u003c!DOCTYPE html\u003e\r","date":"2023-01-20T00:00:00Z","permalink":"https://haolovelin.com/post/%E7%BB%99%E7%90%B3%E7%9A%84%E4%BF%A1/","title":"给琳的信"},{"content":"go语言一些便捷的表达式：\n//三元运算符： func If(isTrue bool, a, b int) int { if isTrue { return a } return b } //int 最小值 INT_MIN := ^int(^uint(0) \u0026gt;\u0026gt; 1) //int 最大值 INT_MAX := int(^uint(0) \u0026gt;\u0026gt; 1) 1. 两数之和 Java实现：\nclass Solution { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; nums.length; i++){ if(map.containsKey(nums[i])){ return new int[]{map.get(nums[i]), i}; }else{ map.put(target - nums[i], i); } } return new int[]{-1,-1}; } } go实现：\nfunc twoSum(nums []int, target int) []int { m := make(map[int]int) for i, v := range nums { if val, ok := m[v]; ok { return []int{val, i} } else { m[target - v] = i } } return []int{-1, -1} } 2. 两数相加 Java实现：\nclass Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode pre = new ListNode(0); ListNode cur = pre; int carry = 0; int a, b, sum; while(l1 != null || l2 != null){ a = l1 == null ? 0 : l1.val; b = l2 == null ? 0 : l2.val; sum = a + b + carry; carry = sum / 10; cur.next = new ListNode(sum%10); cur = cur.next; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; } if(carry != 0){ cur.next = new ListNode(carry); } return pre.next; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { pre := new(ListNode) cur := pre carry, a, b, sum := 0,0,0,0 for l1 != nil || l2 != nil { if l1 == nil { a = 0 } else { a = l1.Val } if l2 == nil { b = 0 } else { b = l2.Val } sum = a + b + carry carry = sum / 10 cur.Next = new(ListNode) cur = cur.Next cur.Val = sum%10 if l1 != nil { l1 = l1.Next } if l2 != nil { l2 = l2.Next } } if carry != 0 { cur.Next = new(ListNode) cur = cur.Next cur.Val = carry } return pre.Next } 3. 无重复字符的最长子串 Java实现：\nclass Solution { public int lengthOfLongestSubstring(String s) { if (s == null) return 0; int len = s.length();//记录长度 if (len \u0026lt;= 1) return len; int[] flag = new int[128]; int max = 0; int start = 0; for (int i = 0; i \u0026lt; len; i++) {//遍历 char c = s.charAt(i);//当前字符 if (flag[c] != 0){//如果有记录 start = Math.max(flag[c], start);//标记起点 } max = Math.max(max, i - start + 1);//计算最大值 flag[c] = i + 1; } return max; } } go实现：\nfunc lengthOfLongestSubstring(s string) int { flag := [128]int{} max ,start := 0, 0 for i, char := range s { start = If(flag[char] != 0 \u0026amp;\u0026amp; flag[char] \u0026gt; start, flag[char], start) max = If(i - start + 1 \u0026gt; max, i - start + 1, max) flag[char] = i + 1 } return max } //三元运算符： func If(isTrue bool, a, b int) int { if isTrue { return a } return b } 4. 寻找两个正序数组的中位数 Java实现：\nclass Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { if (nums1.length \u0026gt; nums2.length) { return findMedianSortedArrays(nums2, nums1); } int m = nums1.length; int n = nums2.length; int left = 0, right = m; int leftTotal = (m + n + 1) / 2; // median1：前一部分的最大值 // median2：后一部分的最小值 int median1 = 0, median2 = 0; while (left \u0026lt;= right) { // 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1] // 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1] int i = (left + right) / 2; int j = leftTotal - i; // nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j] int nums_im1 = (i == 0 ? Integer.MIN_VALUE : nums1[i - 1]); int nums_i = (i == m ? Integer.MAX_VALUE : nums1[i]); int nums_jm1 = (j == 0 ? Integer.MIN_VALUE : nums2[j - 1]); int nums_j = (j == n ? Integer.MAX_VALUE : nums2[j]); if (nums_im1 \u0026lt;= nums_j) {//如果nums1[i-1]小于等于nums2[j]，说明分割线符合要求，记录可能的中位数 median1 = Math.max(nums_im1, nums_jm1); median2 = Math.min(nums_i, nums_j); left = i + 1; } else { right = i - 1; } } return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1; } } go实现：\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 { //int 最小值 INT_MIN := ^int(^uint(0) \u0026gt;\u0026gt; 1) //int 最大值 INT_MAX := int(^uint(0) \u0026gt;\u0026gt; 1) if len(nums1) \u0026gt; len(nums2) { return findMedianSortedArrays(nums2, nums1) } m := len(nums1) n := len(nums2) left := 0 right := m leftTotal := (m + n + 1)/2 median1 := 0 median2 := 0 for left \u0026lt;= right { i := (left + right)/2 j := leftTotal - i var nums1_i1,nums1_i,nums2_j1,nums2_j int if i == 0 { nums1_i1 = INT_MIN } else { nums1_i1 = nums1[i - 1] } if i == m { nums1_i = INT_MAX } else { nums1_i = nums1[i] } if j == 0 { nums2_j1 = INT_MIN } else { nums2_j1 = nums2[j - 1] } if j == n { nums2_j = INT_MAX } else { nums2_j = nums2[j] } if nums1_i1 \u0026lt;= nums2_j { if nums1_i1 \u0026gt; nums2_j1 { median1 = nums1_i1 } else { median1 = nums2_j1 } if nums1_i \u0026lt; nums2_j { median2 = nums1_i } else { median2 = nums2_j } left = i + 1 } else { right = i - 1 } } if (m + n) % 2 == 0{ return float64(median1 + median2) / 2.0 } else { return float64(median1) } } 5. 最长回文子串 Java实现：\nclass Solution { public String longestPalindrome(String s) { if (s == null || s.length() \u0026lt; 1) { return \u0026#34;\u0026#34;; } int start = 0, end = 0, maxlen = 0; for (int i = 0; i \u0026lt; s.length(); i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len \u0026gt; maxlen) { maxlen = len; start = i - (maxlen - 1) / 2; } } return s.substring(start, start + maxlen); } public int expandAroundCenter(String s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.length() \u0026amp;\u0026amp; s.charAt(left) == s.charAt(right)) { --left; ++right; } return right - left - 1; } } go实现：\nfunc longestPalindrome(s string) string { if len(s) == 0 { return \u0026#34;\u0026#34; } start ,max := 0,0 for index, _ := range s { len1 := expandAroundCenter(s, index, index) len2 := expandAroundCenter(s, index, index + 1) len1 = If(len1 \u0026gt; len2, len1, len2) if len1 \u0026gt; max { max = len1 start = index - (max - 1)/2 } } return s[start:start + max] } func expandAroundCenter(s string, left, right int) int { for left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; len(s) \u0026amp;\u0026amp; s[left] == s[right] { left-- right++ } return right - left - 1 } //三元运算符： func If(isTrue bool, a, b int) int { if isTrue { return a } return b } 6. Z 字形变换 Java实现：\nclass Solution { public String convert(String s, int numRows) { if (numRows \u0026lt;= 1 || s.length() \u0026lt;= 1)return s;//如果行数为1，或者s长度小于等于1，直接返回s StringBuilder[] res = new StringBuilder[numRows]; for(int i = 0; i \u0026lt; numRows; i++) { res[i] = new StringBuilder(); } int index = 0;//索引 boolean back = false;//看是否需要往上跑 for (int i = 0; i \u0026lt; s.length(); i++) {//遍历s res[index].append(s.charAt(i));//添加到容器里面 if (back){//如果需要往上走，索引-- index--; }else{//往下走，索引++ index++; } if (index == numRows - 1){//如果到了底部，下一次该往上走了 back = true; }else if (index == 0){//如果到了顶部，下一次该往下走了 back = false; } } StringBuilder sb = new StringBuilder();//用于拼接字符，返回结果 for (int i = 0; i \u0026lt; numRows; i++) {//遍历每行的容器 sb.append(res[i]);//拼接到结果的StringBuilder } return sb.toString(); } } go实现：\nfunc convert(s string, numRows int) string { if numRows \u0026lt;= 1 { return s } var res strings.Builder var values []strings.Builder for i := 0; i \u0026lt; numRows; i++ { var builder strings.Builder values = append(values, builder) } back := false index := 0 for i := 0; i \u0026lt; len(s); i++ { values[index].WriteByte(s[i]) if back { index-- } else { index++ } if index == numRows - 1 { back = true } else if index == 0{ back = false } } for i := 0; i \u0026lt; numRows; i++ { res.WriteString(values[i].String()) } return res.String() } 7. 整数反转 Java实现：\nclass Solution { public int reverse(int x) { int res = 0;//存结果 int last = 0;//防止溢出的临时变量 int tmp = 0;//存余数 while(x!=0) {//无论正还是负，只要x不为0，就一直进行求余数 //每次取末尾数字 tmp = x%10; last = res;//存一下上一次的结果，用于判断 res = res*10 + tmp;//计算当前步骤的结果 if(last != res/10)//按理来说应该相等，不等的时候，说明整数溢出，返回0 { return 0; } x /= 10; } return res; } } go实现：\nfunc reverse(x int) int { INT_MIN := -(1 \u0026lt;\u0026lt; 31) INT_MAX := (1 \u0026lt;\u0026lt; 31) - 1 res,temp := 0,0 for x != 0 { temp = x % 10 res = res * 10 + temp if res \u0026gt; INT_MAX || res \u0026lt; INT_MIN { return 0 } x /= 10 } return res } 8. 字符串转换整数 (atoi) Java实现：\npublic class Solution { public int myAtoi(String str) { char[] chars = str.trim().toCharArray();//trim去掉空格 int n = chars.length; int idx = 0; if (n == 0) return 0;//长度为0 boolean negative = false; if (chars[idx] == \u0026#39;-\u0026#39;) { //遇到负号 negative = true; idx++; } else if (chars[idx] == \u0026#39;+\u0026#39;) { // 遇到正号 idx++; } else if (!Character.isDigit(chars[idx])) { // 其他符号 return 0; } int ans = 0; while (idx \u0026lt; n \u0026amp;\u0026amp; Character.isDigit(chars[idx])) { int digit = chars[idx] - \u0026#39;0\u0026#39;; if (ans \u0026gt; (Integer.MAX_VALUE - digit) / 10) { // 本来应该是 ans * 10 + digit \u0026gt; Integer.MAX_VALUE // 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。 return negative? Integer.MIN_VALUE : Integer.MAX_VALUE; } ans = ans * 10 + digit; idx++; } return negative? -ans : ans; } } go实现：\nfunc myAtoi(s string) int { if len(s) == 0 { return 0 } INT_MIN := -(1 \u0026lt;\u0026lt; 31) INT_MAX := (1 \u0026lt;\u0026lt; 31) - 1 negative := false number := false ans := 0 for _, value := range s { if !number \u0026amp;\u0026amp; value == \u0026#39; \u0026#39; { continue } else if !number \u0026amp;\u0026amp; value == \u0026#39;-\u0026#39; { negative = true number = true continue } else if !number \u0026amp;\u0026amp; value == \u0026#39;+\u0026#39; { number = true continue } else if !number \u0026amp;\u0026amp; value - \u0026#39;0\u0026#39; \u0026gt;= 0 \u0026amp;\u0026amp; value - \u0026#39;9\u0026#39; \u0026lt;= 0 { ans = ans * 10 + int(value - \u0026#39;0\u0026#39;) number = true } else if number \u0026amp;\u0026amp; value - \u0026#39;0\u0026#39; \u0026gt;= 0 \u0026amp;\u0026amp; value - \u0026#39;9\u0026#39; \u0026lt;= 0 { ans = ans * 10 + int(value - \u0026#39;0\u0026#39;) if ans \u0026gt; INT_MAX { if negative { return INT_MIN } else { return INT_MAX } } } else { break } } if negative { return -ans } else { return ans } } 9. 回文数 Java实现：\nclass Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0) return false;//负数 int cur = 0; int num = x; while(num != 0) {//只要不为0 cur = cur * 10 + num % 10; num /= 10; } return cur == x; } } go实现：\nfunc isPalindrome(x int) bool { if x \u0026lt; 0 { return false } cur := 0 num := x for num != 0 { cur = cur * 10 + num % 10 num /= 10 } return cur == x } 10. 正则表达式匹配 Java实现：\nclass Solution { public boolean isMatch(String s, String p) { int m = s.length(); int n = p.length(); boolean[][] f = new boolean[m + 1][n + 1]; f[0][0] = true; for (int i = 0; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (p.charAt(j - 1) == \u0026#39;*\u0026#39;) {//如果j-1是*，则j-2可以不匹配，即f[i][j] = f[i][j-2] f[i][j] = f[i][j - 2]; if (matches(s, p, i, j - 1)) {//如果匹配 f[i][j] = f[i][j] || f[i - 1][j]; } } else {//正常字符匹配 if (matches(s, p, i, j)) { f[i][j] = f[i - 1][j - 1]; } } } } return f[m][n]; } public boolean matches(String s, String p, int i, int j) { if (i == 0) { return false; } if (p.charAt(j - 1) == \u0026#39;.\u0026#39;) {//.匹配任意字符 return true; } return s.charAt(i - 1) == p.charAt(j - 1); } } go实现：\nfunc isMatch(s string, p string) bool { m := len(s) n := len(p) dp := [21][31]bool{} dp[0][0] = true for i := 0; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { if p[j-1] == \u0026#39;*\u0026#39; { dp[i][j] = dp[i][j-2] if Match(s,p,i,j-1) { dp[i][j] = dp[i][j] || dp[i-1][j] } } else if Match(s,p,i,j){ dp[i][j] = dp[i-1][j-1] } } } return dp[m][n] } func Match(s, p string, i, j int) bool { if i == 0 { return false } if p[j-1] == \u0026#39;.\u0026#39; { return true } return s[i - 1] == p [j - 1] } 11. 盛最多水的容器 Java实现：\nclass Solution { public int maxArea(int[] height) { int left=0, right=height.length - 1, max = 0, tmp; while(left \u0026lt; right) { tmp = (right - left) * Math.min(height[left], height[right]); max = max \u0026gt; tmp ? max : tmp; if(height[left] \u0026lt; height[right]) { left++; } else { right--; } } return max; } } go实现：\nfunc maxArea(height []int) int { max, left, right, area := 0,0,len(height) - 1, 0 for left \u0026lt; right { area = (right - left) * Min(height[left], height[right]) max = Max(max, area) if height[left] \u0026lt; height[right] { left++ } else { right-- } } return max } func Max(a, b int) int { if a \u0026gt; b { return a } return b } func Min(a, b int) int { if a \u0026gt; b { return b } return a } 15. 三数之和 Java实现：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { int n = nums.length, target = 0; int j,k; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); Arrays.sort(nums); for(int i = 0;i \u0026lt; n - 2; i++){ if(i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]){ continue; } k = n-1; target = -nums[i]; for(j = i+1; j \u0026lt; n - 1; j++){ if(j \u0026gt; i+1 \u0026amp;\u0026amp; nums[j] == nums[j-1]){ continue; } while(j\u0026lt;k \u0026amp;\u0026amp; nums[j] + nums[k] \u0026gt; target) { k--; } if(j==k) break; if(nums[j] + nums[k] == target) { res.add(new ArrayList\u0026lt;Integer\u0026gt;(Arrays.asList(nums[i],nums[j],nums[k]))); } } } return res; } } go实现：\nfunc threeSum(nums []int) [][]int { n,target,j,k := len(nums),0,0,0 res := [][]int{} sort.Ints(nums) for i := 0; i \u0026lt; n - 2; i++{ if i \u0026gt; 0 \u0026amp;\u0026amp; nums[i - 1] == nums[i] { continue } k = n - 1 target = -nums[i] for j = i + 1; j \u0026lt; n - 1; j++ { if j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j - 1] == nums[j] { continue } for j \u0026lt; k \u0026amp;\u0026amp; nums[j] + nums[k] \u0026gt; target { k-- } if j == k { break } if nums[j] + nums[k] == target { res = append(res, []int{nums[i],nums[j],nums[k]}) } } } return res } 17. 电话号码的字母组合 Java实现：\nclass Solution { public List\u0026lt;String\u0026gt; letterCombinations(String digits) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;String\u0026gt;(); int len = digits.length(); if(len == 0) return res; String[] phoneMap = { \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34; }; deal(res, phoneMap, digits, 0, new StringBuilder()); return res; } public void deal(List\u0026lt;String\u0026gt; res, String[] phoneMap, String digits, int index, StringBuilder combination){ if (index == digits.length()) { res.add(combination.toString()); } else { int digit = digits.charAt(index) - \u0026#39;2\u0026#39;; String letters = phoneMap[digit]; int len = letters.length(); for(int i = 0 ; i \u0026lt; len ; i++){ combination.append(letters.charAt(i)); deal(res, phoneMap, digits, index + 1, combination); combination.deleteCharAt(index); } } } } go实现：\nfunc letterCombinations(digits string) []string { res := []string{} length := len(digits) if length == 0 { return res } phoneMap := []string{ \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;} res = deal(res, phoneMap, digits, 0, \u0026#34;\u0026#34;) return res } func deal(res, phoneMap []string, digits string, index int, combination string) []string { if index == len(digits) { res = append(res, combination) } else { digit := digits[index] - \u0026#39;2\u0026#39; letters := phoneMap[digit] for _, value := range letters { res = deal(res, phoneMap, digits, index + 1, combination + string(value)) } } return res } 19. 删除链表的倒数第 N 个结点 Java实现：\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode pre = new ListNode(0); pre.next = head; ListNode fast = pre; ListNode slow = pre; for(int i = 0; i \u0026lt; n; i++){ fast = fast.next; } while(fast.next != null){ fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return pre.next; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { pre := new(ListNode) pre.Next = head fast := pre slow := pre for i := 0; i \u0026lt; n; i++ { fast = fast.Next } for fast.Next != nil { fast = fast.Next slow = slow.Next } slow.Next = slow.Next.Next return pre.Next } 20. 有效的括号 Java实现：\nclass Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int n = s.length(); if (n % 2 == 1) { return false; } for(int i = 0; i \u0026lt; n; i++){ char c = s.charAt(i); switch(c){ case \u0026#39;(\u0026#39;: case \u0026#39;[\u0026#39;: case \u0026#39;{\u0026#39;: stack.push(c); break; case \u0026#39;)\u0026#39;: if(stack.isEmpty() || stack.pop() != \u0026#39;(\u0026#39;) return false; break; case \u0026#39;]\u0026#39;: if(stack.isEmpty() || stack.pop() != \u0026#39;[\u0026#39;) return false; break; case \u0026#39;}\u0026#39;: if(stack.isEmpty() || stack.pop() != \u0026#39;{\u0026#39;) return false; break; } } if(stack.isEmpty()) return true; return false; } } go实现：\nfunc isValid(s string) bool { if len(s) % 2 != 0 { return false } index := 0 for index \u0026lt; len(s) { switch s[index] { case \u0026#39;(\u0026#39;,\u0026#39;[\u0026#39;,\u0026#39;{\u0026#39;: index++ continue case \u0026#39;)\u0026#39;: if index \u0026lt;= 0 || s[index - 1] != \u0026#39;(\u0026#39; { return false } else { s = s[:index - 1] + s[index + 1:] index-- } case \u0026#39;]\u0026#39;: if index \u0026lt;= 0 || s[index - 1] != \u0026#39;[\u0026#39; { return false } else { s = s[:index - 1] + s[index + 1:] index-- } case \u0026#39;}\u0026#39;: if index \u0026lt;= 0 || s[index - 1] != \u0026#39;{\u0026#39; { return false } else { s = s[:index - 1] + s[index + 1:] index-- } } } if index == 0 { return true } else { return false } } 21. 合并两个有序链表 Java实现：\nclass Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode pre = new ListNode(0); ListNode cur = pre; if(list1 == null) return list2; if(list2 == null) return list1; while(list1 != null \u0026amp;\u0026amp; list2 != null){ if(list1.val \u0026lt; list2.val){ cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } cur = cur.next; } if(list1 == null) cur.next = list2; if(list2 == null) cur.next = list1; return pre.next; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { pre := new(ListNode) cur := pre if list1 == nil { return list2 } if list2 == nil { return list1 } for list1 != nil \u0026amp;\u0026amp; list2 != nil { if list1.Val \u0026lt; list2.Val { cur.Next = list1 cur = cur.Next list1 = list1.Next } else { cur.Next = list2 cur = cur.Next list2 = list2.Next } } if list1 == nil { cur.Next = list2 } if list2 == nil { cur.Next = list1 } return pre.Next } 22. 括号生成 Java实现：\nclass Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; res = new ArrayList\u0026lt;String\u0026gt;(); backtrack(res, new StringBuilder(), 0, 0, n * 2); return res; } public void backtrack(List\u0026lt;String\u0026gt; res, StringBuilder cur, int left, int right, int max){ if(cur.length() == max){ res.add(cur.toString()); } if(left \u0026lt; max/2){ cur.append(\u0026#39;(\u0026#39;); backtrack(res, cur, left + 1, right, max); cur.deleteCharAt(cur.length() - 1); } if(right \u0026lt; left) { cur.append(\u0026#39;)\u0026#39;); backtrack(res, cur, left, right + 1, max); cur.deleteCharAt(cur.length() - 1); } } } go实现：\nfunc generateParenthesis(n int) []string { res := []string{} if n == 0 { return res } res = backtrack(res, \u0026#34;\u0026#34;, n * 2, 0, 0) return res } func backtrack(res []string, s string, n, left, right int) []string { if len(s) == n { res = append(res, s) return res } if left \u0026lt; n/2 { res = backtrack(res, s + \u0026#34;(\u0026#34;, n, left + 1, right) } if left \u0026gt; right { res = backtrack(res, s + \u0026#34;)\u0026#34;, n, left, right + 1) } return res } 23. 合并K个升序链表 Java实现：\n/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.length == 0) return null; return merge(lists, 0, lists.length - 1); } private ListNode merge(ListNode[] lists, int left, int right) { if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l1 = merge(lists, left, mid); ListNode l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); } public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode pre = new ListNode(0); ListNode cur = pre; if(list1 == null) return list2; if(list2 == null) return list1; while(list1 != null \u0026amp;\u0026amp; list2 != null){ if(list1.val \u0026lt; list2.val){ cur.next = list1; list1 = list1.next; } else { cur.next = list2; list2 = list2.next; } cur = cur.next; } if(list1 == null) cur.next = list2; if(list2 == null) cur.next = list1; return pre.next; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { if len(lists) == 0 { return nil } return merge(lists, 0, len(lists) - 1) } func merge(lists []*ListNode, left, right int) *ListNode { if left == right { return lists[left] } mid := left + (right - left) / 2 l1 := merge(lists, left, mid) l2 := merge(lists, mid + 1, right) return mergeTwoLists(l1, l2) } func mergeTwoLists(left, right *ListNode) *ListNode { if left == nil { return right } if right == nil { return left } pre := new(ListNode) cur := pre for left != nil \u0026amp;\u0026amp; right != nil { if left.Val \u0026lt; right.Val { cur.Next = left left = left.Next } else { cur.Next = right right = right.Next } cur = cur.Next } if left == nil { cur.Next = right } else { cur.Next = left } return pre.Next } 31. 下一个排列 Java实现：\nclass Solution { public void nextPermutation(int[] nums) { if(nums.length \u0026lt; 2) return; int i = nums.length - 2; while (i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i + 1]) { i--; } if (i \u0026gt;= 0) { int j = nums.length - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j]) { j--; } swap(nums, i, j); } reverse(nums, i + 1); } public void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } public void reverse(int[] nums, int start) { int left = start, right = nums.length - 1; while (left \u0026lt; right) { swap(nums, left, right); left++; right--; } } } go实现：\nfunc nextPermutation(nums []int) { if len(nums) \u0026lt;= 1 { return } i := len(nums) - 2 for i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i+1] { i-- } if i \u0026gt;= 0 { j := len(nums) - 1 for j \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[j] { j-- } nums[i], nums[j] = nums[j], nums[i] } left := i + 1 right := len(nums) - 1 for left \u0026lt; right { nums[left], nums[right] = nums[right], nums[left] left++ right-- } } 32. 最长有效括号 Java实现：\nclass Solution { public int longestValidParentheses(String s) { int maxans = 0; int[] dp = new int[s.length()]; for (int i = 1; i \u0026lt; s.length(); i++) { if (s.charAt(i) == \u0026#39;)\u0026#39;) { if (s.charAt(i - 1) == \u0026#39;(\u0026#39;) { dp[i] = (i \u0026gt;= 2 ? dp[i - 2] : 0) + 2; } else if (i - dp[i - 1] \u0026gt; 0 \u0026amp;\u0026amp; s.charAt(i - dp[i - 1] - 1) == \u0026#39;(\u0026#39;) { dp[i] = dp[i - 1] + ((i - dp[i - 1]) \u0026gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; } maxans = Math.max(maxans, dp[i]); } } return maxans; } } go实现：\nfunc longestValidParentheses(s string) int { max := 0 dp := [30000]int{} length := len(s) for i := 1 ; i \u0026lt; length; i++ { value := s[i] if value == \u0026#39;)\u0026#39; { if s[i - 1] == \u0026#39;(\u0026#39; { if i \u0026gt;= 2 { dp[i] = dp[i - 2] + 2 } else { dp[i] = 2 } } else if i - dp[i - 1] \u0026gt; 0 \u0026amp;\u0026amp; s[i - dp[i - 1] - 1] == \u0026#39;(\u0026#39;{ if i - dp[i - 1] - 2 \u0026gt;= 0 { dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2] } else { dp[i] = dp[i - 1] + 2 } } } if max \u0026lt; dp[i] { max = dp[i] } } return max } 33. 搜索旋转排序数组 Java实现：\nclass Solution { public int search(int[] nums, int target) { int n = nums.length; if (n == 0) { return -1; } if (n == 1) { return nums[0] == target ? 0 : -1; } int l = 0, r = n - 1; int mid = 0; while (l \u0026lt;= r) { mid = (l + r) / 2; if (nums[mid] == target) { return mid; } if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return -1; } } go实现：\nfunc search(nums []int, target int) int { n := len(nums) if n == 0 { return -1 } if n == 1 { if nums[0] == target { return 0 } else { return -1 } } left, right, mid := 0, n - 1, 0 for left \u0026lt;= right { mid = (left + right) / 2 if nums[mid] == target { return mid } if nums[0] \u0026lt;= nums[mid] { if nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid] { right = mid - 1 } else { left = mid + 1 } } else { if nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n - 1] { left = mid + 1 } else { right = mid - 1 } } } return -1 } 34. 在排序数组中查找元素的第一个和最后一个位置 Java实现：\nclass Solution { public int[] searchRange(int[] nums, int target) { int left = binaryLSearch(nums, target); int right = binaryRSearch(nums, target); if(left \u0026lt;= right \u0026amp;\u0026amp; right\u0026lt; nums.length \u0026amp;\u0026amp; nums[left] == target \u0026amp;\u0026amp; nums[right] == target){ return new int[]{left,right}; } return new int[]{-1,-1}; } public int binaryLSearch(int[] nums, int target){ int left = 0, right = nums.length - 1, res = nums.length; while(left \u0026lt;= right){ int mid = (left + right)/2; if(nums[mid] \u0026gt;= target){ right = mid - 1; res = mid; } else { left = mid + 1; } } return res; } public int binaryRSearch(int[] nums, int target){ int left = 0, right = nums.length - 1, res = nums.length; while(left \u0026lt;= right){ int mid = (left + right)/2; if(nums[mid] \u0026lt;= target){ left = mid + 1; res = mid; } else { right = mid - 1; } } return res; } } go实现：\nfunc searchRange(nums []int, target int) []int { n := len(nums) if n == 0 { return []int{-1, -1} } if n == 1{ if nums[0] == target { return []int{0, 0} } else { return []int{-1, -1} } } l, r, mid, res := 0, len(nums) - 1, 0, len(nums) left := findL(nums, target, l, r, mid, res) right := findR(nums, target, l, r, mid, res) if left \u0026lt;= right \u0026amp;\u0026amp; left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; len(nums) \u0026amp;\u0026amp; nums[left] == target \u0026amp;\u0026amp; nums[right] == target { return []int{left, right} } return []int{-1, -1} } func findL(nums []int, target, left, right, mid, res int) int { for left \u0026lt;= right { mid = (left + right) / 2 if nums[mid] \u0026gt;= target { right = mid - 1 res = mid } else { left = mid + 1 } } return res } func findR(nums []int, target, left, right, mid, res int) int { for left \u0026lt;= right { mid = (left + right) / 2 if nums[mid] \u0026lt;= target { left = mid + 1 res = mid } else { right = mid - 1 } } return res } 39. 组合总和 Java实现：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); int len = candidates.length; if(len == 0) return res; Arrays.sort(candidates); deal(res, candidates, target, 0, new ArrayList\u0026lt;Integer\u0026gt;()); return res; } void deal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int[] candidates, int target, int index, List\u0026lt;Integer\u0026gt; candidate){ if(index == candidates.length) return; if(target == 0){ res.add(new ArrayList\u0026lt;\u0026gt;(candidate)); return; } if(target - candidates[index] \u0026gt;= 0){ candidate.add(candidates[index]); deal(res, candidates, target - candidates[index], index, candidate); candidate.remove(candidate.size() - 1); } deal(res, candidates, target, index + 1, candidate); } } go实现：\nfunc combinationSum(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } res := [][]int{} sort.Ints(candidates) res = find(res, candidates, target, 0, []int{}) return res } func find(res [][]int, candidates []int, target, index int, now []int) [][]int { if index == len(candidates) { return res } if target == 0 { return append(res, now) } if target - candidates[index] \u0026gt;= 0 { new_now := make([]int, len(now), len(now)) copy(new_now, now) new_now = append(new_now, candidates[index]) res = find(res, candidates, target - candidates[index], index, new_now) } res = find(res, candidates, target, index + 1, now) return res } 42. 接雨水 Java实现：\nclass Solution { public int trap(int[] height) { int ans = 0; int left = 0, right = height.length - 1; int leftMax = 0, rightMax = 0; while (left \u0026lt; right) { leftMax = Math.max(leftMax, height[left]); rightMax = Math.max(rightMax, height[right]); if (height[left] \u0026lt; height[right]) { ans += leftMax - height[left]; ++left; } else { ans += rightMax - height[right]; --right; } } return ans; } } go实现：\nfunc trap(height []int) int { n := len(height) if n \u0026lt;= 2 { return 0 } left, right, res, leftMax, rightMax := 0, n - 1, 0, 0, 0 for left \u0026lt; right { if(height[left] \u0026lt; height[right]){ if leftMax \u0026lt; height[left] { leftMax = height[left] } res += leftMax - height[left] left++ } else { if rightMax \u0026lt; height[right] { rightMax = height[right] } res += rightMax - height[right] right-- } } return res } 46. 全排列 Java实现：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); List\u0026lt;Integer\u0026gt; output = new ArrayList\u0026lt;Integer\u0026gt;(); for (int num : nums) { output.add(num); } int n = nums.length; deal(n, output, res, 0); return res; } void deal(int n, List\u0026lt;Integer\u0026gt; output, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int index){ // 所有数都填完了 if (index == n) { res.add(new ArrayList\u0026lt;Integer\u0026gt;(output)); return; } for(int i = index; i \u0026lt; n; i++){ // 动态维护数组 swap(output, index, i); // 继续递归填下一个数 deal(n, output, res, index + 1); // 撤销操作 swap(output, index, i); } } void swap(List\u0026lt;Integer\u0026gt; output, int i, int j) { Integer tmp = output.get(i); output.set(i, output.get(j)); output.set(j, tmp); } } go实现：\nfunc permute(nums []int) [][]int { n := len(nums) size := 1 for i := 2 ; i \u0026lt;= n; i++{ size *= i } res := make([][]int, 0, size) res = deal(res, nums, 0, n) return res } func deal(res [][]int, nums []int, index, n int) [][]int { if index == n { res = append(res, nums) return res } for i := index; i \u0026lt; n; i++ { new_nums := make([]int, n) copy(new_nums, nums) new_nums[i], new_nums[index] = new_nums[index], new_nums[i] res = deal(res, new_nums, index + 1, n) } return res } 48. 旋转图像 Java实现：\nclass Solution { public void rotate(int[][] matrix) { int n = matrix.length; // 水平翻转 for(int i = 0; i \u0026lt; n/2; ++i){ for(int j = 0; j \u0026lt; n; ++j){ swap(matrix, i, j, n - i - 1, j); } } // 主对角线翻转 for(int i = 0; i \u0026lt; n; ++i){ for(int j = i; j \u0026lt; n; ++j){ swap(matrix, i, j, j, i); } } } void swap(int[][] matrix, int i, int j, int x, int y){ int tmp = matrix[i][j]; matrix[i][j] = matrix[x][y]; matrix[x][y] = tmp; } } go实现：\nfunc rotate(matrix [][]int) { n := len(matrix) for i := 0; i \u0026lt; n/2; i++ { for j := 0; j \u0026lt; n; j++{ matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j] } } for i := 0; i \u0026lt; n; i++ { for j := 0; j \u0026lt; i; j++ { matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] } } } 49. 字母异位词分组 Java实现：\nclass Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;(); for (String str : strs) { int[] counts = new int[26]; int length = str.length(); for (int i = 0; i \u0026lt; length; i++) { counts[str.charAt(i) - \u0026#39;a\u0026#39;]++; } // 将每个出现次数大于 0 的字母和出现次数按顺序拼接成字符串，作为哈希表的键 StringBuffer sb = new StringBuffer(); for (int i = 0; i \u0026lt; 26; i++) { if (counts[i] != 0) { sb.append((char) (\u0026#39;a\u0026#39; + i)); sb.append(counts[i]); } } String key = sb.toString(); List\u0026lt;String\u0026gt; list = map.getOrDefault(key, new ArrayList\u0026lt;String\u0026gt;()); list.add(str); map.put(key, list); } return new ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(map.values()); } } go实现：\nfunc groupAnagrams(strs []string) [][]string { keyMap := make(map[string][]string) res := [][]string{} for _, str := range strs { charr := [26]int{} for _, ch := range str { charr[ch - \u0026#39;a\u0026#39;]++ } var sb strings.Builder for index, ch := range charr { sb.WriteByte((byte)(index + \u0026#39;a\u0026#39;)) sb.WriteByte((byte)(ch + \u0026#39;0\u0026#39;)) } key := sb.String() list, flag := keyMap[key] if flag != false { list = append(list, str) keyMap[key] = list } else { list = []string{str} keyMap[key] = list } } for _, value := range keyMap { res = append(res, value) } return res } 53. 最大子数组和 Java实现：\nclass Solution { public int maxSubArray(int[] nums) { int n = nums.length; int pre = 0; int max = nums[0]; for(int i = 0; i \u0026lt; n;++i){ pre = Math.max(nums[i], pre + nums[i]); max = Math.max(max, pre); } return max; } } go实现：\nfunc maxSubArray(nums []int) int { n := len(nums) max := nums[0] pre := 0 for i := 0; i \u0026lt; n; i++{ if pre \u0026gt; 0 { pre += nums[i] } else { pre = nums[i] } if max \u0026lt; pre { max = pre } } return max } 55. 跳跃游戏(*) Java实现：\nclass Solution { public boolean canJump(int[] nums) { int len = nums.length; if (len \u0026lt; 1) return true; int max = 0; for (int i = 0; i \u0026lt; len ; i++) { if (i \u0026lt;= max) { max = Math.max(max, nums[i] + i); } } return max \u0026gt;= len - 1; } } go实现：\nfunc canJump(nums []int) bool { n := len(nums) if n \u0026lt;= 1 { return true } max := 0 for i, value := range nums { if i \u0026lt;= max { if max \u0026lt; value + i { max = value + i } } } return max \u0026gt;= n - 1 } 56. 合并区间(*) Java实现：\nclass Solution { public int[][] merge(int[][] intervals) { if (intervals.length == 0) { return new int[0][0]; } Arrays.sort(intervals, new Comparator\u0026lt;int[]\u0026gt;() { public int compare(int[] interval1, int[] interval2) { return interval1[0] - interval2[0]; } }); List\u0026lt;int[]\u0026gt; merged = new ArrayList\u0026lt;int[]\u0026gt;(); for (int i = 0; i \u0026lt; intervals.length; ++i) { int L = intervals[i][0], R = intervals[i][1]; if (merged.size() == 0 || merged.get(merged.size() - 1)[1] \u0026lt; L) { merged.add(new int[]{L, R}); } else { merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R); } } return merged.toArray(new int[merged.size()][]); } } go实现：\nfunc merge(intervals [][]int) [][]int { sort.Slice(intervals, func(i, j int) bool{ return intervals[i][0] \u0026lt;= intervals[j][0] }) res := [][]int{} for _, interval := range intervals { L, R := interval[0], interval[1] if len(res) == 0 || res[len(res) - 1][1] \u0026lt; L { res = append(res, interval) } else { if R \u0026gt; res[len(res) - 1][1] { res[len(res) - 1][1] = R } } } return res } 62. 不同路径 Java实现：\n// 从左上角到右下角的过程中，我们需要移动 m+n-2 次，其中有 m-1 次向下移动，n-1 次向右移动。因此路径的总数，就等于从 m+n-2 次移动中选择 m-1 次向下移动的方案数，即组合数：(C m+n−2 m−1) class Solution { public int uniquePaths(int m, int n) { long ans = 1; for(int i = m, j = 1; j \u0026lt; n; j++, i++){ ans = ans * i / j; } return (int)ans; } } go实现：\nfunc uniquePaths(m int, n int) int { ans := 1 for i, j := m,1; j \u0026lt; n; i, j = i+1, j+1 { ans = ans * i / j } return ans } 64. 最小路径和 Java实现：\nclass Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for(int i = 1; i \u0026lt; m; i++){ dp[i][0] = dp[i-1][0] + grid[i][0]; } for(int i = 1; i \u0026lt; n; i++){ dp[0][i] = dp[0][i-1] + grid[0][i]; } for(int i = 1; i \u0026lt; m; i++){ for(int j = 1; j \u0026lt; n; j++){ dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; } } return dp[m-1][n-1]; } } go实现：\nfunc minPathSum(grid [][]int) int { m,n := len(grid), len(grid[0]) dp := [200][200]int{} dp[0][0] = grid[0][0] for i := 1; i \u0026lt; m; i++ { dp[i][0] = dp[i - 1][0] + grid[i][0] } for i := 1; i \u0026lt; n; i++ { dp[0][i] = dp[0][i - 1] + grid[0][i] } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] } } return dp[m - 1][n - 1] } func min(a, b int) int { if a \u0026lt; b { return a } return b } 70. 爬楼梯 Java实现：\nclass Solution { public int climbStairs(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for(int i = 2; i \u0026lt;= n; i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } } go实现：\nfunc climbStairs(n int) int { dp := [46]int{} dp[0] = 1 dp[1] = 1 for i := 2; i \u0026lt;= n; i++ { dp[i] = dp[i - 1] + dp[i - 2] } return dp[n] } 72. 编辑距离(*) Java实现：\nclass Solution { public int minDistance(String word1, String word2) { int n = word1.length(); int m = word2.length(); // 有一个字符串为空串 if (n * m == 0) { return n + m; } // DP 数组 int[][] D = new int[n + 1][m + 1]; // 边界状态初始化 for (int i = 0; i \u0026lt; n + 1; i++) { D[i][0] = i; } for (int j = 0; j \u0026lt; m + 1; j++) { D[0][j] = j; } // 计算所有 DP 值 for (int i = 1; i \u0026lt; n + 1; i++) { for (int j = 1; j \u0026lt; m + 1; j++) { int left = D[i - 1][j] + 1; int down = D[i][j - 1] + 1; int left_down = D[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) { left_down += 1; } D[i][j] = Math.min(left, Math.min(down, left_down)); } } return D[n][m]; } } go实现：\nfunc minDistance(word1 string, word2 string) int { m,n := len(word1), len(word2) dp := [501][501]int{} for i := 1; i \u0026lt;= m ; i++ { dp[i][0] = i } for i := 1; i \u0026lt;= n ; i++ { dp[0][i] = i } for i := 1; i \u0026lt;= m; i++ { for j := 1; j \u0026lt;= n; j++ { left := dp[i - 1][j] + 1 down := dp[i][j - 1] + 1 left_down := dp[i - 1][j - 1] if word1[i - 1] != word2[j - 1] { left_down++ } dp[i][j] = min(left, min(down, left_down)) } } return dp[m][n] } func min(a, b int) int { if a \u0026lt; b { return a } return b } 75. 颜色分类 Java实现：\nclass Solution { public void sortColors(int[] nums) { int len = nums.length; int p0 = 0, p2 = len - 1; for(int i = 0; i \u0026lt; len; i++){ while(i \u0026lt; p2 \u0026amp;\u0026amp; nums[i] == 2){ nums[i] = nums[p2]; nums[p2] = 2; --p2; } if(nums[i] == 0){ nums[i] = nums[p0]; nums[p0] = 0; ++p0; } } } } go实现：\nfunc sortColors(nums []int) { n := len(nums) p0, p2 := 0, n - 1 for i, _ := range nums { for i \u0026lt; p2 \u0026amp;\u0026amp; nums[i] == 2 { nums[i], nums[p2] = nums[p2], 2 p2-- } if nums[i] == 0 { nums[i], nums[p0] = nums[p0], 0 p0++ } } } 76. 最小覆盖子串(*) Java实现：\nclass Solution { public String minWindow(String s, String t) { char[] chars = s.toCharArray(), chart = t.toCharArray(); int n = chars.length, m = chart.length; int[] hash = new int[128]; for (char ch : chart) hash[ch]--; String res = \u0026#34;\u0026#34;; for (int i = 0, j = 0, cnt = 0; i \u0026lt; n; i++) { hash[chars[i]]++; if (hash[chars[i]] \u0026lt;= 0) cnt++; while (cnt == m \u0026amp;\u0026amp; hash[chars[j]] \u0026gt; 0) hash[chars[j++]]--; if (cnt == m) if (res.equals(\u0026#34;\u0026#34;) || res.length() \u0026gt; i - j + 1) res = s.substring(j, i + 1); } return res; } } go实现：\nfunc minWindow(s string, t string) string { n := len(t) hash := [128]int{} for _, ch := range t { hash[ch]-- } res := \u0026#34;\u0026#34; j, count := 0, 0 for i, ch := range s { hash[ch]++ if hash[ch] \u0026lt;= 0 { count++ } for count == n \u0026amp;\u0026amp; hash[s[j]] \u0026gt; 0 { hash[s[j]]-- j++ } if count == n { if res == \u0026#34;\u0026#34; || len(res) \u0026gt; i - j + 1 { res = s[j:i+1] } } } return res } 78. 子集 Java实现：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { int len = nums.length; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); deal(res, new ArrayList\u0026lt;Integer\u0026gt;(), 0, nums); return res; } public void deal(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; ans, int index, int[] nums){ if(index == nums.length){ res.add(new ArrayList\u0026lt;Integer\u0026gt;(ans)); return; } ans.add(nums[index]); deal(res, ans, index+1, nums); ans.remove(ans.size() - 1); deal(res, ans, index+1, nums); } } go实现：\nfunc subsets(nums []int) [][]int { n := len(nums) res := [][]int{} res = deal(res, nums, []int{}, 0, n) return res } func deal(res [][]int, nums, now []int, index, n int) [][]int { if index == n { return append(res, now) } new_now := make([]int, len(now), len(now)) copy(new_now, now) new_now = append(new_now, nums[index]) res = deal(res, nums, new_now, index + 1, n) new_now = make([]int, len(now), len(now)) copy(new_now, now) res = deal(res, nums, new_now, index + 1, n) return res } 79. 单词搜索 Java实现：\nclass Solution { public boolean exist(char[][] board, String word) { boolean res = false; int m = board.length; int n = board[0].length; for(int i = 0; i \u0026lt; m; ++i){ for(int j = 0; j \u0026lt; n; ++j){ res |= deal(board, i, j, word, 0, new boolean[m][n]); if(res) return true; } } return res; } public boolean deal(char[][] board, int x, int y, String word, int index, boolean[][] flag){ if (board[x][y] != word.charAt(index)) { return false; } if(index == word.length() - 1) return true; flag[x][y] = true; boolean res = false; if(x\u0026gt;0 \u0026amp;\u0026amp; !flag[x-1][y]) res |= deal(board, x - 1, y, word, index + 1, flag); if(res) return true; if(y\u0026gt;0 \u0026amp;\u0026amp; !flag[x][y-1]) res |= deal(board, x, y - 1, word, index + 1, flag); if(res) return true; if(x\u0026lt;board.length-1 \u0026amp;\u0026amp; !flag[x+1][y]) res |= deal(board, x + 1, y, word, index + 1, flag); if(res) return true; if(y\u0026lt;board[0].length-1 \u0026amp;\u0026amp; !flag[x][y+1]) res |= deal(board, x, y + 1, word, index + 1, flag); flag[x][y] = false; return res; } } go实现：\nfunc exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) res := false for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { res = find(board, [6][6]bool{}, word, 0, i, j) if (res) { return true } } } return false } func find(board [][]byte,flag [6][6]bool, word string, index, x, y int) bool{ if board[x][y] != word[index] { return false } if index == len(word) - 1 { return true } flag[x][y] = true if x \u0026gt; 0 \u0026amp;\u0026amp; !flag[x - 1][y] { if find(board, flag, word, index + 1, x - 1, y) { return true } } if x \u0026lt; len(board) - 1 \u0026amp;\u0026amp; !flag[x + 1][y] { if find(board, flag, word, index + 1, x + 1, y) { return true } } if y \u0026gt; 0 \u0026amp;\u0026amp; !flag[x][y - 1] { if find(board, flag, word, index + 1, x, y - 1) { return true } } if y \u0026lt; len(board[0]) - 1 \u0026amp;\u0026amp; !flag[x][y + 1] { if find(board, flag, word, index + 1, x, y + 1) { return true } } return false } 84. 柱状图中最大的矩形(*) Java实现：\nclass Solution { public int largestRectangleArea(int[] heights) { int n = heights.length; if(n == 0)return 0; if(n == 1)return heights[0]; int max = 0; Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] newHeigths = new int[n+2]; for(int i=0;i\u0026lt;n;i++){ newHeigths[i+1]=heights[i]; } n += 2; heights=newHeigths; stack.addLast(0); for(int i=0;i\u0026lt;n;i++){ while (heights[stack.peekLast()] \u0026gt; heights[i]) { int height = heights[stack.removeLast()]; int width = i - stack.peekLast() - 1; max = Math.max(max, height * width); } stack.addLast(i); } return max; } } go实现：\nfunc largestRectangleArea(heights []int) int { n := len(heights) if n == 0 { return 0 } if n == 1 { return heights[0] } max := 0 heights = append(heights, heights[n - 1], 0) stack := new(Stack) for i := n ; i \u0026gt;= 1; i-- { heights[i] = heights[i - 1] } heights[0] = 0 stack.Push(0) n += 2 for i := 0; i \u0026lt; n; i++ { for heights[stack.Peek()] \u0026gt; heights[i] { height := heights[stack.Pop()] width := i - stack.Peek() - 1 if max \u0026lt; height * width { max = height * width } } stack.Push(i) } return max } type Stack struct { i int data [100002]int } func (s *Stack) Push(k int) { s.data[s.i] = k s.i++ } func (s *Stack) Pop() int { s.i-- return s.data[s.i] } func (s *Stack) Peek() int { return s.data[s.i - 1] } 85. 最大矩形(*) Java实现：\nclass Solution { public int maximalRectangle(char[][] matrix) { int m = matrix.length; if (m == 0) { return 0; } int n = matrix[0].length; int[][] left = new int[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1; } } } int ret = 0; for (int j = 0; j \u0026lt; n; j++) { // 对于每一列，使用基于柱状图的方法 int[] up = new int[m]; int[] down = new int[m]; Deque\u0026lt;Integer\u0026gt; stack = new LinkedList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; m; i++) { while (!stack.isEmpty() \u0026amp;\u0026amp; left[stack.peek()][j] \u0026gt;= left[i][j]) { stack.pop(); } up[i] = stack.isEmpty() ? -1 : stack.peek(); stack.push(i); } stack.clear(); for (int i = m - 1; i \u0026gt;= 0; i--) { while (!stack.isEmpty() \u0026amp;\u0026amp; left[stack.peek()][j] \u0026gt;= left[i][j]) { stack.pop(); } down[i] = stack.isEmpty() ? m : stack.peek(); stack.push(i); } for (int i = 0; i \u0026lt; m; i++) { int height = down[i] - up[i] - 1; int area = height * left[i][j]; ret = Math.max(ret, area); } } return ret; } } go实现：\nfunc maximalRectangle(matrix [][]byte) int { m := len(matrix) if m == 0 { return 0 } n := len(matrix[0]) left := [200][200]int{} for i := 0 ; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if matrix[i][j] == \u0026#39;1\u0026#39; { if j == 0 { left[i][j] = 1 } else { left[i][j] = left[i][j - 1] + 1 } } } } ret := 0 for j := 0; j \u0026lt; n; j++ { up := [200]int{} down := [200]int{} stack := new(Stack) for i := 0; i \u0026lt; m; i++ { for !stack.IsEmpty() \u0026amp;\u0026amp; left[stack.Peek()][j] \u0026gt;= left[i][j] { stack.Pop() } if stack.IsEmpty() { up[i] = -1 } else { up[i] = stack.Peek() } stack.Push(i) } stack.Clear() for i := m - 1; i \u0026gt;= 0; i-- { for !stack.IsEmpty() \u0026amp;\u0026amp; left[stack.Peek()][j] \u0026gt;= left[i][j] { stack.Pop() } if stack.IsEmpty() { down[i] = m } else { down[i] = stack.Peek() } stack.Push(i) } for i := 0; i \u0026lt; m; i++ { height := down[i] - up[i] - 1 area := height * left[i][j] ret = max(ret, area) } } return ret } type Stack struct { i int data [200]int } func (s *Stack) Push(k int) { s.data[s.i] = k s.i++ } func (s *Stack) Pop() int { s.i-- return s.data[s.i] } func (s *Stack) Peek() int { return s.data[s.i - 1] } func (s *Stack) IsEmpty() bool { if s.i == 0 { return true } return false } func (s *Stack) Clear() { s.i = 0 } func max(a, b int) int { if a \u0026gt; b { return a } return b } 94. 二叉树的中序遍历 Java实现：\nclass Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;Integer\u0026gt;(); inorder(root, res); return res; } public void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; res){ if(root != null){ if(root.left != null) inorder(root.left, res); res.add(root.val); if(root.right != null) inorder(root.right, res); } } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { res := []int{} res = inorder(res, root) return res } func inorder(res []int, root *TreeNode) []int { if root != nil { if root.Left != nil { res = inorder(res, root.Left) } res = append(res, root.Val) if root.Right != nil { res = inorder(res, root.Right) } } return res } 96. 不同的二叉搜索树 Java实现：\n//方法一：左节点个数j-1，右节点个数i-j, j-1(左)+1(根)+i-j(右)=i class Solution { public int numTrees(int n) { int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i = 2; i \u0026lt; n + 1; i++) for(int j = 1; j \u0026lt; i + 1; j++) dp[i] += dp[j-1] * dp[i-j]; return dp[n]; } } //事实上我们在方法一中推导出的 G(n)G(n)函数的值在数学上被称为卡塔兰数 class Solution { public int numTrees(int n) { // 提示：我们在这里需要用 long 类型防止计算过程中的溢出 long C = 1; for (int i = 0; i \u0026lt; n; ++i) { C = C * 2 * (2 * i + 1) / (i + 2); } return (int) C; } } go实现：\nfunc numTrees(n int) int { //左边 j，右边 i - j - 1 dp := [20]int{} dp[0] = 1 dp[1] = 1 for i := 2; i \u0026lt;= n; i++ { for j := 0; j \u0026lt; i; j++ { dp[i] += dp[j] * dp[i - j - 1] } } return dp[n] } //卡塔兰数 func numTrees(n int) int { res := 1 for i := 0; i \u0026lt; n; i++ { res = 2 * res * (2 * i + 1) / (i + 2) } return res } 98. 验证二叉搜索树 Java实现：\nclass Solution { long pre = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } // 访问左子树 if (!isValidBST(root.left)) { return false; } // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。 if (root.val \u0026lt;= pre) { return false; } pre = root.val; // 访问右子树 return isValidBST(root.right); } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isValidBST(root *TreeNode) bool { res, _ := isValid(root, -(1 \u0026lt;\u0026lt; 31) - 1) return res } func isValid(root *TreeNode, preNum int) (res bool, pre int) { res, pre = false, preNum if root == nil { return true , pre } res, pre = isValid(root.Left, pre) if !res { return false , pre } if root.Val \u0026lt;= pre { return false , pre } pre = root.Val res, pre = isValid(root.Right, pre) return res, pre } 101. 对称二叉树 Java实现：\nclass Solution { public boolean isSymmetric(TreeNode root) { if(root == null) return true; return isSym(root.left, root.right); } public boolean isSym(TreeNode left, TreeNode right){ if(left != null \u0026amp;\u0026amp; right != null \u0026amp;\u0026amp; left.val == right.val){ return isSym(left.left, right.right) \u0026amp;\u0026amp; isSym(left.right, right.left); } else if(left == null \u0026amp;\u0026amp; right == null){ return true; } else { return false; } } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSymmetric(root *TreeNode) bool { if root == nil { return true } return isSym(root.Left, root.Right) } func isSym(left *TreeNode, right *TreeNode) bool { if left == nil \u0026amp;\u0026amp; right == nil { return true } if left == nil || right == nil { return false } else { if left.Val != right.Val { return false } return isSym(left.Left, right.Right) \u0026amp;\u0026amp; isSym(left.Right, right.Left) } } 102. 二叉树的层序遍历 Java实现：\nclass Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;TreeNode\u0026gt;(); if(root != null) queue.offer(root); level(res, queue); return res; } public void level(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, Queue\u0026lt;TreeNode\u0026gt; queue){ if(queue.isEmpty()) return; Queue\u0026lt;TreeNode\u0026gt; newQueue = new LinkedList\u0026lt;TreeNode\u0026gt;(); List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); while(!queue.isEmpty()){ TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) newQueue.offer(node.left); if(node.right != null) newQueue.offer(node.right); } res.add(list); level(res, newQueue); } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { queue := []*TreeNode{root} res := [][]int{} if root == nil { return res } return levelFind(res, queue) } func levelFind(res [][]int, queue []*TreeNode) [][]int { if len(queue) == 0 { return res } new_queue := []*TreeNode{} level := []int{} for _, node := range queue { level = append(level, node.Val) if node.Left != nil { new_queue = append(new_queue, node.Left) } if node.Right != nil { new_queue = append(new_queue, node.Right) } } res = append(res, level) res = levelFind(res, new_queue) return res } 104. 二叉树的最大深度 Java实现：\nclass Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(a, b int) int { if a \u0026gt; b { return a } return b } 105. 从前序与中序遍历序列构造二叉树(*) Java实现：\nclass Solution { private Map\u0026lt;Integer, Integer\u0026gt; indexMap; public TreeNode buildTree(int[] preorder, int[] inorder) { int n = preorder.length; // 构造哈希映射，帮助我们快速定位根节点 indexMap = new HashMap\u0026lt;Integer, Integer\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { indexMap.put(inorder[i], i); } return build(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1); } public TreeNode build(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) { if (preorder_left \u0026gt; preorder_right) { return null; } // 前序遍历中的第一个节点就是根节点 int preorder_root = preorder_left; // 在中序遍历中定位根节点 int inorder_root = indexMap.get(preorder[preorder_root]); // 先把根节点建立出来 TreeNode root = new TreeNode(preorder[preorder_root]); // 得到左子树中的节点数目 int size_left_subtree = inorder_root - inorder_left; // 递归地构造左子树，并连接到根节点 // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root.left = build(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1); // 递归地构造右子树，并连接到根节点 // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素 root.right = build(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right); return root; } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var indexMap = make(map[int]int) func buildTree(preorder []int, inorder []int) *TreeNode { n := len(preorder) for i, val := range inorder { indexMap[val] = i } return build(preorder, inorder, 0, n - 1, 0, n - 1) } func build(preorder []int, inorder []int, pre_left, pre_right, in_left, in_right int) *TreeNode { if pre_left \u0026gt; pre_right { return nil } pre_root := pre_left in_root := indexMap[preorder[pre_root]] left_size := in_root - in_left root := new(TreeNode) root.Val = preorder[pre_root] root.Left = build(preorder, inorder, pre_left + 1, pre_left + left_size, in_left, in_root - 1) root.Right = build(preorder, inorder, pre_left + left_size + 1, pre_right, in_root + 1, in_right) return root } 114. 二叉树展开为链表(*) Java实现：\nclass Solution { public void flatten(TreeNode root) { TreeNode curr = root; while (curr != null) { if (curr.left != null) { TreeNode next = curr.left; TreeNode predecessor = next; while (predecessor.right != null) { predecessor = predecessor.right; } predecessor.right = curr.right; curr.left = null; curr.right = next; } curr = curr.right; } } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func flatten(root *TreeNode) { cur := root for cur != nil { if cur.Left != nil { next := cur.Left pre := next for pre.Right != nil { pre = pre.Right } pre.Right = cur.Right cur.Left = nil cur.Right = next } cur = cur.Right } } 121. 买卖股票的最佳时机 Java实现：\nclass Solution { public int maxProfit(int[] prices) { int len = prices.length; if(len \u0026lt;= 1) return 0; int buy = prices[0]; int max = 0; for(int i = 1; i \u0026lt; len; ++i){ max = Math.max(max, prices[i] - buy); buy = Math.min(buy, prices[i]); } return max; } } go实现：\nfunc maxProfit(prices []int) int { if len(prices) \u0026lt;= 1 { return 0 } maxres := 0 buy := prices[0] for _, val := range prices { if val \u0026gt; buy { maxres = max(maxres, val - buy) } if val \u0026lt; buy { buy = val } } return maxres } func max(a, b int) int { if a \u0026gt; b { return a } return b } 124. 二叉树中的最大路径和(*) Java实现：\nclass Solution { int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { genMax(root); return max; } public int genMax(TreeNode root){ if(root == null)return 0; // 递归计算左右子节点的最大贡献值 // 只有在最大贡献值大于 0 时，才会选取对应子节点 int left = Math.max(genMax(root.left), 0); int right = Math.max(genMax(root.right), 0); // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值 int price = root.val + left + right; // 更新max max = Math.max(max, price); // 返回节点的最大贡献值 return root.val + Math.max(left, right); } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxPathSum(root *TreeNode) int { _, maxres := deal(root, -(1 \u0026lt;\u0026lt; 31)) return maxres } func deal(root *TreeNode, maxres int) (int, int) { if root == nil { return 0, maxres } left, maxres := deal(root.Left, maxres) left = max(left, 0) right, maxres := deal(root.Right, maxres) right = max(right, 0) maxres = max(left + right + root.Val, maxres) return max(left, right) + root.Val , maxres } func max(a, b int) int { if a \u0026gt; b { return a } return b } 128. 最长连续序列(*) Java实现：\nclass Solution { public int longestConsecutive(int[] nums) { Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;Integer\u0026gt;(); for(int num : nums){ set.add(num); } int max = 0, cur = 0, count = 0; for(int num : set){ if(!set.contains(num - 1)){ cur = num; count = 1; while(set.contains(cur + 1)){ ++cur; ++count; } max = Math.max(count, max); } } return max; } } go实现：\nfunc longestConsecutive(nums []int) int { hash := make(map[int]int) for i, val := range nums { hash[val] = i } max, cur, count := 0, 0, 0 for num, _ := range hash { _, ok := hash[num - 1] if !ok { cur = num count = 1 _, flag := hash[cur + 1] for flag { cur++ count++ _, flag = hash[cur + 1] } if count \u0026gt; max { max = count } } } return max } 136. 只出现一次的数字 Java实现：\nclass Solution { public int singleNumber(int[] nums) { int res = 0; for(int i = 0; i \u0026lt; nums.length; ++i){ res ^= nums[i]; } return res; } } go实现：\nfunc singleNumber(nums []int) int { res := 0 for _, val := range nums { res ^= val } return res } 139. 单词拆分(*) Java实现：\nclass Solution { public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { boolean[] dp = new boolean[s.length()+1]; dp[0] = true; //先遍历背包 for(int i=1;i\u0026lt;=s.length();i++) { //再遍历物品 //i和j也可以作为校验字符串是否在字典中存在的双指针 //但是规定j小于i for(int j=0;j\u0026lt;i;j++) { //如果s[0...j]之间的字符串能够拼凑出 \u0026amp;\u0026amp; s[j...i]之间的字符串也在字典中存在 if(dp[j] \u0026amp;\u0026amp; wordDict.contains(s.substring(j,i))) { //那么说明s[0...j] + s[j...i] 拼凑出来字符串可以用字典拼出 dp[i] = true; } } } return dp[s.length()]; } } go实现：\nfunc wordBreak(s string, wordDict []string) bool { dp := [301]bool{} dp[0] = true hash := make(map[string]int) for _, val := range wordDict { hash[val] = 1 } n := len(s) for i := 1; i \u0026lt;= n; i++ { for j := 0; j \u0026lt; i; j++ { _, ok := hash[s[j:i]] if dp[j] \u0026amp;\u0026amp; ok { dp[i] = true } } } return dp[n] } 141. 环形链表 Java实现：\npublic class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; ListNode fast = head.next; ListNode slow = head; while(fast != null \u0026amp;\u0026amp; fast.next != null){ if(fast == slow) return true; fast = fast.next.next; slow = slow.next; } return false; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { if head == nil { return false } fast := head.Next slow := head for fast != nil \u0026amp;\u0026amp; fast.Next != nil{ if fast == slow { return true } fast = fast.Next.Next slow = slow.Next } return false } 142. 环形链表 II Java实现：\npublic class Solution { public ListNode detectCycle(ListNode head) { if(head == null || head.next == null) return null; ListNode fast = head; ListNode slow = head; while(fast != null){ if(fast != null \u0026amp;\u0026amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow){ fast = head; while(fast != slow){ fast = fast.next; slow = slow.next; } return fast; } } else { return null; } } return null; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { fast := head slow := head for fast != nil { if fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next if (fast == slow) { fast = head for fast != slow { fast = fast.Next slow = slow.Next } return fast } } else { return nil } } return nil } 146. LRU 缓存(*) Java实现：\nclass LRUCache { private LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache; private int capacity = 0; public LRUCache(int capacity) { this.capacity = capacity; this.cache = new LinkedHashMap\u0026lt;\u0026gt;(); } public int get(int key) { if(cache.containsKey(key)){ int value = cache.get(key); cache.remove(key); cache.put(key, value); return value; } else { return -1; } } public void put(int key, int value) { if(cache.containsKey(key)){ cache.remove(key); cache.put(key, value); } else { if(cache.size() == capacity){ cache.remove(cache.keySet().iterator().next()); } cache.put(key, value); } } } go实现：\ntype LRUCache struct { size int //双向链表的长度 capacity int //双向链表容量 chche map[int]*DLinkedNode //查询key对应的节点 head *DLinkedNode //伪头节点 tail *DLinkedNode //伪尾节点 } type DLinkedNode struct { //节点保存的信息 key int //key val int //value prev *DLinkedNode //节点的上一个节点 next *DLinkedNode //节点的下一个节点 } func initDLinkedNode(key, value int) *DLinkedNode { //初始化一个新节点 return \u0026amp;DLinkedNode{ key: key, val: value, } } func Constructor(capacity int) LRUCache { l := LRUCache{ size: 0, capacity: capacity, chche: map[int]*DLinkedNode{}, head: initDLinkedNode(0, 0), tail: initDLinkedNode(0, 0), } l.head.next = l.tail l.tail.prev = l.head return l } func (LRU *LRUCache) Get(key int) int { if k, ok := LRU.chche[key]; ok { LRU.moveToHead(k) return k.val } return -1 } func (LRU *LRUCache) Put(key int, value int) { if k, ok := LRU.chche[key]; ok { LRU.moveToHead(k) k.val = value } else { newNode := initDLinkedNode(key, value) LRU.chche[key] = newNode LRU.size++ LRU.addToHead(newNode) } if LRU.size \u0026gt; LRU.capacity { LRU.removeTail() LRU.size-- } } func (LRU *LRUCache) addToHead(node *DLinkedNode) { node.next = LRU.head.next node.prev = LRU.head LRU.head.next.prev = node LRU.head.next = node } func (LRU *LRUCache) removeNode(node *DLinkedNode) { node.next.prev = node.prev node.prev.next = node.next } func (LRU *LRUCache) moveToHead(node *DLinkedNode) { LRU.removeNode(node) LRU.addToHead(node) } func (LRU *LRUCache) removeTail() { delete(LRU.chche, LRU.tail.prev.key) LRU.tail.prev = LRU.tail.prev.prev LRU.tail.prev.next = LRU.tail } 148. 排序链表(*) Java实现：\nclass Solution { public ListNode sortList(ListNode head) { if(head == null) return head; int length = 0; ListNode node = head; while (node != null) { length++; node = node.next; } ListNode dummyHead = new ListNode(0, head); for (int subLength = 1; subLength \u0026lt; length; subLength \u0026lt;\u0026lt;= 1) { ListNode prev = dummyHead, curr = dummyHead.next; while (curr != null) { ListNode head1 = curr; for (int i = 1; i \u0026lt; subLength \u0026amp;\u0026amp; curr.next != null; i++) { curr = curr.next; } ListNode head2 = curr.next; curr.next = null; curr = head2; for (int i = 1; i \u0026lt; subLength \u0026amp;\u0026amp; curr != null \u0026amp;\u0026amp; curr.next != null; i++) { curr = curr.next; } ListNode next = null; if (curr != null) { next = curr.next; curr.next = null; } ListNode merged = merge(head1, head2); prev.next = merged; while (prev.next != null) { prev = prev.next; } curr = next; } } return dummyHead.next; } public ListNode merge(ListNode head1, ListNode head2) { ListNode dummyHead = new ListNode(0); ListNode temp = dummyHead, temp1 = head1, temp2 = head2; while (temp1 != null \u0026amp;\u0026amp; temp2 != null) { if (temp1.val \u0026lt;= temp2.val) { temp.next = temp1; temp1 = temp1.next; } else { temp.next = temp2; temp2 = temp2.next; } temp = temp.next; } if (temp1 != null) { temp.next = temp1; } else if (temp2 != null) { temp.next = temp2; } return dummyHead.next; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { if head == nil { return nil } length := 0 node := head for node != nil { node = node.Next length++ } dummyHead := \u0026amp;ListNode{0, head} for index := 1; index \u0026lt; length; index \u0026lt;\u0026lt;= 1 { pre, cur := dummyHead, dummyHead.Next for cur != nil { head1 := cur for i := 1; i \u0026lt; index \u0026amp;\u0026amp; cur.Next != nil; i++ { cur = cur.Next } head2 := cur.Next cur.Next = nil cur = head2 for i := 1; i \u0026lt; index \u0026amp;\u0026amp; cur != nil \u0026amp;\u0026amp; cur.Next != nil; i++ { cur = cur.Next } var next *ListNode if cur != nil { next = cur.Next cur.Next = nil } merged := merge(head1, head2) pre.Next = merged for pre.Next != nil { pre = pre.Next } cur = next } } return dummyHead.Next } func merge(list1, list2 *ListNode) *ListNode { pre := new(ListNode) cur := pre if list1 == nil { return list2 } if list2 == nil { return list1 } for list1 != nil \u0026amp;\u0026amp; list2 != nil { if list1.Val \u0026lt;= list2.Val { cur.Next = list1 list1 = list1.Next } else { cur.Next = list2 list2 = list2.Next } cur = cur.Next } if list1 == nil { cur.Next = list2 } if list2 == nil { cur.Next = list1 } return pre.Next } 152. 乘积最大子数组(*) Java实现：\nclass Solution { public int maxProduct(int[] nums) { int length = nums.length; if(length == 0) return 0; if(length == 1) return nums[0]; int max = nums[0]; int min = nums[0]; int res = max; int tmp = 0; for(int i=1; i\u0026lt;length; ++i){ if (nums[i] \u0026gt; 0){ max = max \u0026lt;= 0 ? nums[i] : max * nums[i]; min = min \u0026gt;= 0 ? nums[i] : min * nums[i]; res = Math.max(res, max); } else if(nums[i] \u0026lt; 0){ tmp = max; max = min \u0026gt;= 0 ? nums[i] : min * nums[i]; min = tmp \u0026lt;= 0 ? nums[i] : tmp * nums[i]; res = Math.max(res, max); } else { max = 0; min = 0; res = Math.max(res, 0); } } return res; } } go实现：\nfunc maxProduct(nums []int) int { n := len(nums) if n == 1 { return nums[0] } maxres, minres, res, tmp := nums[0], nums[0], nums[0], 0 for i := 1; i \u0026lt; n; i++ { if nums[i] == 0 { maxres = 0 minres = 0 res = max(res, 0) } else if nums[i] \u0026lt; 0 { tmp = maxres maxres = If(minres \u0026gt;= 0, nums[i], minres * nums[i]) minres = If(tmp \u0026lt;= 0, nums[i], tmp * nums[i]) res = max(maxres, res) } else { maxres = If(maxres \u0026lt;= 0, nums[i], maxres * nums[i]) minres = If(minres \u0026gt;= 0, nums[i], minres * nums[i]) res = max(maxres, res) } } return res } func max(a,b int) int { if a \u0026gt; b { return a } return b } func min(a,b int) int { if a \u0026lt; b { return a } return b } func If(flag bool, a, b int) int { if flag { return a } return b } 155. 最小栈 Java实现：\nclass MinStack { Deque\u0026lt;Integer\u0026gt; xStack; Deque\u0026lt;Integer\u0026gt; minStack; public MinStack() { xStack = new LinkedList\u0026lt;Integer\u0026gt;(); minStack = new LinkedList\u0026lt;Integer\u0026gt;(); minStack.push(Integer.MAX_VALUE); } public void push(int x) { xStack.push(x); minStack.push(Math.min(minStack.peek(), x)); } public void pop() { xStack.pop(); minStack.pop(); } public int top() { return xStack.peek(); } public int getMin() { return minStack.peek(); } } go实现：\ntype MinStack struct { stack *Stack minStack *Stack } type Stack struct { i int data [30000]int } func (s *Stack) Push(k int) { s.data[s.i] = k s.i++ } func (s *Stack) Pop() int { s.i-- return s.data[s.i] } func (s *Stack) Peek() int { if s.i == 0 { return (1 \u0026lt;\u0026lt; 31) } return s.data[s.i - 1] } func Constructor() MinStack { mstack := MinStack{ \u0026amp;Stack{}, \u0026amp;Stack{}, } return mstack } func (this *MinStack) Push(val int) { this.stack.Push(val) this.minStack.Push(min(val, this.minStack.Peek())) } func (this *MinStack) Pop() { this.stack.Pop() this.minStack.Pop() } func (this *MinStack) Top() int { return this.stack.Peek() } func (this *MinStack) GetMin() int { return this.minStack.Peek() } func min(a,b int) int { if a \u0026lt; b { return a } return b } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */ 160. 相交链表 Java实现：\npublic class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode l1 = headA; ListNode l2 = headB; while(l1 != l2){ if(l1 == null) l1 = headB; if(l2 == null) l2 = headA; if(l1 == l2) break; l1 = l1.next; l2 = l2.next; } return l1; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } l1, l2 := headA, headB for l1 != l2 { if l1 == nil { l1 = headB } if l2 == nil { l2 = headA } if l1 == l2 { return l1 } l1 = l1.Next l2 = l2.Next } return l1 } 169. 多数元素(*) Java实现：\nclass Solution { public int majorityElement(int[] nums) { int count = 1; int maj = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { if (maj == nums[i])//如果相同则累加 count++; else {//如果不同，则相抵 count--; if (count == 0) {//如果抵消完了，移动到下一位 maj = nums[i + 1]; } } } return maj; } } go实现：\nfunc majorityElement(nums []int) int { count, maj, n := 1, nums[0], len(nums) for i := 1; i \u0026lt; n; i++ { if maj == nums[i] { count++ } else { if count == 0 { maj = nums[i] count = 1 } else { count-- } } } return maj } 198. 打家劫舍 Java实现：\nclass Solution { public int rob(int[] nums) { int max=0; int len = nums.length; if(len \u0026lt; 1)return 0; if(len == 1)return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; for(int i = 1; i\u0026lt; nums.length; i++){ dp[i] = Math.max(dp[i-1], nums[i] + (i \u0026gt;= 2 ? dp[i-2] : 0)); max = Math.max(max, dp[i]); } return max; } } go实现：\nfunc rob(nums []int) int { n := len(nums) if n == 1 { return nums[0] } if n == 2 { return max(nums[0], nums[1]) } dp := [100]int{} dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i := 2; i \u0026lt; n; i++ { dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]) } return dp[n - 1] } func max(a,b int) int { if a \u0026gt; b { return a } return b } 200. 岛屿数量 Java实现：\nclass Solution { int sum = 0; public int numIslands(char[][] grid) { int m = grid.length; int n = grid[0].length; if(m \u0026lt; 1 || n \u0026lt; 1)return 0; for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ if(grid[i][j] == \u0026#39;1\u0026#39;){ dfs(grid,i,j); sum += 1; } } } return sum; } public void dfs(char[][] grid, int x, int y){ if(x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= grid.length || y \u0026gt;= grid[0].length || grid[x][y] != \u0026#39;1\u0026#39;){ return; } else { grid[x][y] = \u0026#39;x\u0026#39;; dfs(grid, x-1, y); dfs(grid, x+1, y); dfs(grid, x, y-1); dfs(grid, x, y+1); } } } go实现：\nfunc numIslands(grid [][]byte) int { m, n := len(grid), len(grid[0]) count := 0 for i := 0; i \u0026lt; m; i++ { for j := 0; j \u0026lt; n; j++ { if grid[i][j] == \u0026#39;1\u0026#39; { dfs(grid, i, j) count++ } } } return count } func dfs(grid [][]byte, x, y int) { if x \u0026lt; 0 || x \u0026gt;= len(grid) || y \u0026lt; 0 || y \u0026gt;= len(grid[0]) || grid[x][y] != \u0026#39;1\u0026#39; { return } else { grid[x][y] = \u0026#39;0\u0026#39; dfs(grid, x - 1, y) dfs(grid, x + 1, y) dfs(grid, x , y - 1) dfs(grid, x , y + 1) } } 206. 反转链表 Java实现：\nclass Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while(cur!=null) { ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { var pre *ListNode next := head for head != nil { next = head.Next head.Next = pre pre = head head = next } return pre } 207. 课程表(*) Java实现：\nclass Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; edges; int[] visited; boolean valid = true; public boolean canFinish(int numCourses, int[][] prerequisites) { edges = new ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; ++i) { edges.add(new ArrayList\u0026lt;Integer\u0026gt;()); } visited = new int[numCourses]; for (int[] info : prerequisites) { edges.get(info[1]).add(info[0]); } for (int i = 0; i \u0026lt; numCourses \u0026amp;\u0026amp; valid; ++i) { if (visited[i] == 0) { dfs(i); } } return valid; } public void dfs(int u) { visited[u] = 1; for (int v: edges.get(u)) { if (visited[v] == 0) { dfs(v); if (!valid) { return; } } else if (visited[v] == 1) { valid = false; return; } } visited[u] = 2; } } go实现：\nvar edges [][]int; var visited []int; var valid bool; func canFinish(numCourses int, prerequisites [][]int) bool { edges = make([][]int, numCourses, numCourses) visited = make([]int, numCourses, numCourses) valid = true for _, val := range prerequisites { edges[val[1]] = append(edges[val[1]], val[0]) } for i := 0 ; i \u0026lt; numCourses \u0026amp;\u0026amp; valid; i++ { if(visited[i] == 0) { dfs(i) } } return valid } func dfs(u int) { visited[u] = 1 for _, v := range edges[u] { if visited[v] == 0 { dfs(v) if !valid { return } } else if visited[v] == 1 { valid = false return } } visited[u] = 2 } 208. 实现 Trie (前缀树)(*) Java实现：\nclass Trie { private Trie[] children; private boolean isEnd; public Trie() { children = new Trie[26]; isEnd = false; } public void insert(String word) { Trie node = this; for (int i = 0; i \u0026lt; word.length(); i++) { char ch = word.charAt(i); int index = ch - \u0026#39;a\u0026#39;; if (node.children[index] == null) { node.children[index] = new Trie(); } node = node.children[index]; } node.isEnd = true; } public boolean search(String word) { Trie node = searchPrefix(word); return node != null \u0026amp;\u0026amp; node.isEnd; } public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; } private Trie searchPrefix(String prefix) { Trie node = this; for (int i = 0; i \u0026lt; prefix.length(); i++) { char ch = prefix.charAt(i); int index = ch - \u0026#39;a\u0026#39;; if (node.children[index] == null) { return null; } node = node.children[index]; } return node; } } go实现：\ntype Trie struct { children []*Trie isEnd bool } func Constructor() Trie { var trie Trie = Trie{ make([]*Trie, 26), false, } return trie } func (this *Trie) Insert(word string) { node := this for _, ch := range word { index := ch - \u0026#39;a\u0026#39; if node.children[index] == nil { nextnode := Constructor() node.children[index] = \u0026amp;nextnode } node = node.children[index] } node.isEnd = true } func (this *Trie) Search(word string) bool { node := this.searchPrefix(word) return node != nil \u0026amp;\u0026amp; node.isEnd } func (this *Trie) StartsWith(prefix string) bool { return this.searchPrefix(prefix) != nil } func (this *Trie) searchPrefix(prefix string) *Trie { node := this for _, ch := range prefix { index := ch - \u0026#39;a\u0026#39; if node.children[index] == nil { return nil } node = node.children[index] } return node } /** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 215. 数组中的第K个最大元素(*) Java实现：\nclass Solution { public int findKthLargest(int[] nums, int k) { int heapSize = nums.length; buildMaxHeap(nums, heapSize); int temp = 0; for (int i = heapSize - 1; i \u0026gt;= nums.length - k + 1; i--) { temp = nums[0]; nums[0] = nums[i]; nums[i] = temp; heapSize--; maxHeapify(nums, 0, heapSize); } return nums[0]; } void buildMaxHeap(int[] a, int heapSize) { for (int i = heapSize/2; i \u0026gt;= 0; i--) { maxHeapify(a, i, heapSize); } } void maxHeapify(int[] a, int i, int heapSize) { int l = i * 2 + 1; int r = i * 2 + 2; int largest = i; if(l \u0026lt; heapSize \u0026amp;\u0026amp; a[l] \u0026gt; a[largest]) { largest = l; } if(r \u0026lt; heapSize \u0026amp;\u0026amp; a[r] \u0026gt; a[largest]) { largest = r; } if(largest != i) { int temp = a[i]; a[i] = a[largest]; a[largest] = temp; maxHeapify(a, largest, heapSize); } } } go实现：\nfunc findKthLargest(nums []int, k int) int { heapSize := len(nums) buildMaxHeap(nums, heapSize) for i := len(nums) - 1; i \u0026gt;= len(nums) - k + 1; i-- { nums[0], nums[i] = nums[i], nums[0] heapSize-- maxHeapify(nums, 0, heapSize) } return nums[0] } func buildMaxHeap(a []int, heapSize int) { for i := (heapSize - 1)/2; i \u0026gt;= 0; i-- { maxHeapify(a, i, heapSize) } } func maxHeapify(a []int, i, heapSize int) { l, r, largest := i * 2 + 1, i * 2 + 2, i if l \u0026lt; heapSize \u0026amp;\u0026amp; a[l] \u0026gt; a[largest] { largest = l } if r \u0026lt; heapSize \u0026amp;\u0026amp; a[r] \u0026gt; a[largest] { largest = r } if largest != i { a[i], a[largest] = a[largest], a[i] maxHeapify(a, largest, heapSize) } } 221. 最大正方形 Java实现：\nclass Solution { public int maximalSquare(char[][] matrix) { int maxSide = 0; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { return maxSide; } int rows = matrix.length, columns = matrix[0].length; int[][] dp = new int[rows][columns]; for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; columns; j++) { if (matrix[i][j] == \u0026#39;1\u0026#39;) { if (i == 0 || j == 0) { dp[i][j] = 1; } else { dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1; } maxSide = Math.max(maxSide, dp[i][j]); } } } int maxSquare = maxSide * maxSide; return maxSquare; } } go实现：\nfunc maximalSquare(matrix [][]byte) int { maxs := 0 dp := [301][301]int{} m, n := len(matrix), len(matrix[0]) for i := 0; i \u0026lt; m; i++ { if matrix[i][0] == \u0026#39;1\u0026#39; { dp[i][0] = 1 maxs = 1 } } for i := 0; i \u0026lt; n; i++ { if matrix[0][i] == \u0026#39;1\u0026#39; { dp[0][i] = 1 maxs = 1 } } for i := 1; i \u0026lt; m; i++ { for j := 1; j \u0026lt; n; j++ { if matrix[i][j] == \u0026#39;1\u0026#39; { dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1 } maxs = max(maxs, dp[i][j]) } } return maxs * maxs } func max(a,b int) int { if a \u0026gt; b { return a } return b } func min(a,b int) int { if a \u0026lt; b { return a } return b } 226. 翻转二叉树 Java实现\nclass Solution { public TreeNode invertTree(TreeNode root) { if(root == null){ return null; } TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root; } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.Right = root.Right, root.Left invertTree(root.Left) invertTree(root.Right) return root } 234. 回文链表 Java实现：\nclass Solution { public boolean isPalindrome(ListNode head) { if(head == null || head.next == null) { return true; } ListNode slow = head, fast = head; ListNode pre = null, next = head; while(fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; next = slow.next; slow.next = pre; pre = slow; slow = next; } if(fast != null) { slow = slow.next; } while(pre != null \u0026amp;\u0026amp; slow != null) { if(pre.val != slow.val) { return false; } pre = pre.next; slow = slow.next; } return true; } } go实现：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { if head == nil || head.Next == nil { return true } fast, slow := head, head var pre, next *ListNode for fast != nil \u0026amp;\u0026amp; fast.Next != nil { fast = fast.Next.Next next = slow.Next slow.Next = pre pre = slow slow = next } if fast != nil { slow = slow.Next } for pre != nil \u0026amp;\u0026amp; slow != nil { if pre.Val != slow.Val { return false } pre = pre.Next slow = slow.Next } return true } 236. 二叉树的最近公共祖先(*) Java实现：\nclass Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; if(root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null) return right; if(right == null) return left; if(left != null \u0026amp;\u0026amp; right != null) // p和q在两侧 return root; return null; // 必须有返回值 } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } left, right := lowestCommonAncestor(root.Left, p, q), lowestCommonAncestor(root.Right, p, q) if left == nil { return right } if right == nil { return left } if left != nil \u0026amp;\u0026amp; right != nil { return root } return nil } 238. 除自身以外数组的乘积 Java实现：\nclass Solution { public int[] productExceptSelf(int[] nums) { int len = nums.length; int area = 1; int flag = 0; for(int i = 0; i \u0026lt; len; ++i){ if(nums[i] == 0){ ++flag; } else { area *= nums[i]; } } for(int i = 0; i \u0026lt; len; ++i){ if (flag \u0026gt; 1) { nums[i] = 0; } else if(flag == 1 \u0026amp;\u0026amp; nums[i] != 0) { nums[i] = 0; } else if(flag == 1 \u0026amp;\u0026amp; nums[i] == 0) { nums[i] = area; } else { nums[i] = area/nums[i]; } } return nums; } } go实现：\nfunc productExceptSelf(nums []int) []int { flag, area := 0, 1 for _, val := range nums { if val == 0 { flag++ } else { area *= val } } for i, val := range nums { if flag \u0026gt; 1 { nums[i] = 0 } else if flag == 1 \u0026amp;\u0026amp; val != 0 { nums[i] = 0 } else if flag == 1 \u0026amp;\u0026amp; val == 0 { nums[i] = area } else { nums[i] = area / val } } return nums } 239. 滑动窗口最大值(*) Java实现：\nclass Solution { public int[] maxSlidingWindow(int[] nums, int k) { int n = nums.length; Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;Integer\u0026gt;(); for (int i = 0; i \u0026lt; k; ++i) { while (!deque.isEmpty() \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[deque.peekLast()]) { deque.pollLast(); } deque.offerLast(i); } int[] ans = new int[n - k + 1]; ans[0] = nums[deque.peekFirst()]; for (int i = k; i \u0026lt; n; ++i) { while (!deque.isEmpty() \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[deque.peekLast()]) { deque.pollLast(); } deque.offerLast(i); while (deque.peekFirst() \u0026lt;= i - k) { deque.pollFirst(); } ans[i - k + 1] = nums[deque.peekFirst()]; } return ans; } } go实现：\nfunc maxSlidingWindow(nums []int, k int) []int { q := []int{} push := func(i int) { for len(q) \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[q[len(q)-1]] { q = q[:len(q)-1] } q = append(q, i) } for i := 0; i \u0026lt; k; i++ { push(i) } n := len(nums) ans := make([]int, 1, n-k+1) ans[0] = nums[q[0]] for i := k; i \u0026lt; n; i++ { push(i) for q[0] \u0026lt;= i-k { q = q[1:] } ans = append(ans, nums[q[0]]) } return ans } 240. 搜索二维矩阵 II Java实现：\nclass Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int x = 0, y = n - 1; while (x \u0026lt; m \u0026amp;\u0026amp; y \u0026gt;= 0) { if (matrix[x][y] == target) { return true; } if (matrix[x][y] \u0026gt; target) { --y; } else { ++x; } } return false; } } go实现：\nfunc searchMatrix(matrix [][]int, target int) bool { n, x, y := len(matrix[0]), len(matrix) - 1, 0 for x \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; n { if matrix[x][y] == target { return true } else if matrix[x][y] \u0026lt; target{ y++ } else { x-- } } return false } 279. 完全平方数(*) Java实现：\nclass Solution { public int numSquares(int n) { if (isPerfectSquare(n)) { return 1; } if (checkAnswer4(n)) { return 4; } for (int i = 1; i * i \u0026lt;= n; i++) { int j = n - i * i; if (isPerfectSquare(j)) { return 2; } } return 3; } // 判断是否为完全平方数 public boolean isPerfectSquare(int x) { int y = (int) Math.sqrt(x); return y * y == x; } // 判断是否能表示为 4^k*(8m+7) public boolean checkAnswer4(int x) { while (x % 4 == 0) { x /= 4; } return x % 8 == 7; } } go实现：\nfunc numSquares(n int) int { if isPerfectSquare(n) { return 1 } if checkAns4(n) { return 4 } for i := 1; i * i \u0026lt; n; i++ { y := n - i * i if isPerfectSquare(y) { return 2 } } return 3 } func isPerfectSquare(x int) bool { y := math.Sqrt((float64)(x)) return (int)(y) * (int)(y) == x } //判断是否能表示为 4^k*(8m+7) func checkAns4(x int) bool { for x % 4 == 0 { x /= 4 } return x % 8 == 7 } 283. 移动零(*) Java实现：\nclass Solution { public void moveZeroes(int[] nums) { if(nums.length \u0026lt;=1 )return; int index = 0; for(int i=0;i\u0026lt;nums.length;i++){ if(nums[i]!=0){ nums[index]=nums[i]; index++; } } for(int j=index;j\u0026lt;nums.length;j++){ nums[j]=0; } } } go实现：\nfunc moveZeroes(nums []int) { cur, n := 0, len(nums) for i := 0; i \u0026lt; n; i++ { if nums[i] != 0 { nums[cur] = nums[i] cur++ } } for i := cur; i \u0026lt; n; i++ { nums[i] = 0 } } 287. 寻找重复数(*) Java实现：\nclass Solution { public int findDuplicate(int[] nums) { int slow = 0, fast = 0; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = 0; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } } go实现：\nfunc findDuplicate(nums []int) int { fast, slow := nums[nums[0]], nums[0] for fast != slow { fast = nums[nums[fast]] slow = nums[slow] } fast = 0 for fast != slow { fast = nums[fast] slow = nums[slow] } return fast } 297. 二叉树的序列化与反序列化(*) Java实现：\npublic class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { return serialize2(root, \u0026#34;\u0026#34;); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] dataArray = data.split(\u0026#34;;\u0026#34;); List\u0026lt;String\u0026gt; dataList = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(dataArray)); return deserialize2(dataList); } public String serialize2(TreeNode root, String str){ if(root == null){ str += \u0026#34;null;\u0026#34;; } else { str += str.valueOf(root.val) + \u0026#34;;\u0026#34;; str = serialize2(root.left, str); str = serialize2(root.right, str); } return str; } public TreeNode deserialize2(List\u0026lt;String\u0026gt; dataList){ if(dataList.get(0).equals(\u0026#34;null\u0026#34;)) { dataList.remove(0); return null; } TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0))); dataList.remove(0); root.left = deserialize2(dataList); root.right = deserialize2(dataList); return root; } } go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Codec struct { data string } func Constructor() Codec { var codec Codec codec.data = \u0026#34;\u0026#34; return codec } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { if root == nil { return \u0026#34;nil;\u0026#34; } else { str := strconv.Itoa(root.Val) + \u0026#34;;\u0026#34; + this.serialize(root.Left) + this.serialize(root.Right) return str } } // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { array := strings.Split(data, \u0026#34;;\u0026#34;) res, _ := deal(array) return res } func deal(dataArray []string) (*TreeNode, []string) { if dataArray[0] == \u0026#34;nil\u0026#34; { dataArray = dataArray[1:] return nil, dataArray } val, _ := strconv.Atoi(dataArray[0]) root := \u0026amp;TreeNode{val, nil, nil} dataArray = dataArray[1:] root.Left, dataArray = deal(dataArray) root.Right, dataArray = deal(dataArray) return root, dataArray } /** * Your Codec object will be instantiated and called as such: * ser := Constructor(); * deser := Constructor(); * data := ser.serialize(root); * ans := deser.deserialize(data); */ 300. 最长递增子序列(*) Java实现：\nclass Solution { public int lengthOfLIS(int[] nums) { int len = 1, n = nums.length; if (n == 0) { return 0; } int[] d = new int[n + 1]; d[len] = nums[0]; for (int i = 1; i \u0026lt; n; ++i) { if (nums[i] \u0026gt; d[len]) { d[++len] = nums[i]; } else { int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0 while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (d[mid] \u0026lt; nums[i]) { pos = mid; l = mid + 1; } else { r = mid - 1; } } d[pos + 1] = nums[i]; } } return len; } } go实现：\nfunc lengthOfLIS(nums []int) int { len, n := 1, len(nums) dp := make([]int, n + 1) dp[len] = nums[0] for i := 1; i \u0026lt; n; i++ { if nums[i] \u0026gt; dp[len] { len++ dp[len] = nums[i] } else { l, r, pos, mid := 1, len, 0, 0 for l \u0026lt;= r { mid = (l + r) / 2 if dp[mid] \u0026lt; nums[i] { pos = mid l = mid + 1 } else { r = mid - 1 } } dp[pos + 1] = nums[i] } } return len } 301. 删除无效的括号(*) Java实现：\nclass Solution { int max = 0; String str; int lens; int n; Map\u0026lt;String, Integer\u0026gt; res; public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { n = s.length(); str = s; res = new HashMap\u0026lt;\u0026gt;(); int l = 0, r = 0, c1 = 0, c2 = 0; for (int i = 0; i \u0026lt; n; i++) { char ch = s.charAt(i); if(ch == \u0026#39;(\u0026#39;) { l++; c1++; } else if (ch == \u0026#39;)\u0026#39;){ if (l != 0) { l--; } else { r++; } c2++; } } lens = n - l - r; max = Math.min(c1, c2); dfs(0, l, r, 0, \u0026#34;\u0026#34;); List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for(String key : res.keySet()) { result.add(key); } return result; } void dfs(int index,int l,int r,int score, String cur) { if (l \u0026lt; 0 || r \u0026lt; 0 || score \u0026lt; 0 || score \u0026gt; max) { return; } if (l == 0 \u0026amp;\u0026amp; r == 0) { if (cur.length() == lens) { res.put(cur, 1); } } if (index == n) { return; } char c = str.charAt(index); if (c == \u0026#39;(\u0026#39;) { dfs(index + 1, l, r, score + 1, cur + c); dfs(index + 1, l - 1, r, score, cur); } else if (c == \u0026#39;)\u0026#39;) { dfs(index + 1, l, r, score - 1, cur + c); dfs(index + 1, l, r - 1, score, cur); } else { dfs(index + 1, l, r, score, cur + c); } } } go实现：\nvar res map[string]int var max int var lens int var n int var str string func removeInvalidParentheses(s string) []string { n = len(s) str = s res = make(map[string]int) l, r, c1, c2 := 0, 0, 0, 0 for _, ch := range s { if ch == \u0026#39;(\u0026#39; { l++ c1++ } else if ch == \u0026#39;)\u0026#39; { if l != 0 { l-- } else { r++ } c2++ } } lens = n - l - r max = min(c1, c2) dfs(0, l, r, 0, \u0026#34;\u0026#34;) result := []string{} for key := range res { result = append(result, key) } return result } func min(a, b int) int { if a \u0026lt; b { return a } return b } func dfs(index, l, r, score int, cur string) { if l \u0026lt; 0 || r \u0026lt; 0 || score \u0026lt; 0 || score \u0026gt; max { return } if l == 0 \u0026amp;\u0026amp; r == 0 { if (len(cur) == lens) { res[cur] = 1 } } if (index == n) { return } c := str[index] if c == \u0026#39;(\u0026#39; { dfs(index + 1, l, r, score + 1, fmt.Sprintf(\u0026#34;%s%c\u0026#34;, cur, c)); dfs(index + 1, l - 1, r, score, cur); } else if c == \u0026#39;)\u0026#39; { dfs(index + 1, l, r, score - 1, fmt.Sprintf(\u0026#34;%s%c\u0026#34;, cur, c)); dfs(index + 1, l, r - 1, score, cur); } else { dfs(index + 1, l, r, score, fmt.Sprintf(\u0026#34;%s%c\u0026#34;, cur, c)); } } 309. 最佳买卖股票时机含冷冻期(*) Java实现：\nclass Solution { public int maxProfit(int[] prices) { int n = prices.length; if (n \u0026lt; 2) { return 0; } int[][] dp = new int[n][3]; dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]); dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]); dp[i][2] = dp[i-1][1] + prices[i]; } return Math.max(dp[n-1][0], dp[n-1][2]); } } go实现：\nfunc maxProfit(prices []int) int { n := len(prices) if n \u0026lt; 2 { return 0 } dp := [5001][3]int{} dp[0][0] = 0 dp[0][1] = -prices[0] dp[0][2] = 0 for i := 1; i \u0026lt; n; i++ { dp[i][0] = max(dp[i-1][0], dp[i-1][2]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) dp[i][2] = dp[i - 1][1] + prices[i] } return max(dp[n-1][0], dp[n-1][2]) } func max(a, b int) int { if a \u0026gt; b { return a } return b } 312. 戳气球(*) Java实现：\nclass Solution { public int maxCoins(int[] nums) { int n = nums.length; int[][] rec = new int[n+2][n+2]; int[] val = new int[n+2]; val[0] = 1; val[n+1] = 1; for (int i = 1; i \u0026lt;= n; i++) { val[i] = nums[i-1]; } for (int i = n-1; i \u0026gt;= 0; i--){ for (int j = i + 2; j \u0026lt;= n + 1; j++){ for (int k = i + 1; k \u0026lt; j; k++) { int sum = val[i] * val[j] * val[k]; sum += rec[i][k] + rec[k][j]; rec[i][j] = Math.max(rec[i][j], sum); } } } return rec[0][n+1]; } } go实现：\nfunc maxCoins(nums []int) int { n := len(nums) rec := make([][]int, n + 2) for i := 0; i \u0026lt; n + 2; i++ { rec[i] = make([]int, n + 2) } val := make([]int, n + 2) val[0], val[n+1] = 1, 1 for i := 1; i \u0026lt;= n; i++ { val[i] = nums[i-1] } for i := n - 1; i \u0026gt;= 0; i-- { for j := i + 2; j \u0026lt;= n + 1; j++ { for k := i + 1; k \u0026lt; j; k++ { sum := val[i] * val[k] * val[j] sum += rec[i][k] + rec[k][j] rec[i][j] = max(rec[i][j], sum) } } } return rec[0][n+1] } func max(x, y int) int { if x \u0026gt; y { return x } return y } 322. 零钱兑换(*) Java实现：\nclass Solution { public int coinChange(int[] coins, int amount) { int max = amount + 1; int[] dp = new int[max]; for(int i = 1; i \u0026lt; max; i++){ dp[i] = max; } for(int i = 1; i \u0026lt;= amount; i++){ for(int j = 0; j \u0026lt; coins.length; j++){ if (coins[j] \u0026lt;= i) { dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); } } } return dp[amount] \u0026gt; amount ? -1 : dp[amount]; } } go实现：\nfunc coinChange(coins []int, amount int) int { max := amount + 1 dp := make([]int, amount + 1) for i, _ := range dp { dp[i] = max } dp[0] = 0 for i := 1; i \u0026lt;= amount; i++ { for j := 0; j \u0026lt; len(coins); j++ { if coins[j] \u0026lt;= i { dp[i] = min(dp[i], dp[i - coins[j]] + 1) } } } return If(dp[amount] \u0026gt; amount, -1 , dp[amount]) } func If(flag bool, a, b int) int { if flag { return a } else { return b } } func min(a, b int) int { if a \u0026lt; b { return a } return b } 337. 打家劫舍 III Java实现：\n/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int rob(TreeNode root) { int[] res = dfs(root); return Math.max(res[0], res[1]); } public int[] dfs(TreeNode root){ if(root == null) return new int[]{0, 0}; int[] left = dfs(root.left); int[] right = dfs(root.right); int selected = root.val + left[1] + right[1]; int noselected = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); return new int[]{selected, noselected}; } } go实现：\nfunc rob(root *TreeNode) int { val := dfs(root) return max(val[0], val[1]) } func dfs(node *TreeNode) []int { if node == nil { return []int{0, 0} } left, right := dfs(node.Left), dfs(node.Right) selected := node.Val + left[1] + right[1] notselected := max(left[0], left[1]) + max(right[0], right[1]) return []int{selected, notselected} } func max(x, y int) int { if x \u0026gt; y { return x } return y } 338. 比特位计数 Java实现：\nclass Solution { public int[] countBits(int n) { int[] res = new int[n+1]; for(int i = 1; i \u0026lt;= n; i++){ res[i] = res[i \u0026gt;\u0026gt; 1] + (i \u0026amp; 1); } return res; } } go实现：\nfunc countBits(n int) []int { bits := make([]int, n + 1) for i := 1; i \u0026lt;= n; i++ { bits[i] = bits[i \u0026gt;\u0026gt; 1] + (i \u0026amp; 1) } return bits } 448. 找到所有数组中消失的数字 go实现：\nfunc findDisappearedNumbers(nums []int) (ans []int) { n := len(nums) for _, val := range nums { nums[(val - 1) % n] += n } for i, val := range nums { if val \u0026lt;= n { ans = append(ans, i+1) } } return } 461. 汉明距离 go实现：\nfunc hammingDistance(x int, y int) (count int) { for x ^= y; x != 0; x \u0026gt;\u0026gt;= 1 { count += x \u0026amp; 1 } return } 543. 二叉树的直径 go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var maxres int func diameterOfBinaryTree(root *TreeNode) int { maxres = 0 deal(root) return maxres } func deal(root *TreeNode) int { if root == nil { return 0 } left, right := deal(root.Left), deal(root.Right) maxres = max(maxres, left + right) return max(left, right) + 1 } func max(a,b int) int { if a \u0026gt; b { return a } return b } 617. 合并二叉树 go实现：\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil \u0026amp;\u0026amp; root2 == nil { return nil } if root1 != nil \u0026amp;\u0026amp; root2 != nil { return \u0026amp;TreeNode{root1.Val + root2.Val, mergeTrees(root1.Left, root2.Left), mergeTrees(root1.Right, root2.Right)} } if root1 != nil { return root1 } else { return root2 } } ","date":"2022-06-26T00:00:00Z","permalink":"https://haolovelin.com/post/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93leetcode/","title":"算法刷题总结（LeetCode）"},{"content":"repo使用 一、基础设施\n安装Python 3 ，目前版本是3.9，不要安装Python 2，这是和旧办法的不同之处\n二、repo工具\n#下载、配置repo使用环境：\nmkdir -p ~/.bin\nPATH=\u0026quot;${HOME}/.bin:${PATH}\u0026quot;\ncurl https://storage.googleapis.com/git-repo-downloads/repo \u0026gt; ~/.bin/repo\nchmod a+rx ~/.bin/repo\n#本地新建一个工程文件夹，如repo：\nmkdir repo\ncd repo\n#init操作\nrepo init -u （manifest 的git 地址）\n命令行出现：repo has been initialized in xxx 表示init成功\n#同步仓库的代码\nrepo sync\n#切分支：\nrepo start 分支名字 \u0026ndash;all | project1 project2 …\n三、可能出现的问题：\n1.repo init -u （manifest 的git 地址）的时候，ssl请求出现如下情况，是证书问题：\nDownloading Repo source from https://gerrit.googlesource.com/git-repo\nfatal: Cannot get https://gerrit.googlesource.com/git-repo/clone.bundle\nfatal: error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1123)\nfatal: cloning the git-repo repository failed, will remove \u0026lsquo;.repo/repo\u0026rsquo;\n解决方法：（安装python目录下的证书，3.9为自己的python版本）\n/Applications/Python\\ 3.9/Install\\ Certificates.command\n2.repo init -u （manifest 的git 地址）的时候，manifest的default.xml找不到的问题：\nfatal: manifest \u0026lsquo;default.xml\u0026rsquo; not available\nfatal: manifest default.xml not found\n解决方法：\n因为git 仓库如果没配置default.xml，我们需要把工程的default.xml放入.repo/manifests 文件夹下\ndefault.xml中配置的属性： （1）remote 远程仓库地址配置，可以多个。\nname: 名字，也用于子仓库的 git remote 名称（.git/config 里的 remote）\nalias: 别名，可省略，建议设为 origin， 设置了那么子仓库的 git remote 即为此名，方便不同的 name 下可以最终设置生成相同的 remote 名称\nfetch: 仓库地址前缀，即 project 的仓库地址为: remote.fetch + project.name\npushurl: 一般可省略，省略了则直接用 fetch\nreview: Gerrit code review 的地址，如果没有用 Gerrit 则不需要配置（也就不能用 repo upload 命令了）\nrevision: 使用此 remote 的默认分支\n（2）project 子项目仓库配置，可以多个。\npath: repo sync 同步时，相对于根目录的子仓库文件夹路径\nname: 子仓库的 git 仓库名称\ngroup: 分组\nrevision: 使用的分支名\nclone-depth: 仓库同步 Git 的 depth\n（3）copyfile project 的子节点属性.\nsrc: project 下的相对路径\ndest: 整个仓库根路径下的相对路径\n（4）linkfile project 的子节点属性，类似 copyfile，只是把复制文件变为创建链接文件。\n（5）default project 没有设置属性时会使用的默认配置，常用的是 remote 和 revision。\n（6）其他 其他现在暂时用的较少，详细完整的 manifest 格式说明请看官方文档。 了解了 Repo 下的 Manifest 配置仓库的概念后就可以根据自己的项目来创建了，Just do it!\n（7）local_manifest local_manifest 简单说就是一个比 repo init 时设置的 manifest 有更高优先级的本地配置，一般用在不改动远程 manifest 配置又想设置到本地的专属配置时用得到。版本高一点的 repo 下，在工作根目录新建配置文件即可： .repo/local_manifests/local_manifest.xml\n有一点需要注意的是如果需要覆盖主 manifest 文件已有 project 的配置那么需要先 remove-project 才行，不然会报错：\nfatal: duplicate path project_name in .repo/manifest.xml\nfix : 命令：\nrepo status: 跟 git status 类似，会把当前 repo 工作区的状态信息列出来\nrepo diff: 同理 git diff\nrepo forall -c : 在（所有）子仓库下执行命令，比如 repo 没有类似 git stash 的命令，利用 forall 就可以实现：repo forall -c git stash\nrepo prune: 删除已经合并分支\nrepo stage: 把文件添加到 index 表(暂存区)中\nrepo manifest: 显示当前使用的 manifest 信息内容\n","date":"2022-01-09T00:00:00Z","permalink":"https://haolovelin.com/post/repo%E4%BD%BF%E7%94%A8/","title":"repo使用"},{"content":"1.二维数组的查找 题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n自己的思路：由于已经排序过，直接逐行找，如果碰到比目标值大的则break跳出循环，继续找下一行第一个，如果都没有则返回false\npublic class Solution { public boolean Find(int target, int [][] array) { int nextSearch = array[0].length; for(int i = 0;i \u0026lt; array.length;i++){ for(int j = 0;j \u0026lt; nextSearch;j++){ if(target\u0026lt;array[i][j]){ nextSearch = j; break; }else if(target==array[i][j]){ return true; } } } return false; } } 2.替换空格 题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n自己的思路：直接使用Java字符串的replaceAll，或者老老实实循环判断每个char\n//方法一 public class Solution { public String replaceSpace (String s) { // write code here if (s == null || s.equals(\u0026#34;\u0026#34;)) return s; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i \u0026lt; s.length(); i++){//遍历 if (s.charAt(i) == \u0026#39; \u0026#39;) { stringBuilder.append(\u0026#34;%20\u0026#34;); } else { stringBuilder.append(s.charAt(i)); } } return stringBuilder.toString(); } } //方法二：直接使用api public class Solution { public String replaceSpace(String str) { return str.replaceAll(\u0026#34; \u0026#34;,\u0026#34;%20\u0026#34;); } } 3.从尾到头打印链表 题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。\n自己的思路：可以写个链表反转，或者直接用LinkedList使用头插法，再转成ArrayList返回\n/** * public class ListNode { * int val; * ListNode next = null; * * ListNode(int val) { * this.val = val; * } * } * */ import java.util.ArrayList; import java.util.LinkedList; public class Solution { public ArrayList\u0026lt;Integer\u0026gt; printListFromTailToHead(ListNode listNode) { if(listNode == null){ return new ArrayList(); } LinkedList res = new LinkedList(); while(listNode!=null){ res.addFirst(listNode.val); listNode = listNode.next; } return new ArrayList(res); } } 4.重建二叉树 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n自己的思路：根据两个遍历的序列找根节点，再递归创建子树\n/** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ import java.util.*; public class Solution { public TreeNode reConstructBinaryTree(int [] pre,int [] in) { if(pre.length==0 || in.length == 0){ return null; } int root = (pre[0]); TreeNode resRoot = new TreeNode(root); for(int i=0;i\u0026lt;in.length;i++){ if(root == in[i]){ resRoot.left=reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i)); resRoot.right=reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length)); break; } } return resRoot; } } 5.用两个栈实现队列 题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n自己的思路：一个栈用于接收push的int，另一个栈用于将栈内数据倒出来，输出第一个栈的栈底元素\nimport java.util.Stack; public class Solution { Stack\u0026lt;Integer\u0026gt; stack1 = new Stack\u0026lt;Integer\u0026gt;(); Stack\u0026lt;Integer\u0026gt; stack2 = new Stack\u0026lt;Integer\u0026gt;(); public void push(int node) { stack1.push(node); } public int pop() { while(stack1.size()\u0026gt;1){ stack2.push(stack1.pop()); } int res = stack1.pop(); while(!stack2.empty()){ stack1.push(stack2.pop()); } return res; } } 6.旋转数组的最小数字 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n自己的思路：二分法和暴力破解都行，自己用的暴力破解，遇到比第一个数小的就返回该数\n//暴力破解 import java.util.ArrayList; public class Solution { public int minNumberInRotateArray(int [] array) { if(array.length==0) return 0; int len = array.length; int flag = array[0]; for(int i=1;i\u0026lt;array.length;i++){ if(array[i]\u0026lt;flag){ return array[i]; } } return 0; } } //二分法 public class Solution { public int minNumberInRotateArray(int [] array) { if(array.length==0) return 0; int len = array.length; int first = 0; int last = len-1; int mid; while (first\u0026lt;last) { mid = (first+last)/2; if (array[mid] \u0026lt; array[last]) {//如果mid的值小于last，则在左边，但可能是mid last = mid; } else if (array[mid] \u0026gt; array[last]) {//如果mid的值大于last，则在右边，而且不可能是mid first = mid + 1; } else {//相等的情况，两边都有可能，可以缩减last last--; } } return array[first]; } } 7.斐波那契数列 题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n\u0026lt;=39\n自己的思路：写个循环一直算到第n项\npublic class Solution { public int Fibonacci(int n) { int pre = 0,next = 1,count = 0,tmp = 0; while(count != n){ tmp = next; next += pre; pre = tmp; count++; } return pre; } } 8.跳台阶 题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。\n自己的思路：递归，将问题规模缩小，一次缩小1或者2\n//递归 public class Solution { public int jumpFloor(int target) { if(target==0){ return 0; }else if(target==1){ return 1; }else if(target==2){ return 2; }else{ return jumpFloor(target-1)+jumpFloor(target-2);//跳上i-1阶（跳1）+ 跳上i-2阶（跳2） } } } //递推 public class Solution { public int jumpFloor(int target) { int a = 1, b = 1; for (int i = 2; i \u0026lt;= target; i++) { a = a + b;//计算跳上i阶的结果 b = a - b;//还原出跳上i-1阶的结果 } return a; } } 9.变态跳台阶 题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n自己的思路：想着按8照猫画虎，好像又有点复杂，于是想着能不能用数学公式解决，数学归纳法走起，二项式定理得出：\npublic class Solution { public int jumpFloorII(int target) { if(target==0)return 0; //数学归纳法，2^(n-1) //return (int)Math.pow(2,target-1); return 1\u0026lt;\u0026lt;(target-1);//位运算更省时间 } } 10.矩形覆盖 题目：我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？\n比如n=3时，2 * 3的矩形块有3种覆盖方法：\n自己的思路：还是要缩小问题规模，那这2 * n的矩形，最左侧起，要么竖着，要么横着，竖着则问题规模-1，横着问题规模-2，n=1时只有1种解法，n=2时有2种解法，可以用递归解决\n//递归 public class Solution { public int rectCover(int target) { if(target\u0026lt;=2){ return target; }else{ return rectCover(target-1)+rectCover(target-2); } } } //递推 public class Solution { public int rectCover(int target) { if(target\u0026lt;=2){ return target; } int a = 2;//记录大的那个 int b = 1;//记录小的那个 for(int i = 3; i \u0026lt;= target; i++){ a = a + b; b = a - b; } return a; } } 11.二进制中1的个数 题目：输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。\n自己的思路：一开始是想除以2不断求余数的，但是负数用的补码，碰到负数那不就懵了，在一阵思考之后感觉位运算是个突破口，拿1来进行与运算，因为它的32位机器数表示是000\u0026hellip;\u0026hellip;001，每次与运算判断结果然后继续进行右移操作，就可以每次都比较最后一位是不是1，进而count统计出来，在进行32次之后得到结果\npublic class Solution { public int NumberOf1(int n) { int count = 0; for(int i = 1;i\u0026lt;=32;i++){ if((n\u0026amp;1)==1){ count++; } n = n\u0026gt;\u0026gt;1; } return count; } } 12.数值的整数次方 题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n保证base和exponent不同时为0\n自己的思路：直接乘？考虑底数或者指数为0的特殊情况，最少的代码量应该是直接使用工具类\n//math库函数 public class Solution { public double Power(double base, int exponent) { return Math.pow(base,exponent); } } //直接乘 public class Solution { public double Power(double b, int n) { if (n \u0026lt; 0) { b = 1 / b; n = -n; } double res = 1.0; for(int i=0;i\u0026lt;n;i++){ res *= b; } return res; } } 13.调整数组顺序使奇数位于偶数前面 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n自己的思路：新建两个数组分别记录奇偶数，遍历所给的数组，符合情况就分别丢进两个数组中，然后使用System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);去放回原数组中\n//方法一 public class Solution { public int[] reOrderArray (int[] array) { int odd=0,even=0,len=array.length; int[] arrOdd = new int[len]; int[] arrEven = new int[len]; for(int i=0;i\u0026lt;len;i++){ if(array[i]%2!=0){ arrOdd[odd]=array[i]; odd++; }else{ arrEven[even]=array[i]; even++; } } System.arraycopy(arrOdd,0,array,0,odd); System.arraycopy(arrEven,0,array,odd,even); return array; } } //方法二，双指针 public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param array int整型一维数组 * @return int整型一维数组 */ public int[] reOrderArray (int[] array) { //双指针，头尾指针 int[] nums = new int[array.length]; int head = 0; int tail = array.length-1; int index_head = head; int index_tail = tail; while(head \u0026lt; array.length \u0026amp;\u0026amp; tail \u0026gt;= 0){ if(array[head] % 2 == 1){ //奇数，放前面 nums[index_head] = array[head]; index_head++; } head++; if(array[tail] % 2 == 0){ //从后到前，如果为偶数，则从后开始填 nums[index_tail] = array[tail]; index_tail--; } tail--; } return nums; } } 14.链表中倒数第k个结点 题目：输入一个链表，输出该链表中倒数第k个结点。\n自己的思路：遍历链表，算出链表长度，然后计算应该输出的结点的位置，输出对应的结点，注意边界处理：链表空或者k大于链表长度的情况\n/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ //方法一，求长度后输出对应的 public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if(k==0 || head == null)return null; int len = 0; ListNode res = head; while(res!=null){ res = res.next; len++; } if(len\u0026lt;k)return null; for(int i=0;i\u0026lt;len-k;i++){ head = head.next; } return head; } } //方法二，同步记录第n个节点时新开始遍历，即可知道倒数第n个节点的值 public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if(k==0 || head == null)return null; int len = 0; ListNode res = head; while(head!=null \u0026amp;\u0026amp; len \u0026lt; k){ head = head.next; len++; } while(head!=null){ res = res.next; head = head.next; } if(len \u0026lt; k){ return null; } return res; } } 15.反转链表 题目：输入一个链表，反转链表后，输出新链表的表头。\n自己的思路：递归的话比较方便，但用循环比较好，防止溢出，从表头开始，newhead记录新的表头结点，如果不为空，则用临时结点tmp继续去存它的next结点，然后把newhead的next指向当前的表头结点，然后head指向newhead当前的结点，newhead指向tmp结点，继续循环操作\n/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ import java.util.*; public class Solution { public ListNode ReverseList(ListNode head) { ListNode tmp = null; ListNode newhead = null; if(head == null || head.next == null){ return head; } newhead = head.next; head.next = null; while(newhead != null){ tmp = newhead.next; newhead.next = head; head = newhead; newhead = tmp; } return head; } } 16.合并两个排序的链表 题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。\n自己的思路：新建一个链表，每次拿两个链表的结点的值比较，值小的链接到新建的链表上，直到一个链表为空为止\n/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode Merge(ListNode list1,ListNode list2) { if(list1 == null)return list2; if(list2 == null)return list1; ListNode tmp = null; ListNode res = null; while(list1 != null \u0026amp;\u0026amp; list2 != null){ if(list1.val\u0026lt;list2.val){ if(res==null){ res = list1; tmp = res; }else{ tmp.next = list1; tmp = tmp.next; } list1 = list1.next; }else{ if(res==null){ res = list2; tmp = res; }else{ tmp.next = list2; tmp = tmp.next; } list2 = list2.next; } } if(list1 == null)tmp.next = list2; if(list2 == null)tmp.next = list1; return res; } } 17.树的子结构 题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）\n自己的思路：从根节点开始，如果值相等：则去一路判断两个树的子节点的值，如果判断到B的子节点为空则说明匹配完成，如果没到或者A的子节点为空则匹配失败。如果根结点的值不相等：则判断A的左右子树和B是否匹配，进行递归\n/** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public boolean HasSubtree(TreeNode root1,TreeNode root2) { if(root1 == null || root2 == null){ return false; } if(root1.val == root2.val){ if(judge(root1,root2)){ return true; } } return HasSubtree(root1.left,root2)||HasSubtree(root1.right,root2); } public boolean judge(TreeNode root, TreeNode subtree) { if(subtree == null){ return true; } if(root == null){ return false; } if(root.val == subtree.val){ return judge(root.left, subtree.left) \u0026amp;\u0026amp; judge(root.right, subtree.right); } return false; } } 18.二叉树的镜像 题目：操作给定的二叉树，将其变换为源二叉树的镜像。\n二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 自己的思路：好像可以用中序遍历压栈再输出一个新的树，但是感觉会有点麻烦，所以试着从根节点开始直接互换左右子树，子树做相同的操作，直到子树为空\n/** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public TreeNode Mirror(TreeNode root) { if(root == null)return null; TreeNode tmp = null; tmp = root.left; root.left = root.right; root.right = tmp; Mirror(root.left); Mirror(root.right); return root; } } 19.顺时针打印矩阵 题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.\n自己的思路：一圈一圈缩减规模，每次碰壁就换方向，直到最后走不动为止，本来写了四个方向移动的方法，但代码比较难写，参考了一下大神写法\nimport java.util.ArrayList; public class Solution { public ArrayList\u0026lt;Integer\u0026gt; printMatrix(int [][] matrix) { if(matrix == null)return null; int l=0,r = matrix[0].length-1; int t=0,b = matrix.length-1; ArrayList\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(); while(true){ for(int i=l;i\u0026lt;=r;i++){ array.add(matrix[t][i]); }if(++t\u0026gt;b)break; for(int i=t;i\u0026lt;=b;i++){ array.add(matrix[i][r]); }if(l\u0026gt;--r)break; for(int i=r;i\u0026gt;=l;i--){ array.add(matrix[b][i]); }if(t\u0026gt;--b)break; for(int i=b;i\u0026gt;=t;i--){ array.add(matrix[i][l]); }if(++l\u0026gt;r)break; } return array; } } 20.包含min函数的栈 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。\n自己的思路：利用双栈，一个栈负责存源数据，一个栈负责存最小值的压栈，如果新push的数据比当前的数据小或者相等，则两个栈都进行push操作，否则最小值栈不进行push。在pop的时候，如果两个栈的栈顶相同，则两个栈都进行pop操作，否则最小值栈不pop，top则返回源数据栈的栈顶，min则返回最小值栈的栈顶。\nimport java.util.Stack; public class Solution { Stack\u0026lt;Integer\u0026gt; stack = new Stack(); Stack\u0026lt;Integer\u0026gt; minstack = new Stack(); public void push(int node) { if(stack.empty()){ stack.push(node); minstack.push(node); }else{ stack.push(node); if(minstack.peek()\u0026gt;=stack.peek()){ minstack.push(node); } } } public void pop() { if(minstack.peek()==stack.peek()){ minstack.pop(); } stack.pop(); } public int top() { return stack.peek(); } public int min() { return minstack.peek(); } } 21.栈的压入、弹出序列 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）\n自己的思路：把序列进行模拟入栈出栈即可，如果当前元素不等于出栈序列的第i个数，则入栈，等于则出栈，遍历完出栈序列，如果栈为空则说明为入栈序列的出栈序列之一，否则不可能是出栈序列\nimport java.util.ArrayList; import java.util.Stack; public class Solution { public boolean IsPopOrder(int [] pushA,int [] popA) { Stack\u0026lt;Integer\u0026gt; stack = new Stack(); if(pushA.length==1)return pushA[0]==popA[0]; int flag = 1; stack.push(pushA[0]); for(int i =0;i\u0026lt;popA.length;i++){ while(stack.empty() || popA[i]!=stack.peek()){//empty()防止越界 if(flag==popA.length)return false; stack.push(pushA[flag++]); } stack.pop(); } if(stack.empty())return true; return false; } } 22.从上往下打印二叉树 题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n自己的思路：使用ArrayList存储二叉树结点，按队列的方式取出然后把值放入目标队列\nimport java.util.ArrayList; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList\u0026lt;Integer\u0026gt; PrintFromTopToBottom(TreeNode root) { if(root==null)return new ArrayList(); ArrayList\u0026lt;Integer\u0026gt; arr = new ArrayList(); ArrayList\u0026lt;TreeNode\u0026gt; arrt = new ArrayList(); arrt.add(root); while(arrt.size()!=0){ TreeNode tmp = arrt.remove(0); arr.add(tmp.val); if(tmp.left!=null)arrt.add(tmp.left); if(tmp.right!=null)arrt.add(tmp.right); } return arr; } } 23.二叉搜索树的后序遍历序列 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。\n自己的思路：后序遍历，那么最后的必定是根节点，那么前面那串比它大的数必定是它的右子树，遇到大的就入栈，遇到小的就出栈，输出，输出序列一定会是一个逆序的序列，全部入栈，最后直到全部出栈如果没异常就返回true\nimport java.util.*; public class Solution { public boolean VerifySquenceOfBST(int [] sequence) { if(sequence.length==0)return false; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int max = (int) 1e8; int i=sequence.length-1; while(i\u0026gt;=0){ if(stack.empty() || stack.peek()\u0026lt;sequence[i]){ stack.push(sequence[i]); i--; }else if(stack.peek()\u0026gt;sequence[i]){ while(!stack.empty() \u0026amp;\u0026amp; stack.peek()\u0026gt;sequence[i]){ if(max\u0026gt;stack.peek()){ max = stack.pop(); }else{ return false; } } stack.push(sequence[i]); i--; } } while(!stack.empty()){ if(max\u0026gt;stack.peek()){ max = stack.pop(); }else{ return false; } } return true; } } 24.二叉树中和为某一值的路径 题目：输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n自己的思路：递归算法三部曲：\n明白递归函数的功能：FindPath(TreeNode* root,int sum)，从root节点出发，找和为sum的路径 递归终止条件：当root节点为叶子节点并且sum==root-\u0026gt;val, 表示找到了一条符合条件的路径 下一次递归：如果左子树不空，递归左子树FindPath(root-\u0026gt;left, sum - root-\u0026gt;val),如果右子树不空，递归右子树，FindPath(root-\u0026gt;right, sum - root-\u0026gt;val) import java.util.ArrayList; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt; FindPath(TreeNode root,int target) { ArrayList\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if(root == null) return res; dfs(root, target, path, res); return res; } public void dfs(TreeNode root, int sum, ArrayList\u0026lt;Integer\u0026gt; path ,ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt; res){ path.add(root.val); if(sum == root.val \u0026amp;\u0026amp; root.left == null \u0026amp;\u0026amp; root.right == null){ res.add(path); } if(root.left != null) dfs(root.left, sum - root.val,(ArrayList\u0026lt;Integer\u0026gt;) path.clone(), res); if(root.right != null) dfs(root.right, sum - root.val,(ArrayList\u0026lt;Integer\u0026gt;) path.clone(), res); } } 25.复杂链表的复制 题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。\n1的位置指向3，2的位置指向5，3的位置指向null，4的位置指向2，5的位置指向null\n如下图:\n自己的思路：遍历，hashmap存结点，然后一个一个拷贝\nimport java.util.HashMap; /* public class RandomListNode { int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) { this.label = label; } } */ public class Solution { public RandomListNode Clone(RandomListNode pHead) { if(pHead == null) return null;//判空 RandomListNode res = new RandomListNode(pHead.label);//res为结果的指针 if(pHead.next == null){//只有一个节点的情况 res.next = null; if(pHead.random == null){//特殊情况处理 res.random = null; return res; } res.random = new RandomListNode(pHead.random.label); return res; } RandomListNode cur = res; //多个节点的情况 HashMap\u0026lt;Integer,RandomListNode\u0026gt; labelMap = new HashMap\u0026lt;\u0026gt;(); while(pHead.next != null){//循环遍历整个链表 if(!labelMap.containsKey(pHead.next.label)){ cur.next = new RandomListNode(pHead.next.label); labelMap.put(pHead.next.label,cur.next);//存map }else{ cur.next = labelMap.get(pHead.next.label); } if(pHead.random == null){ cur.random = null; pHead = pHead.next; cur = cur.next; continue; } if(!labelMap.containsKey(pHead.random.label)){ cur.random = new RandomListNode(pHead.random.label); labelMap.put(pHead.random.label,cur.random);//存map }else{ cur.random = labelMap.get(pHead.random.label); } pHead = pHead.next; cur = cur.next; } cur.next = null; if(pHead.random == null){//特殊情况处理 cur.random = null; return res; } if(!labelMap.containsKey(pHead.random.label)){ cur.random = new RandomListNode(pHead.random.label); }else{ cur.random = labelMap.get(pHead.random.label); } return res; } } 26.二叉搜索树与双向链表 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示\n注意:\n1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构\n4.你不用输出或者处理，示例中输出里面的英文，比如\u0026quot;From left to right are:\u0026ldquo;这样的，程序会根据你的返回值自动打印输出\n示例:\n输入: {10,6,14,4,8,12,16}\n输出:From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;\n解析:\n输入就是一棵二叉树，如上图，输出的时候会将这个双向链表从左到右输出，以及\n从右到左输出，确保答案的正确\n自己的思路：先遍历右子树，再遍历根节点，再遍历左子树，线索化二叉树，用一个全局变量去保存前一个节点，然后再去创建节点之间的关系\n/** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { TreeNode pre=null; public TreeNode Convert(TreeNode pRootOfTree) { if (pRootOfTree==null) return null; Convert(pRootOfTree.right); if (pre!= null){ pRootOfTree.right=pre; pre.left=pRootOfTree; } pre=pRootOfTree; Convert(pRootOfTree.left); return pre; } } 27.字符串的排列 题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。\n自己的思路： 假设输入为a、b、c 那么其实排序的总数： fun（a，b，c）=a（fun（b，c））+ a和b交换（fun（a，c））+a和c交换（fun（b，a）） fun（b，c） = b+fun（c）+b和c交换（fun（b）） fun（c）=1 所以用递归的方法就可以了，并且在这个递归的过程中，并没有做出一些浪费运行时间的事情，每一个递归都会产生新的结果，因此用递归来解决被称为动态规划的此题，是合理的。 另外题目中说明可能存在重复的字符，因此在进行交换的时候需要判断进行交换的字符是否相等，如果相等就没有必要交换了。\nimport java.util.*; public class Solution { public ArrayList\u0026lt;String\u0026gt; PermutationHelp(StringBuilder str){ ArrayList\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;String\u0026gt;(); if(str.length() == 1)result.add(str.toString()); else{ for(int i = 0; i \u0026lt; str.length(); i++){ if(i== 0 || str.charAt(i) != str.charAt(0)){ char temp = str.charAt(i); str.setCharAt(i, str.charAt(0)); str.setCharAt(0, temp); ArrayList\u0026lt;String\u0026gt; newResult = PermutationHelp(new StringBuilder(str.substring(1))); for(int j =0; j \u0026lt; newResult.size(); j++) result.add(str.substring(0,1)+newResult.get(j)); //用完还是要放回去的 temp = str.charAt(0); str.setCharAt(0, str.charAt(i)); str.setCharAt(i, temp); } } //需要在做一个排序操作 } return result; } public ArrayList\u0026lt;String\u0026gt; Permutation(String str) { StringBuilder strBuilder = new StringBuilder(str); ArrayList\u0026lt;String\u0026gt; result = PermutationHelp(strBuilder); result.sort(new Comparator\u0026lt;String\u0026gt;() {//排序 @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }); return result; } } 28.数组中出现次数超过一半的数字 题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。你可以假设数组是非空的，并且给定的数组总是存在多数元素。1\u0026lt;=数组长度\u0026lt;=50000\n自己的思路：map存key和个数，先遍历记录个数，然后遍历记录的结果，看哪个最大\nimport java.util.*; public class Solution { public int MoreThanHalfNum_Solution(int [] array) { HashMap\u0026lt;Integer,Integer\u0026gt; flagMap = new HashMap\u0026lt;\u0026gt;(); int res = 0; int countMax = 0; for(int i = 0; i\u0026lt; array.length; i++){ if (flagMap.containsKey(array[i])) { int value = flagMap.get(array[i]) + 1; flagMap.put(array[i],value); } else { flagMap.put(array[i],1); } } for(Integer i : flagMap.keySet()){ if(flagMap.get(i)\u0026gt;countMax){ countMax = flagMap.get(i); res = i; } } return res; } } 29.最小的K个数 题目：给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。\n0 \u0026lt;= k \u0026lt;= input.length \u0026lt;= 10000 0 \u0026lt;= input[i] \u0026lt;= 10000 自己的思路：先排序后取最小的K个数，堆排序是时间复杂度最小的算法，因为只需要确定K个即可返回。\n//使用工具类 import java.util.*; public class Solution { public ArrayList\u0026lt;Integer\u0026gt; GetLeastNumbers_Solution(int [] input, int k) { if(k\u0026lt;=0)return new ArrayList\u0026lt;Integer\u0026gt;(); Arrays.sort(input); ArrayList\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0;i\u0026lt;k;i++){ res.add(input[i]); } return res; } } 30.连续子数组的最大和 题目：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).\n自己的思路：动态规划，状态定义：dp[i]表示以i结尾的连续子数组的最大和。所以最终要求dp[n-1] 状态转移方程：dp[i] = max(array[i], dp[i-1]+array[i]) 解释：如果当前元素为整数，并且dp[i-1]为负数，那么当然结果就是只选当前元素 技巧：这里为了统一代码的书写，定义dp[i]表示前i个元素的连续子数组的最大和，结尾元素为array[i-1]\npublic class Solution { public int FindGreatestSumOfSubArray(int[] array) { int length = array.length; int[] dp = new int[length+1]; dp[0] = 0; int res = array[0]; for(int i=1;i\u0026lt;=length;i++){ dp[i] = Math.max(array[i-1],dp[i-1]+array[i-1]); res = Math.max(res,dp[i]); } return res; } } ","date":"2021-07-20T00:00:00Z","permalink":"https://haolovelin.com/post/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E5%89%91%E6%8C%87offer/","title":"算法刷题总结（剑指offer）"},{"content":"计算机基础——计算机网络 作为一名程序员，不可能不与网络打交道。所以网络的知识很重要，以下提及的知识点都需要了解清楚。\n一、背景知识 1、什么是计算机网络 计算机网络，是指地理位置不同，具有独立功能的计算机及周边设备，通过在网络操作系统中连接的通信线路，管理和协调网络管理软件和网络通信协议，实现计算机系统的资源共享和信息传输的计算机系统。\n计算机网络的基本功能是数据通信和资源共享。 资源共享包括硬件、软件和数据资源的共享。\n2、网络的分类 按照覆盖的地理范围来分： 广域网：广域网是一种公共数据网络，其可以将远隔千里的计算机连在一起。 局域网：局域网一般属于单位所有，用于将有限范围内的各种计算机、终端和外部设备连接起来。 城域网：是以IP为基础，通过计算机网络、广播电视台、电信网的三网融合，形成覆盖城市区域的网络通信平台。 比如：校园网就属于局域网\n二、OSI\u0026mdash;开放系统互连基本参考模型 OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型，是一个逻辑上的定义和规范 ，顾名思义，把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机； OSI七层模型是一种框架性的设计方法，其最主要的功能就是帮助不同类型的主机实现数据传输。 学习计算机网络原理的时候往往用的是五层协议的体系结构 : 物理层, 数据链路层, 网络层, 传输层和应用层。 但是我们今天了解一下七层都有什么吧。\n1、物理层 我们都知道，计算机的世界里只有0和1, 存储在计算机中也是一大串0和1的组合。但是这些数字不能在真实的物理介质中传输，而需要把它转换为光信号或者电信号，所以这一层负责将这些比特流与光电信号进行转换。\n如果没有物理层， 那么也就不存在互联网,，不存在数据的共享， 因为数据无法在网络中流动。 所以， 物理层处于OSI参考模型的最低层，它利用传输介质为通信的主机之间建立，管理和释放物理连接，实现比特流的透明传输（传输单位是比特），保证比特流通过传输介质的正确传输。\n2、数据链路层 数据在这一层不再是以比特流的形式传输，而是分割成一个一个的 帧 再进行传输。也就是说，数据链路层 是为网络层提供数据传送服务的，这种服务要依靠本层具备的功能来实现。 链路层应具备如下功能： （1）链路连接的建立、拆除和分离 （2）帧定界和帧同步。链路层的数据传输单元是帧，协议不同，帧的长短和界面也有差别，但无论如何必须对帧进行定界； （3）顺序控制，指对帧的收发顺序的控制； （4）差错检测和恢复。还有链路标识，流量控制等等。差错检测多用方阵码校验和循环码校验来检测信道上数据的误码，而帧丢失等用序号检测。各种错误的恢复则常靠反馈重发技术来完成。\n3、网络层 网络层是将网络地址翻译成对应的物理地址，通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制、拥塞控制和网络互联的功能；网络层用于本地L A N网段之上的计算机系统建立通信，它之所以可以这样做，是因为它有自己的路由地址结构，这种结构与第二层机器地址是分开的、独立的。这种协议称为路由或可路由协议。 为建立网络连接和为上层提供服务，网络层应具备以下主要功能： （1）路由选择和中继； （2）激活，终止网络连接； （3）在一条数据链路上复用多条网络连接，多采取 分时复用技术； （4）检测与恢复； （5）排序，流量控制； （6）服务选择； （7）网络管理。\n4、传输层 传输层是两台计算机经过网络进行数据通信时，第一个端到端的层次，具有缓冲作用。当网络层服务质量不能满足要求时，它将服务加以提高，以满足高层的要求；当网络层服务质量较好时，它只用很少的工作。传输层还可进行复用，即在一个网络连接上创建多个逻辑连接。传输层也称为运输层。传输层只存在于端开放系统中，是介于低3层通信子网系统和高3层之间的一层，但是很重要的一层。因为它是源端到目的端对数据传送进行控制从低到高的最后一层。 主要功能是端开放系统之间数据的收妥确认。同时，还用于弥补各种通信网路的质量差异，对经过下三层之后仍然存在的传输差错进行恢复，进一步提高可靠性。另外，还通过复用、分段和组合、连接和分离、分流和合流等技术措施，提高吞吐量和服务质量。 这一层主要重点是两个协议 : UDP 和 TCP。在以后的文章会介绍这两个协议。\n5、会话层 会话层负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。 会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限。\n6、表示层 它的主要作用之一是为异种机通信提供一种公共语言，以便能进行互操作。这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。与第五层提供透明的数据运输不同，表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。除此之外，表示层协议还对图片和文件格式信息进行解码和编码。 例如，IBM 主机 使用EBCDIC编码，而大部分PC机使用的是ASCII码。在这种情况下，便需要表示层来完成这种转换。\n7、应用层 OSI参考模型的最高层。 其功能是实现应用进程（如用户程序、终端操作员等）之间的信息交换。同时，还具有一系列业务处理所需要的服务功能。 应用层一般包括公共应用服务要素（CASE）和特定应用服务要素（SASE）。其中CASE提供应用进程中最基本的服务，向应用进程提供信息传送所必需的、但又独立于应用进程通信的能力。SASE实质上是各种应用进程在应用层中的映射，每一个SASE都针对某一类具体应用，例如文件传送、访问和管理（FTAM）、虚拟终端（VT）、消息处理系统（MHS）、电子数据互换（EDI）和目录查询等。 OSI七层模型的优点 OSI七层模型将服务、接口和协议这三个概念明确地区分开来，这样各个层之间具有很强的独立性， 所以： （服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务） 1、减少网络复杂度 ，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错； 2、标准化 ，每一层都遵循同样的标准，便于不同的网络设备实现互操作 3、模块化 4、协作 5、加速发展 ，有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术。 6、简单教学\n三、TCP/IP四层模型 1、什么是TCP/IP？ TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇. TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求.\n2、分层介绍 （1）应用层 TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。　应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本传输协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。\n（2）传输层: 负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机.在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmissioncontrol protocol）和用户数据报协议UDP（user datagram protocol）。　TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。　（3）网络层: 负责地址管理和路由选择. 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规划出两台主机之间的数据传输的线路(路由). 路由器(Router)工作在网络层. （4）网络接口层网络接口层与OSI参考模型中的物理层和数据链路层相对应。网络接口层是TCP/IP与各种LAN或WAN的接口。\n网络接口层在发送端将上层的IP数据报封装成帧后发送到网络上；数据帧通过网络到达接收端时，该结点的网络接口层对数据帧拆封，并检查帧中包含的MAC地址。如果该地址就是本机的MAC地址或者是广播地址，则上传到网络层，否则丢弃该帧。\n当使用串行线路连接主机与网络，或连接网络与网络时，例如，主机通过Modem和电话线接入Internet，则需要在网络接口层运行SLIP或PPP协议。\n☆ SLIP（Serial Line Internet Protocol）协议提供了一种在串行通信线路上封装IP数据报的简单方法，使用户通过电话线和Modem能方便地接入TCP/IP网络。\n☆ PPP（Point to Point Protocol）协议是一种有效的点到点通信协议，解决了SLIP存在的上述问题，即可以支持多种网络层协议（如IP、IPX等），支持动态分配的IP地址；并且PPP帧中设置了校验字段，因而PPP在网络接口层上具有差错检验能力。\n四、TCP的三次握手和四次挥手 TCP 协议简述 TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。\n无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。 同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式，所以需要四次挥手关闭连接。\nTCP包首部 网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。\n所以我们在学习TCP协议之前，首先要知道TCP在网络传输中处于哪个位置，以及它的协议的规范，下面我们就看看TCP首部的网络传输起到的作用：\n下面的图是TCP头部的规范定义，它定义了TCP协议如何读取和解析数据： TCP首部承载这TCP协议需要的各项信息，下面我们来分析一下：\nTCP端口号 TCP的连接是需要四个要素确定唯一一个连接： （源IP，源端口号）+ （目地IP，目的端口号） 所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递 源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535 另外1024以下是系统保留的，从1024-65535是用户使用的端口范围 TCP的序号和确认号： 32位序号 seq：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。 32位确认号 ack：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。 TCP的标志位 每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。 用的最广泛的标志是 SYN，ACK 和 FIN，用于建立连接，确认成功的段传输，最后终止连接。 SYN：简写为S，同步标志位，用于建立会话连接，同步序列号； ACK： 简写为.，确认标志位，对已接收的数据包进行确认； FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接； PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队； RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包； URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理； TCP 三次握手建立连接 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个报文。\n三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。\n三次握手过程的示意图如下： 第一次握手： 客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。 第二次握手： 服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。 第三次握手： 客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。 注意:我们上面写的ack和ACK，不是同一个概念：\n小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。 下面我自己做实验，开一个HTTP服务，监听80端口，然后使用Tcpdump命令抓包，看一下TCP三次握手的过程：\nsudo tcpdump -n -t -S -i enp0s3 port 80 第一次握手，标志位Flags=S IP 10.0.2.2.51323 \u0026gt; 10.0.2.15.80: Flags [S], seq 84689409, win 65535, options [mss 1460], length 0 第二次握手，标志位Flags=[S.] IP 10.0.2.15.80 \u0026gt; 10.0.2.2.51323: Flags [S.], seq 1893430205, ack 84689410, win 64240, options [mss 1460], length 0 第三次握手，标志位Flags=[.] IP 10.0.2.2.51323 \u0026gt; 10.0.2.15.80: Flags [.], ack 1893430206, win 65535, length 0 建立连接后，客户端发送http请求 IP 10.0.2.2.51321 \u0026gt; 10.0.2.15.80: Flags [P.], seq 1:753, ack 1, win 65535, length 752: HTTP: GET / HTTP/1.1 tcpdump命令解析一下： -i : 指定抓包的网卡是enp0s3 -n: 把域名转成IP显示 -t: 不显示时间 -S: 序列号使用绝对数值，不指定-S的话，序列号会使用相对的数值 port: 指定监听端口是80 host:指定监听的主机名\n我们看下实战中TCP的三次握手过程：\n第一次握手，客户端51323端口号向服务器端80号端口发起连接，此时标志位flags=S，即SYN=1标志，表示向服务端发起连接的请求，同时生成序列号seq=84689409 第二次握手，服务端标志位flags=[S.]，即SYN+ACK标志位设置为1，表示对上一个请求连接的报文进行确认，同时设置ack=seq+1=184689410，生成序列号seq=1893430205 第三次握手，客户端对服务端的响应进行确认，所以此时标志位是[.]即ACK=1，同时返回对上一个报文的seq的确认号，ack=1893430206 至此，三次握手完成，一个TCP连接建立完成，接下来就是双端传输数据了\n为什么需要三次握手？ 我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。\n本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。\n假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。\n所以，采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。\nTCP 三次握手跟现实生活中的人与人打电话是很类似的：\n三次握手： “喂，你听得到吗？” “我听得到呀，你听得到我吗？” “我能听到你，今天 balabala……”\n经过三次的互相确认，大家就会认为对方对听的到自己说话，并且愿意下一步沟通，否则，对话就不一定能正常下去了。\nTCP 四次挥手关闭连接 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。\n四次挥手过程的示意图如下： 挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：\n第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入FIN_WAIT_1状态，这表示Client端没有数据要发送给Server端了。 第二次分手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入FIN_WAIT_2状态，Server端告诉Client端，我确认并同意你的关闭请求。 第三次分手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入LAST_ACK状态。 第四次分手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入TIME_WAIT状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。 为什么连接的时候是三次握手，关闭的时候却是四次握手？ 建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。\n由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。 这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。 当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\n为什么要等待2MSL？ MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。 有以下两个原因：\n第一点：保证TCP协议的全双工连接能够可靠关闭： 由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于CLOESD状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入CLOSED状态，而要保持TIME_WAIT，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。 第二点：保证这次连接的重复数据段从网络中消失 如果Client端发送最后的ACK直接进入CLOSED状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。 五、DNS域名解析 1、域名系统概述 域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换成为IP地址。域名系统其实就是名字系统。为什么不叫“名字”而叫“域名”呢？这是因为在这种因特网的命名系统中使用了许多的“域(domain)”，因此就出现了“域名”这个名词。“域名系统”明确地指明这种系统是应用在因特网中。\n我们都知道，IP地址是由32位的二进制数字组成的。用户与因特网上某台主机通信时，显然不愿意使用很难记忆的长达32位的二进制主机地址。即使是点分十进制IP地址也并不太容易记忆。相反，大家愿意使用比较容易记忆的主机名字。但是，机器在处理IP数据报时，并不是使用域名而是使用IP地址。这是因为IP地址长度固定，而域名的长度不固定，机器处理起来比较困难。\n域名到IP地址的解析是由分布在因特网上的许多域名服务器程序共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为域名服务器。\n2、因特网的域名结构 由于因特网的用户数量较多，所以因特网在命名时采用的是层次树状结构的命名方法。任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名(domain name)。这里，“域”(domain)是名字空间中一个可被管理的划分。\n3、域名服务器 如果采用上述的树状结构，每一个节点都采用一个域名服务器，这样会使得域名服务器的数量太多，使域名服务器系统的运行效率降低。所以在DNS中，采用划分区的方法来解决。\n一个服务器所负责管辖(或有权限)的范围叫做区(zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机到域名IP地址的映射。总之，DNS服务器的管辖范围不是以“域”为单位，而是以“区”为单位。区是DNS服务器实际管辖的范围。区 \u0026lt;= 域。\n根域名服务器：最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助根域名服务器。所以根域名服务器是最重要的域名服务器。假定所有的根域名服务器都瘫痪了，那么整个DNS系统就无法工作。需要注意的是，在很多情况下，根域名服务器并不直接把待查询的域名直接解析出IP地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。\n顶级域名服务器：负责管理在该顶级域名服务器注册的二级域名。\n权限域名服务器：负责一个“区”的域名服务器。\n本地域名服务器：本地服务器不属于下图的域名服务器的层次结构，但是它对域名系统非常重要。当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。\n4、域名的解析过程 一、主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。\n二、本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。\n查询步骤：\n1、主机m.abc.com先向本地服务器dns.xyz.com进行递归查询。\n2、本地服务器采用迭代查询。它先向一个根域名服务器查询。\n3、根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。\n4、本地域名服务器向顶级域名服务器dns.com进行查询。\n5、顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。\n6、本地域名服务器向权限域名服务器dns.abc.com进行查询。\n7、权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。\n8、本地域名服务器最后把查询结果告诉m.xyz.com。\n整个查询过程共用到了8个UDP报文。\n为了提高DNS查询效率，并减轻服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n例如，在上面的查询过程中，如果在m.xyz.com的主机上不久前已经有用户查询过y.abc.com的IP地址，那么本地域名服务器就不必向根域名服务器重新查询y.abc.com的IP地址，而是直接把告诉缓存中存放的上次查询结果(即y.abc.com的IP地址)告诉用户。\n由于名字到地址的绑定并不经常改变，为保持告诉缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项(例如每个项目两天)。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。\n不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。\n1.1）域名与ip地址 （1）ip地址：ip地址是一个32位（4字节）的二进制数（IPV4）,常见格式为：192.168.1.101.IP地址是IP协议移动的一种统一的地址格式，为互联网上每一个网络和每一台主机分配一个逻辑地址. IPV4与IPV6的区别：IPv4 使用32位（4字节）地址，因此只有 4,294,967,296 个，但随着联网设备的增加，这些地址显然是不够用的，所以需要新的协议和更多的地址。IPv6 便是这个新的协议，IPV6有128位（8字节）地址，有2^128-1个地址，IPv6 的目的皆在解决 IPv4 枯竭的问题。 （2）域名：ip地址与域名是一对多的关系。一个ip地址可以对应多个域名，但是一个域名只有一个ip地址。ip地址是数字组成的，不方便记忆，所以有了域名。\n1.2）域名系统（DNS——Domain Name System） 域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。域名的最终指向是IP。 将主机名和域名转换为IP地址。（域名：www.qq.com-\u0026gt;119.147.15.13）\na)DNS本质 用于TCP/IP应用程序的数据库，该数据库中记录了域名和IP的对应关系，同时也是一种用于客户端和服务端通讯的应用层的计算机网络协议。\nb)域名的特点 1、分布式：将域名服务器分布式存储于不同计算机中，目前全球有13台根服务器 2、阶层式：域名格式采用分层结构，类似树状结构，一棵独立的DNS子树就是一个区域（zone），一个区域被委派了授权机构（唯一授权机构：网络信息中心NIC），该机构需搭建DNS服务区，记录该区域下的子域名和IP对应关系，并且该授权机构可以再委派该区域下的子区域的DNS系统，依此向下委派，形成阶梯式管理结构 3、建立缓存：当一个DNS服务器查询到域名和IP的映射关系后，会将该映射数据写入自己的缓存中，如果其他的主机再来询问相同的映射关系时，直接读取自己的缓存，而不需要再去询问其他服务器了\nc)一次请求域名解析过程 迭代查询（服务端）和递归查询（客户端）（区别：递归是查询者变化，迭代是查询者不变）\n以查询 zh.wikipedia.org 为例：\n输入域名\u0026quot;zh.wikipedia.org\u0026quot;，操作系统会先检查自己的本地hosts文件是否有这个网址映射关系。如果hosts没有这个域名的映射，则查询本地DNS解析器缓存。如果hosts与本地DNS服务器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器。 客户端发送查询报文\u0026quot;query zh.wikipedia.org\u0026quot;至DNS服务器，DNS服务器首先检查自身缓存，如果存在记录则直接返回结果。 如果记录老化或不存在，则： （1）DNS服务器向根域名服务器发送查询报文\u0026quot;query zh.wikipedia.org\u0026quot;，根域名服务器返回顶级域.org 的权威域名服务器地址。 （2）DNS服务器向 .org 域的权威域名服务器发送查询报文\u0026quot;query zh.wikipedia.org\u0026quot;，得到二级域.wikipedia.org 的权威域名服务器地址。 （3）DNS服务器向 .wikipedia.org 域的权威域名服务器发送查询报文\u0026quot;query zh.wikipedia.org\u0026quot;，得到主机 zh 的A记录，存入自身缓存并返回给客户端。\n1.3）以Chrome浏览器为例，Chrome解析域名对应的IP地址 Chrome浏览器会首先搜索浏览器自身的DNS缓存（可以使用 chrome://net-internals/#dns 来进行查看），浏览器自身的DNS缓存有效期比较短，且容纳有限，大概是1000条。如果自身的缓存中存在blog.csdn.net 对应的IP地址并且没有过期，则解析成功。 如果未找到，那么Chrome会搜索操作系统自身的DNS缓存（可以在命令行下使用 ipconfig /displaydns 查看）。如果找到且没有过期则成功。 如果未找到，那么尝试读取位于C:\\Windows\\System32\\drivers\\etc下的hosts文件，如果找到对应的IP地址则解析成功。 如果未找到，浏览器首先会找TCP/IP参数中设置的本地DNS服务器，并请求LDNS服务器来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。否则本地DNS服务器会请求根DNS服务器。 本地DNS会把请求发至13台根DNS，根DNS服务器会返回所查询域的主域名服务器的地址(.net)，本地DNS服务器使用该IP信息联系负责.net域的这台服务器。这台负责.net域的服务器收到请求后，会返回.net域的下一级DNS服务器地址(blog.csdn.net)给本地DNS服务器。以此类推，直至找到。\n六、HTTP协议 HTTP协议简介 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。\nHTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。\n2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。\nHTTP协议概述 HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。\n尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如\u0026quot;HTTP/1.1 200 OK\u0026quot;，以及返回的内容，如请求的文件、错误消息、或者其它信息。\nHTTP工作原理 HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n以下是 HTTP 请求/响应的步骤：\n\\1. 客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.baidu.com。\n\\2. 发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。\n\\3. 服务器接受请求并返回HTTP响应 Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。\n\\4. 释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;\n\\5. 客户端浏览器解析HTML内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。\n例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 释放 TCP连接; 浏览器将该 html 文本并显示内容; http协议是基于TCP/IP协议之上的应用层协议。\n基于 请求-响应 的模式\nHTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应\n无状态保存\nHTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。\n使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。有关Cookie的详细内容稍后讲解。\n无连接\n无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。\nHTTP请求方法 HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：\nGET 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。\nHEAD 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。\nPOST 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。\nPUT 向指定资源位置上传其最新内容。\nDELETE 请求服务器删除Request-URI所标识的资源。\nTRACE 回显服务器收到的请求，主要用于测试或诊断。\nOPTIONS 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用\u0026rsquo;*\u0026lsquo;来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\nCONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。\n注意事项：\n方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源*。* 请求方式: get与post请求（通过form表单我们自己写写看） GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以\u0026amp;相连，如EditBook?name=test1\u0026amp;id=123456.（请求头里面那个content-type做的这种参数形式，后面讲） POST方法是把提交的数据放在HTTP包的请求体中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET与POST请求在服务端获取请求数据方式不同，就是我们自己在服务端取请求数据的时候的方式不同了，这句废话昂。 HTTP状态码 所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。\n状态代码的第一个数字代表当前响应的类型：\n1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 虽然 RFC 2616 中已经推荐了描述状态的短语，例如\u0026quot;200 OK\u0026quot;，\u0026ldquo;404 Not Found\u0026rdquo;，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。\nURL\n超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：\n传送协议。 层级URL标记符号(为[//],固定不变) 访问资源需要的凭证信息（可省略） 服务器。（通常为域名，有时为IP地址） 端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略） 路径。（以“/”字符区别路径中的每一个目录名称） 查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“\u0026amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） 片段。以“#”字符为起点 以http://www.luffycity.com:80/news/index.html?id=250\u0026amp;page=1 为例, 其中：\nhttp，是协议； www.luffycity.com，是服务器； 80，是服务器上的默认网络端口号，默认不显示； /news/index.html，是路径（URI：直接定位到对应的资源）； ?id=250\u0026amp;page=1，是查询。 大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（www.luffycity.com:80/news/index.html?id=250\u0026amp;page=1）就可以了。\n由于超文本传输协议允许服务器将浏览器重定向到另一个网页地址，因此许多服务器允许用户省略网页地址中的部分，比如 www。从技术上来说这样省略后的网页地址实际上是一个不同的网页地址，浏览器本身无法决定这个新地址是否通，服务器必须完成重定向的任务。\nHTTP请求格式(请求协议) URL包含：/index/index2?a=1\u0026amp;b=2；路径和参数都在这里。\n请求头里面的内容举个例子：这个length表示请求体里面的数据长度，其他的请求头里面的这些键值对，陆续我们会讲的，大概知道一下就可以了，其中有一个user-agent，算是需要你记住的吧，就是告诉你的服务端，我是用什么给你发送的请求。\n以京东为例，看一下user-agent\n看一个爬虫的例子，爬京东的时候没问题，但是爬抽屉的时候必须带着user-agent，因为抽屉对user-agent做了判断，来判断你是不是一个正常的请求，算是反扒机制的一种。\n打开我们保存的demo.html文件，然后通过浏览器打开看看就能看到页面效果。\n写上面这些内容的意思是让你知道有这么个请求头的存在，有些是有意义的，请求头我们还可以自己定义，就在requests模块里面那个headers={}，这个字典里面加就行。\nHTTP响应格式（响应协议） 七、cookie，session，token的区别 Cookie cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。\ncookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。\nSession session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。\nsession 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。\n服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。\nToken 在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。\n以下几点特性会让你在程序中使用基于Token的身份验证\n无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们\n大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。\nToken的起源 在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。\n基于服务器的验证\n我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。\n在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。\n下图展示了基于服务器验证的原理\n随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。\n基于服务器验证方式暴露的一些问题\nSeesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 在这些问题中，可扩展行是最突出的。因此我们有必要去寻求一种更有行之有效的方法。\n基于Token的验证原理 基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。\n这种概念解决了在服务端存储信息时的许多问题\nNoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。\n基于Token的身份验证的过程如下:\n用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的token 给客户端。 客户端储存token,并且每次用于每次发送请求。 服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。\n实现思路：\n用户登录校验，校验成功后就返回Token给客户端。 客户端收到数据后保存在客户端 客户端每次访问API是携带Token到服务器端。 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。\n我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）\nTokens的优势 无状态、可扩展 在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。\n如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成\n一些拥堵。\n但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。\n安全性 请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。\ntoken是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。\n可扩展性 Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。\n使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。\n多平台跨域 我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。\nHaving our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.\n只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。\nAccess-Control-Allow-Origin: * 1 基于标准 创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。\n最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。\n八、Https原理及流程 我们知道，HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。\n密码学基础 在正式讲解HTTPS协议之前，我们首先要知道一些密码学的知识。\n明文： 明文指的是未被加密过的原始数据。 密文：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。 密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。\n对称加密：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。 其加密过程如下：明文 + 加密算法 + 私钥 =\u0026gt; 密文 解密过程如下： 密文 + 解密算法 + 私钥 =\u0026gt; 明文\n对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。 其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。\n非对称加密：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。 被公钥加密过的密文只能被私钥解密，过程如下： 明文 + 加密算法 + 公钥 =\u0026gt; 密文， 密文 + 解密算法 + 私钥 =\u0026gt; 明文 被私钥加密过的密文只能被公钥解密，过程如下： 明文 + 加密算法 + 私钥 =\u0026gt; 密文， 密文 + 解密算法 + 公钥 =\u0026gt; 明文\n由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。 非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。\nHTTPS通信过程 HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。\nSSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0\nTLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。\nHTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。\nHTTPS在传输的过程中会涉及到三个密钥：\n服务器端的公钥和私钥，用来进行非对称加密\n客户端生成的随机密钥，用来进行对称加密\n一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。 1.客户端向服务器发起HTTPS请求，连接到服务器的443端口\n2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。\n3.服务器将自己的公钥发送给客户端。\n4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。\n5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。\n6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。\n7.然后服务器将加密后的密文发送给客户端。\n8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。\n九、网络数据解析 TCP/IP协议数据包，一般由应用层、传输层、网络层、数据链路层封装而成。\n四层协议各自的作用：\n数据链路层实现了网卡接口的驱动程序。\n网络层实现了数据包的选路和转发。\n传输层为两台主机上的应用程序提供端到端（end to end）的通信。\n应用层负责处理应用程序的逻辑。\n#1、先封装的协议头是传输层，传输层有TCP、UDP、TLS 、DCCP 、SCTP 、RSVP 、PPTP，常用的有TCP，UDP\nTCP头的结构（tcp头总长度为 20个字节+options可选选项）\n（1）TCP源端口（Source Port）：16位的源端口包含初始化通信的端口号。源端口和IP地址的作用是标识报文的返回地址。\n（2）TCP目的端口（Destination Port）：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。\n（3）序列号（Sequence Number）：32位 TCP连线发送方向接收方的封包顺序号。\n（4）确认序号（Acknowledge Number）：32位 接收方回发的应答顺序号。\n（5）头长度（Header Length）：偏移量（4bit）和保留（4bit）总共8位 。 表示TCP头的双四字节数，如果转化为字节个数需要乘以4。\n（6）保留（2bit）和标记（6bit）总共8位。\n标记位：　URG：是否使用紧急指针，0为不使用，1为使用。\nACK：请求/应答状态。0为请求，1为应答。\nPSH：以最快的速度传输数据。　RST：连线复位，首先断开连接，然后重建。\nSYN：同步连线序号，用来建立连线。\nFIN：结束连线。如果FIN为0是结束连线请求，FIN为1表示结束连线。\n（7）窗口大小（Window）：16位 目的机使用16位的域告诉源主机，它想收到的每个TCP数据段大小。\n（8）校验和（Check Sum）：16位 这个校验和和IP的校验和有所不同，不仅对头数据进行校验还对封包内容校验。\n（9）紧急指针（Urgent Pointer）：16位 当URG为1的时候才有效。TCP的紧急方式是发送紧急数据的一种方式。\n（10）可选选项(options)24位，类似IP，是可选选项。填充8位，使选项凑足32位。\nUDP头的结构\n源端口（2字节） 目的端口（2字节） 封报长度（2字节） 校验和（2字节） 数据 （1）源端口（Source Port）：16位的源端口域包含初始化通信的端口号。源端口和IP地址的作用是标识报文的返回地址。\n（2）目的端口（Destination Port）：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。\n（3）封包长度（Length）：16位 UDP头和数据的总长度。\n（4）校验和（Check Sum）： 16位 和TCP和校验和一样，不仅对头数据进行校验，还对包的内容进行校验。\n#2、然后封装的是网络层，网络层主要是IP协议，还有ICMP协议，IGMP协议等** IP协议头（ip头总长度根据IP头的头长来计算。一般IP没有可选选项，长度为20字节，也就是对应头长等于5）：\n1-1.版本4位，表示版本号，目前最广泛的是4=B1000，即常说的IPv4；相信IPv6以后会广泛应用，它能给世界上每个纽扣都分配\n​ 一个IP地址。\n**1-2.**头长4位，数据包头部长度。它表示数据包头部包括多少个32位长整型，也就是多少个4字节的数据。无选项则为5（红色部分）。\n这个字段表示了IP头部的总长度，但它不是直接表示，因为它只占了4比特，最大也就15，实际的IP头部长度等于首部长度字段表示的 值乘以4，单位是字节，也就是首部最长为15×4＝60字节，一般IP数据报首部都没有选择项，长度为20字节，也就是对应头长等于5。\n1-3.服务类型，包括8个二进制位，每个位的意义如下：\n​ 过程字段：3位，设置了数据包的重要性，取值越大数据越重要，取值范围为：0（正常）~ 7（网络控制）\n​ 延迟字段：1位，取值：0（正常）、1（期特低的延迟）\n​ 流量字段：1位，取值：0（正常）、1（期特高的流量）\n​ 可靠性字段：1位，取值：0（正常）、1（期特高的可靠性）\n​ 成本字段：1位，取值：0（正常）、1（期特最小成本）\n​ 保留字段：1位 ，未使用\n1-4.包裹总长16位，当前数据包的总长度，单位是字节。当然最大只能是65535，及64KB。\n2-1.重组标识16位，发送主机赋予的标识，以便接收方进行分片重组。\n2-2.标志3位，他们各自的意义如下：\n​ 保留段位(2)：1位，未使用\n​ 不分段位(1)：1位，取值：0（允许数据报分段）、1（数据报不能分段）\n​ 更多段位(0)：1位，取值：0（数据包后面没有包，该包为最后的包）、1（数据包后面有更多的包）\n2-3.段偏移量13位，与更多段位组合，帮助接收方组合分段的报文，以字节为单位。\n3-1.生存时间8位，经常ping命令看到的TTL（Time To Live）就是这个，每经过一个路由器，该值就减一，到零丢弃。\n3-2.协议代码8位，表明使用该包裹的上层协议，如TCP=6，ICMP=1，UDP=17等。\n**3-3.**头检验和16位，是IPv4数据包头部的校验和。由发送端填充，接收端对其使用CRC算法检验IP数据报头部在传输过程中是否损坏。\n4-1.源始地址，32位4字节，我们常看到的IP是将每个字节用点（.）分开，如此而已。\n5-1.目的地址，32位，同上。\n6-1.可选选项，主要是给一些特殊的情况使用，往往安全路由会当作攻击而过滤掉，普联（TP_LINK）的TL-ER5110路由就能这么做。\n*ICMP协议头*\nICMP报文就像是IP报文的小弟，总顶着IP报文的名头出来混。因为ICMP报文是在IP报文内部的：\nICMP所有报文的前4个字节都是一样的，但是剩下的其他字节不相同。\n前四个字节统一的格式：类型（8位），代码（8位），校验和（16位）\n类型和代码决定了ICMP报文的类型。常见的有：\n类型8， 代码0 ==\u0026gt; 表示回显请求（ping请求）\n类型0， 代码0 ==\u0026gt; 表示回显应答（ping应答）\n类型11，代码0 ==\u0026gt; 超时\n检验和字段：包括数据在内的整个ICMP数据包的检验和；其计算方法和IP头部检验和的计算方法一样的。\nICMP报文具体分为查询报文和差错报文(对ICMP差错报文有时需要做特殊处理，因此要对其进行区分。如：对ICMP差错报文进行响应时，永远不会生成另一份ICMP差错报文，否则会出现死循环)\n#3、最后封装的是数据链路层，即以太网头和FCS\n**以太网头（总长度为14个字节）**是由 6字节的目的MAC地址 + 6字节的源MAC地址 + 2字节的类型 组成。\n以太的各种类型：\n以太类型 协议 0x0800 Internet协议版本4（IPv4） 0x0806 地址解析协议（ARP） 0x8035 反向地址解析协议（RARP） 三个数值 AppleTalk（Ethertalk） 0x80f3 AppleTalk地址解析协议（AARP） 为0x8100 IEEE 802.1Q标签帧 三个数值 Novell IPX（alt） 0x8138 Novell公司 0x86DD Internet协议版本6（IPv6） 0x8819 CobraNet技术 0x88a8 提供商桥接（IEEE 802.1ad） 0x8847 MPLS单播 0x8848 MPLS多播 0x8863 PPPoE发现阶段 0x8864 PPPoE会话阶段 0x888E EAP over LAN（IEEE 802.1X） 0x889A HyperSCSI（以太网SCSI） 0x88A2 以太网ATA 0x88A4 EtherCAT协议 0x88CD SERCOS-III 0x88D8 以太网电路仿真服务（MEF-8） 0x88E5 MAC安全（IEEE 802.1AE） 0x8906 以太网光纤通道 0x8914 FCoE初始化协议 0x9100 Q-in-Q的 0xCAFE Veritas低延迟传输（LLT） 在不定长的数据字段(以太网头后面的数据)后是4个字节的帧校验序列(FCS)\n","date":"2021-07-15T00:00:00Z","permalink":"https://haolovelin.com/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络"},{"content":"近日在b站看到了一个视频，名为《勿忘国耻不是你贩卖仇恨的理由（无删版）》，该视频的up主自认为站在理中客的视角看待问题，但实际上个人觉得他是有双标的倾向，出于礼貌，我从头到尾把他的这个视频看完了，原本以为是能够站在一个客观的角度看问题发表自己的高论，但事实上有些论据其实是经不起推敲，由于对他视频中的大部分言论表示不认同，特此想礼貌地驳一下他的言论以及论据。\n先说说他的视频封面，他用食指指着镜头，俨然一副想增加自己的威信，要对众人说教的样子。\n首先在开篇0:35秒的时候，他说之前看了另一名up主的视频，说出了：“就因为日本在搞小动作，这位大佬（指另一名up主）就义愤填膺说咱们中国不能够再拿热脸贴别人的冷屁股了，同时呼吁大家放弃幻想，准备打仗，瞬间，屏幕上黑压压的全都是点赞，隔着屏幕我好像也能感受到深深的浓浓的硝烟\u0026hellip;\u0026hellip;” 以上是他的原话。\n不知道我的理解是不是有问题，先根据一开始的那三个字，“就因为”这个词用出来，我就感觉他用词不当，日本搞的动作，而且还是针对中国的动作，虽然不知道他说的”小动作“，这个“小”是怎么定义的，但是他用这个词，去评判另一位up主的“咱们中国不能够再拿热脸贴别人的冷屁股了”这个呼吁，他这样的评判就很有问题，日本如果都胆敢欺负到我们头上了，我们难道还得笑脸相迎？而且我对日本本来就没什么好感，先不说其他的，就单论之前排放核废水这一行为，我相信是个正常地球人都会讨厌这个反人类的国家，更别说，那段历史，那段国耻应该是刻在每一个中国人的心中的，首先我们就不能忘记仇恨。然后他说另一位up主“呼吁大家放弃幻想，准备打仗”，我不清楚这句话是不是他本人曲解了另一位up的意思（这个由于我不知道他说的那位up是谁，因为他没有贴出来另一位up的视频链接，也没有指明他看到的是哪位up的哪个视频，我没有办法实际去调查他说的那个大佬说的话，所以对于他口中说的那位大佬的言论的正确性，我是没有发言权的，这一点我在此只提出，此处就不算是驳他的点）但是声明一点，这句话更多被传播的版本是：“丢掉幻想，准备斗争”。此话出自于《毛选》第四卷的同名文章《丢掉幻想，准备斗争》是我们伟大的教员运用历史唯物主义观点，对中国革命的胜利的原因作了理论上的说明，深刻揭露了美国对华政策的帝国主义本质，批评了国内一部分资产阶级知识分子对于美国帝国主义的幻想，告诫人们战斗，继续战斗，直到完全胜利。这个“斗争”可不是指打仗，这个既不是宣传战争，更不是贩卖仇恨，这句话是让我们保持独立自主，不要幻想着依靠他国的力量，也不要幻想着博得别国的怜悯来求生存发展，自身的强大才是最重要的。如果是大家都对“丢掉幻想，准备斗争”这句话有同感，那绝对是一件好事情，因为我知道，铭记历史，准备斗争，不断使自己变得强大才是正道，如果每个人都这么有觉悟，那无论是谁，都必然是阻挡不了我们中华民族伟大复兴的历史进程的。\n然后，这位up先是举了外国人仇视中国人的例子，然后他提出自己的疑问，说这个问题在于这些外国人仇视中国人的例子的数据是可靠的吗？是不是列强一有动作，我们就草木皆兵地动员打仗？他还举了美国军机过来侦察然后民众总有几个挑事说要打仗的、特别喜欢拉仇恨。然后他假设了我们盲目排外以及闭关锁国之后会发生落后的假设，他假设我们强大以后可能去胡作非为，把列强都欺负一遍、他举了个十几年前就已经被公知广泛流传的反面例子——”日本右翼的关于中国人素质差的调查、中国人让日本人在礼仪方面打了0分”，最后这位up来个反转说自己举的这个是反面例子，是日本右翼误导的结果、他说要警惕法西斯的幼虫，如果不趁早灭了他们，将来他们一旦得势，搞不好我们中国也会成为帝国主义\u0026hellip;\u0026hellip;看完视频，从头到尾，他的言论唯一能让我认同的一句话是，珍惜和平、维护和平是强大起来的中国应尽的义务，珍惜眼前的和平。\n我们来一个一个点地反驳，首先，他质疑其他up所说的大多数外国人仇视中国人的例子，然后后面他说他去网上搜索了，没有可靠的证据证明，所以这位up明显没有使用科学上网的手段，因此他也只能搜到很少的数据，那么就论某外国社交平台推特，那上面占据很大部分的仇中言论，难道只是一些机器人水军吗？他无法证明数据是可靠的，但也不说明这就是不可靠的，无法证伪的东西很多，但那不一定就是事实，而且很多事情，不是非黑即白的，我们不能走到任何一个极端，就事论事，如果真有那么多人仇视我们，我们难道还要笑脸相迎吗？显然是不行的，如果大家都欢迎我们，友好相处，那我们肯定就世界人民大团结啊，我这个说法没毛病吧？正所谓，朋友来了有美酒，豺狼来了有猎枪。\n其次，什么叫做列强一有动作，我们就草木皆兵动员打仗？我没穿越吧，现在是2021年，如果大国之间发生战争，出动的肯定是军队，而军队是我们伟大的党来领导的，岂能是我们动员就可以打起来的，单凭一个up的言论，就能主导战争？川建国都不敢这么整。而且真要打仗的时候，肯定是我们国家的利益、人民的利益严重受到侵害，才会全国动员打起来，最后，我们普通人怎么打？枪都没有，我们难道动员大家拿着菜刀上战场？而且按照这位up假设的，假设，如果真的是我们挑起战争，那么首先我们得打过去吧？战场得在日本吧？我们普通人游泳穿过太平洋吗\u0026hellip;\u0026hellip;那还是别了，我们没游到就被核废水淹死了，emmm\u0026hellip;我懂了，这波日本是在大气层，排核废水是利用太平洋建造生化防御体系（误），其次，真到了发动战争的时候，东风快递可不是闹着玩的，钱学森弹道加持打过去，真的轮得到我们人民群众来动员和发动力量吗？可别小瞧了真理的力量。\n他说民众总有几个挑事说要打仗的、特别喜欢拉仇恨。那确实是，十四万万的中国人，什么样的人没有？卖国贼、公知、汉奸都有不少呢，挑事的肯定也存在的，但我相信大部分的人民群众都是好人，看全民抗疫就很清楚这一点，而坏人总是想伪装自己藏在人民之间，但是我们可不是坏人糊弄几下就能被煽动的，我相信大部分人还是很理性的，哪怕有不理性的人，也不可能能够影响到我们的党，不可能把大部分人都煽动起来，更不可能使法西斯主义复苏，我认为防患于未然是可以的，但是不能不从实际出发设想后果。\n然后他说到盲目排外，盲目排外会导致闭关锁国而落后，我想问个问题，我们现在有盲目排外吗？我们现在可还有不少崇拜西方的呢，近几年加上去年疫情才慢慢增强了中华民族的民族自信，我们才刚开始在认清公知的面目，中国人重新自信起来，还远远没到盲目排外的情况，而且伟大的导师告诉过我们战略上藐视敌人，战术上重视敌人，在一百多年前刚吃过这么大亏的中国，按目前来看，可远远不会出现盲目自大的行为，甚至，我们还需要逐渐壮大我们的文化自信、民族自信，还需要发展自身的实力。盲目排外这种情况，即使是极个别的人允许，我们大多数人民群众也不会同意的。\n这位up还假设我们强大以后可能去胡作非为，把列强都欺负一遍，这种观点简直滑稽，我们中国自古以来就是礼仪之邦，就连古代那封建时期，都是友好对待外邦的，至于他说搞侵略、搞殖民、欺负别国的事情，那是西方国家所擅长的，中国从来不会欺负别人，我们中国走的是社会主义道路，要为共产主义事业一直奋斗，天安门上写着什么？是“中华人民共和国万岁，世界人民大团结万岁”，就在1953年，我们伟大的周总理就已经在外交方面完整提出了和平共处五项原则，我们的党不会允许我们的国家去欺负别的国家，我们还主导一带一路，带动别国发展，这样的国家，他假设我们强大后去胡作非为？我们可不是某个灯塔国，不会干这种事情。\n还有就是那个说中国人不文明的例子，这个例子最早可以追溯到我小学的时候吧，典型的公知双标言论，妄图用这样的言论来打击我们，让我们抬不起头，虽然也有教育的批判作用，虽然有一点是对的，不文明的行为确实需要纠正，但是这样的说法，只说明了个例的现象，然后用个例来代表整体中国人真的合适吗？而且这样的言论只说我们国家有，不说别国也会有这样的人，虽然这位up最后说明了他的这个举例是个反面例子，批了一下日本右翼分子，但是有时候我建议，表达观点能够先表明立场，不然我差点被这位up的这个例子气到。\n最后他说的中国搞不好会成为帝国主义就更是无稽之谈了，帝国主义的苗头，在中国是不可能存在的，原因我上面也说过了，如果有人认为这个世界有存在帝国主义，那请他先看一下远在大洋彼岸的某个国家，再对比一下，有时候假设也要结合实际，否则是站不住脚的。\n到结尾了，说说我认同的一个观点，珍惜和平、维护和平是强大起来的中国应尽的义务，我们要珍惜眼前的和平，但他的大部分言论和论据，我是不接受的，我不清楚这位up到底是不清楚很多言论只是网友们的口嗨，然后他当真了，还是本来就另有所图，我希望他只是前者，因此今天只是就他的言论来驳一下他。而现实中对于日本这个国家和它的人民的态度，往往是根据对方采取的态度和行动来决定的，我相信大多数人都是爱好和平的，但如果别人不愿意友善对待我们，那我们也将会收起我们的友善，因为他们不配。我们要铭记历史，我们不盲目去仇恨，但是我们必须记住国耻。放弃幻想，准备斗争是没错的，而这个过程中，我们每个普通人应该做的，就是要为自己、为家人、为国家发展做贡献，创造自己的价值，不为别人的怂恿煽动所感染，脚踏实地、做好自己。\n","date":"2021-07-05T00:00:00Z","permalink":"https://haolovelin.com/post/%E5%8B%BF%E5%BF%98%E5%9B%BD%E8%80%BB%E4%B8%8D%E7%AD%89%E5%90%8C%E4%BA%8E%E8%B4%A9%E5%8D%96%E4%BB%87%E6%81%A8/","title":"勿忘国耻不等同于贩卖仇恨"},{"content":"青年在选择职业时的考虑 卡·马克思的中学考试德语作文 自然本身给动物规定了它应该遵守的活动范围，动物也就安分地在这个范围内活动，而不试图越出这个范围，甚至不考虑有其它范围存在。神也给人指定了共同的目标──使人类和他自己趋于高尚，但是，神要人自己去寻找可以达到这个目标的手段；神让人在社会上选择一个最适合于他、最能使他和社会变得高尚的地位。 这种选择是人比其它创造物远为优越的地方，但同时也是可能毁灭人的一生、破坏他的一切计划并使他陷于不幸的行为。因此，认真地权衡这种选择，无疑是开始走上生活道路而又不愿在最重要的事情上听天由命的青年的首要责任。 每个人眼前都有一个目标，这个目标至少在他本人看来是伟大的，而且如果最深刻的信念，即内心深处的声音，认为这个目标是伟大的，那它实际上也是伟大的，因为神决不会使世人完全没有引导者；神轻声地但坚定地作启示。 但是，这声音很容易被淹没；我们认为是热情的东西可能倏忽而生，同样可能倏忽而逝。也许，我们的幻想蓦然迸发，我们的感情激动起来，我们的眼前浮想联翩，我们狂热地追求我们以为是神本身给我们指出的目标；但是，我们梦寐以求的东西很快就使我们厌恶，于是，我们便感到自己的整个存在遭到了毁灭。 因此，我们应当认真考虑：我们对所选择的职业是不是真的怀有热情？发自我们内心的声音是不是同意选择这种职业？我们的热情是不是一种迷误？我们认为是神的召唤的东西是不是一种自我欺骗？不过，如果不对热情的来源本身加以探究，我们又怎么能认清这一切呢？ 伟大的东西是闪光的，闪光会激发虚荣心，虚荣心容易使人产生热情或者一种我们觉得是热情的东西；但是，被名利迷住了心窍的人，理性是无法加以约束的，于是他一头栽进那不可抗拒的欲念召唤他去的地方；他的职业已经不再是由他自己选择，而是由偶然机会和假象去决定了。 我们的使命决不是求得一个最足以炫耀的职业，因为它不是那种可能由我们长期从事，但始终不会使我们感到厌倦、始终不会使我们劲头低落、始终不会使我们的热情冷却的职业，相反，我们很快就会觉得，我们的愿望没有得到满足，我们的理想没有实现，我们就将怨天尤人。 但是，不仅虚荣心能够引起对某种职业的突然的热情，而且我们也许会用自己的幻想把这种职业美化，把它美化成生活所能提供的至高无上的东西。我们没有仔细分析它，没有衡量它的全部分量，即它加在我们肩上的重大责任；我们只是从远处观察它，而从远处观察是靠不住的。 在这里，我们自己的理性不能给我们充当顾问，因为当它被感情欺骗，受幻想蒙蔽时，它既不依靠经验，也不依靠更深入的观察。然而，我们的目光应该投向谁呢？当我们丧失理性的时候，谁来支持我们呢？ 是我们的父母，他们走过了漫长的生活道路，饱尝了人世辛酸。──我们的心这样提醒我们。 如果我们经过冷静的考察，认清了所选择的职业的全部分量，了解它的困难以后，仍然对它充满热情，仍然爱它，觉得自己适合于它，那时我们就可以选择它，那时我们既不会受热情的欺骗，也不会仓促从事。 但是，我们并不总是能够选择我们自认为适合的职业；我们在社会上的关系，还在我们有能力决定它们以前就已经在某种程度上开始确立了。 我们的体质常常威胁我们，可是任何人也不敢藐视它的权利。 诚然，我们能够超越体质的限制，但这么一来，我们也就垮得更快；在这种情况下，我们就是冒险把大厦建筑在残破的废墟上，我们的一生也就变成一场精神原则和肉体原则之间的不幸的斗争。但是，一个不能克服自身相互斗争的因素的人，又怎能抗御生活的猛烈冲击，怎能安静地从事活动呢？然而只有从安静中才能产生出伟大壮丽的事业，安静是唯一能生长出成熟果实的土壤。 尽管我们由于体质不适合我们的职业，不能持久地工作，而且很少能够愉快地工作，但是，为了克尽职守而牺牲自己幸福的思想激励着我们不顾体弱去努力工作。如果我们选择了力不胜任的职业，那么我们决不能把它做好，我们很快就会自愧无能，就会感到自己是无用的人，是不能完成自己使命的社会成员。由此产生的最自然的结果就是自卑。还有比这更痛苦的感情吗？还有比这更难于靠外界的各种赐予来补偿的感情吗？自卑是一条毒蛇，它无尽无休地搅扰、啃啮我们的胸膛，吮吸我们心中滋润生命的血液，注入厌世和绝望的毒液。 如果我们错误地估计了自己的能力，以为能够胜任经过较为仔细的考虑而选定的职业，那么这种错误将使我们受到惩罚。即使不受到外界的指责，我们也会感到比外界指责更为可怕的痛苦。 如果我们把这一切都考虑过了，如果我们的生活条件容许我们选择任何一种职业，那么我们就可以选择一种使我们获得最高尊严的职业，一种建立在我们深信其正确的思想上的职业，一种能给我们提供最广阔的场所来为人类工作，并使我们自己不断接近共同目标即臻于完美境界的职业，而对于这个共同目标来说，任何职业都只不过是一种手段。 尊严是最能使人高尚、使他的活动和他的一切努力具有更加崇高品质的东西，是使他无可非议、受到众人钦佩并高出于众人之上的东西。 但是，能给人以尊严的只有这样的职业，在从事这种职业时我们不是作为奴隶般的工具，而是在自己的领域内独立地进行创造；这种职业不需要有不体面的行动（哪怕只是表面上不体面的行动），甚至最优秀的人物也会怀着崇高的自豪感去从事它。最合乎这些要求的职业，并不总是最高的职业，但往往是最可取的职业。 但是，正如有失尊严的职业会贬低我们一样，那种建立在我们后来认为是错误的思想上的职业也一定会成为我们的沉重负担。 这里，我们除了自我欺骗，别无解救办法，而让人自我欺骗的解救办法是多么令人失望啊！ 那些主要不是干预生活本身，而是从事抽象真理的研究的职业，对于还没有确立坚定的原则和牢固的、不可动摇的信念的青年是最危险的，当然，如果这些职业在我们心里深深地扎下了根，如果我们能够为它们的主导思想而牺牲生命、竭尽全力，这些职业看来还是最高尚的。 这些职业能够使具有合适才干的人幸福，但是也会使那些不经考虑、凭一时冲动而贸然从事的人毁灭。 相反，重视作为我们职业的基础的思想，会使我们在社会上占有较高的地位，提高我们自己的尊严，使我们的行为不可动摇。 一个选择了自己所珍视的职业的人，一想到他可能不称职时就会战战兢兢──这种人单是因为他在社会上所处的地位是高尚的，他也就会使自己的行为保持高尚。 在选择职业时，我们应该遵守的主要指针是人类的幸福和我们自身的完美。不应认为，这两种利益会彼此敌对、互相冲突，一种利益必定消灭另一种利益；相反，人的本性是这样的：人只有为同时代人的完美、为他们的幸福而工作，自己才能达到完美。 如果一个人只为自己劳动，他也许能够成为著名的学者、伟大的哲人、卓越的诗人，然而他永远不能成为完美的、真正伟大的人物。 历史把那些为共同目标工作因而自己变得高尚的人称为最伟大的人物；经验赞美那些为大多数人带来幸福的人是最幸福的人；宗教本身也教诲我们，人人敬仰的典范，就曾为人类而牺牲自己──有谁敢否定这类教诲呢？ 如果我们选择了最能为人类而工作的职业，那么，重担就不能把我们压倒，因为这是为大家作出的牺牲；那时我们所享受的就不是可怜的、有限的、自私的乐趣，我们的幸福将属于千百万人，我们的事业将悄然无声地存在下去，但是它会永远发挥作用，而面对我们的骨灰，高尚的人们将洒下热泪。\n卡·马克思写于1835年8月\n","date":"2021-07-01T00:00:00Z","permalink":"https://haolovelin.com/post/%E8%AF%BB%E9%9D%92%E5%B9%B4%E5%9C%A8%E9%80%89%E6%8B%A9%E8%81%8C%E4%B8%9A%E6%97%B6%E7%9A%84%E8%80%83%E8%99%91/","title":"读《青年在选择职业时的考虑》"},{"content":"近来很通行说青年；开口青年，闭口也是青年。但青年又何能一概而论？有醒着的，有睡着的，有昏着的，有躺着的，有玩着的，此外还多。但是，自然也有要前进的。\n要前进的青年们大抵想寻求一个导师。然而我敢说：他们将永远寻不到。寻不到倒是运气；自知的谢不敏，自许的果真识路么？凡自以为识路者，总过了“而立”之年，灰色可掬了，老态可掬了，圆稳而已，自己却误以为识路。假如真识路，自己就早进向他的目标，何至于还在做导师。说佛法的和尚，卖仙药的道士，将来都与白骨是“一丘之貉”，人们现在却向他听生西的大法，求上升的真传，岂不可笑！\n但是我并非敢将这些人一切抹杀；和他们随便谈谈，是可以的。说话的也不过能说话，弄笔的也不过能弄笔；别人如果希望他打拳，则是自己错。他如果能打拳，早已打拳了，但那时，别人大概又要希望他翻筋斗。\n青年又何须寻那挂着金字招牌的导师呢？不如寻朋友，联合起来，同向着似乎可以生存的方向走。你们所多的是生力，遇见深林，可以辟成平地的，遇见旷野，可以栽种树木的，遇见沙漠，可以开掘井泉的。问什么荆棘塞途的老路，寻什么乌烟瘴气的鸟导师！\n——鲁迅《华盖集·导师》\n","date":"2021-06-29T00:00:00Z","permalink":"https://haolovelin.com/post/%E5%8D%8E%E7%9B%96%E9%9B%86%E5%AF%BC%E5%B8%88%E6%AE%B5%E8%90%BD%E6%91%98%E5%BD%95/","title":"《华盖集·导师》段落摘录"},{"content":"我要做一个什么样的人？这是一个我曾经思考了很久的问题，读完毛选的第一卷之后，现在已隐约找到了答案。\n要回答这个问题，我首先问了自己，我最向往成为什么样的人？因为只要我弄清楚了这个答案，那我就知道我要做一个什么样的人了。我脑海里闪过很多思绪，我细想了一下，从小到大，我所向往的事物有哪些。\n自我记事以来，在小学时期，被问到过一个几乎每个人都会被问的问题，“你长大后想干什么？”。依稀记得，当时的我的答案是：“宇航员”。不为什么，因为当时杨利伟叔叔很出名，那时的我觉得如果能当上宇航员，那一定倍有面子。儿时的想法很稚嫩，倒也很纯粹，虽然现在走上了程序员的道路，几乎绕不到儿时的梦想上了，但我知道，那其实不能算是梦想，毕竟那只是自己羡慕名人的荣誉罢了。\n在初中时期，由于看到了同班同学都有各自的手机，有些人的手机还很牛逼，是他的爸爸买的。那时最好的手机是诺基亚的塞班系统手机，而我自己拿着一个打开3g门户都卡的翻盖机，偷菜都比别人慢一步，上网刷个网页等半天，所以那个时期，我特别羡慕班里的小土豪，毕竟我家其实很一般，买不起那所谓的智能手机，因此在那个时期，我长大后想当个有钱人，把一切自己想买的东西都买回家。\n在高中时期，因为阅历的增长以及对历史有了进一步的了解（虽然历史考不高分），那时的我记住了老师说的至今都还记得很清楚的一句话：“落后就要挨打”，在通过书本和老师言传，了解了两弹一星的共和国伟人们的事迹之后，我对这些伟大的科学家们有了崇高的敬意，他们主动放弃优渥的条件，只愿投身建设祖国，哪怕那个过程可能会让自己隐姓埋名一辈子也无所谓，多亏受到了他们事迹的影响，我决心要当一名科学家，再明确点，是想当像钱老、邓老那样的物理学家，所以中学时期，我对物理近乎着迷，单论物理成绩确实是一直占据榜首的。最终高考填志愿，我不论哪个学校，第一志愿始终是物理学，但是由于坡脚，物理学没上。最后误打误撞上了个软件工程，算是近几年跟着计算机的大热卷起来的专业。\n到了大学时期，由于自身没啥计算机基础，自己一时适应不了，学业方面有所怠惰，加上18年都未离开家人，接触到新环境，还是自身有所松懈吧，那个时期直播行业刚刚兴起，自身又打游戏，看着龙头游戏主播一天能收到好几万甚至几十上百万的礼物，一下子感觉这个世界不真实了起来，而且很是羡慕，于是还想成为那样的人，虽然后面才知道，只有头部会如此光鲜，而且那些所谓的礼物，内幕有多少水分甚至很可能是主播加上平台一起割韭菜都不得而知。\n大学毕业后，听闻同届优秀毕业生进了福报厂，年薪60多w，约等于1/3个爽，煞是羡慕之极，于是，我想成为一个大厂程序员，拿着高薪待遇和收获大厂光环。但是自己由于大学的懈怠和不适应，起点是远远不及的，因此，工作时开始努力追赶和拼搏，下班后不断积累，在此期间，命运的红线缠绕了过来，让我更加静下心来，踏实学习了起来，所幸，自己还是有一定的悟性，那些以前看不懂的，惧怕的，看不下的专业知识，一下子看得沉迷其中了，在上一家公司积累了一年零四个月，我感觉准备得差不多了，于是跳往了现在这个相对来说还可以的平台，一个二线互联网公司，薪资翻了一番，虽然还差一半，但是看上去，年薪60w也不是特别难了。\n然后就是又工作了大半年后，在新公司经历了半年多的大小周工作，我开始知道，其实互联网行业的高薪，是有代价的，福报厂给的工资，是因为它剥削了你的剩余价值，因此稍微给你一点补偿，在上个阶段，我以为高薪就是一切，但看了并夕夕员工猝死的事件，我又有一种难以名状的感觉，虽然自己没那么夸张，但是前段时间在看完《觉醒年代》之后，我认为，996、007是社会之毒瘤，而不工作，人是无法创造价值的，这样子也不行，所以八小时工作制，才是幸福的，既奉献社会，又拥有充足的时间休息，还能有自己的时间去生活，可以闻闻花香，用于思考和学习，于是，我想先暂时卧薪尝胆提升自我，而后能力足够了，去做一个能兼顾工作和生活，正常作息的人。\n如今，在读完毛选第一卷之后，感叹教员之伟大的同时，我才真正地理解到，什么叫做从群众中来，到群众中去，我更加明确了自己的目标，我要在上面的：能兼顾工作和生活，正常作息的人基础上，尽可能地像教员学习，学习他不断阅读，增长自身知识，努力提升自己，学习他的思想，武装自己的灵魂，让自己不再迷茫，学习他不服输，敢于自我批评和自我修正，学习他实事求是，防止教条主义，学习他理论联系实际，亲身实践，实践了才有发言权，学习他走群众路线，认识到不同的人有不同的难处，尝试理解他人，学习他独立自主，学习他看问题重点抓主要矛盾，也不可完全忽视次要矛盾，还要学习他强身健体，他倡导人人体育锻炼，青年人应该是强健的而非体弱的。综上，我希望我可以成为他，我要做这样的人，一个光辉的理想主义者，他虽然不是神，但是吾辈向往之，若不能至，也要一步一步踏实地走，一直向着他靠近。\n最后引用鲁迅先生的话：\n愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。\n——鲁迅\n","date":"2021-06-29T00:00:00Z","permalink":"https://haolovelin.com/post/%E6%88%91%E8%A6%81%E5%81%9A%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/","title":"我要做一个什么样的人"},{"content":"《卜算子·咏梅》 风雨送春归，飞雪迎春到。已是悬崖百丈冰，犹有花枝俏。\n俏也不争春，只把春来报。待到山花烂漫时，她在丛中笑。\n感悟：想起小时候读这首词，只记得此词易于记忆，而且当时的感觉是没有特别惊艳到我，如今经历了社会，不久前读了毛选，重读此词，查了此词之背景，顿感教员之伟大，是我从前肤浅了，此词的基调是乐观的，不像一般写梅花的词如陆游的《卜算子·咏梅》是以悲为基调的，一般来说哀调相对于喜调，更容易唤起读者的共情，教员的词不仅是喜调，还刻画了一种在困境奋斗之乐观精神，以及不争春、只把春来报的奉献精神，最终书写了山花烂漫的美好愿景，这与当时的创作背景是符合的。无法不感叹教员之伟大，今记录于此，望自己一直向教员学习，不断向他靠近。\n此词的创作背景： 1960年6月，在罗马尼亚首都布加勒斯特召开共产党和工人党代表会议，苏共代表团和中共代表团发生激烈争论。会后，苏联撤走在华的全部专家，撕毁几百个协定和合同，停止供应重要设备。当时，以美国为首的西方国家一直对华经济封锁。苏联的严重措施，实际上断绝了中国从国外获取先进技术装备的正常渠道。与此同时，中国正处在三年困难时期，正经历着前所未有的严峻考验。在严重困难面前，毛泽东始终保持着中华民族大无畏的气概顶住了大国沙文主义的压カ。中国人民独立自主、自力更生的精神、赢得了普遍的赞誉。 1961年12月，毛泽东在广州，为即将召开的中共中央扩大的工作会议做准备。他读了陆游的《卜算子·咏梅》，感到文辞好；但意志消沉，只可借其形，不可用其义，于是他再续一首与陆游的词风格不同的咏梅词，目的主要是鼓励大家蔑视困难，敢于战胜困难。此词最早发表于1963年12月人民文学出版社出版的《毛主席诗词》。 ","date":"2021-06-28T00:00:00Z","permalink":"https://haolovelin.com/post/%E9%87%8D%E8%AF%BB%E6%AF%9B%E6%B3%BD%E4%B8%9C%E8%AF%97%E8%AF%8D%E6%9C%89%E6%84%9F/","title":"重读毛泽东诗词有感"},{"content":"近日来，互联网上出现了许多“躺平”相关的言论，一时间，这个词语被广泛议论，个人也想表达一下自己的看法。\n在表明我的立场之前，我想先谈谈自己对躺平的理解。首先说说这个词语爆火的原因，作为一个靠打工来领工资生活的劳动人民，个人认为一是广大的劳动人民长期受到畸形工作时长（996、007现象）压迫，而且被各种无意义的行业内卷（被自愿群体恶性加班，即使下班后也不敢早走，早走像是个异类的现象）挤压了劳动人民心中的幸福感，而且房价被炒得日益高涨但是工资并没有相应地涨起来，反倒是工作时长被迫增加，而面对这些导致自身幸福感下降的大环境，我们希望以一种方式去表达内心的抗拒，并以此去和资本家抗争，而采取的方式就是我所理解躺平，因此我所理解的躺平，本质上应该是：需要去和资本或者资本家对抗，需要去和被炒起来的房价对抗，需要促进自身薪资涨幅，而且需要加上最重要的一点，能够提升自身的幸福感的方式。\n那么明确了我所理解的躺平的本质之后，我是非常赞同这样的方式的，但是近来，有不少来自一些奇奇怪怪的地方的声音，试图去曲解躺平的做法和本质并向大众传播，他们把躺平与混吃等死等同，他们把躺平与不劳动、不工作、消极生活等同，使得躺平这个词语污名化。他们希望你像他们口中说的那样躺平。\n那么请你思考：他们为什么希望你混吃等死？他们为什么希望你不劳动、不工作、消极生活？他们到底是谁？\n先假设他们是从自己的利益出发的，来看看前两个问题，如果你混吃等死、不劳动、不工作、消极生活对别人有什么好处，会对什么人有好处？首先，这样的行为肯定是不会给你老板带去好处的（这算是利于对抗资本家的一方面），但是其他方面来说，首先明确一个事情，劳动创造价值，那么真这样做了，你确实不会给社会创造出价值，虽然说一个人的影响是有限的，但是如果全部劳动人民都这样做，那么我们国家的经济发展就会受到阻碍，那么这样的结果对谁是有益处的？那必然是其他国家，比如某丑国，攻破堡垒往往在内部进攻是最容易的，如果我们的经济发展受到了制约，那必然会被其他国家拉开距离，历史告诉我们：落后就要挨打！\n进一步的，在不劳动和不工作的情况下，如果很多人真如他们所说的，现在年轻人生活一眼看不到头，看不到希望了，所以他们希望你去消极生活。你需要知道的是，如果一个人感到消极，那很可能会做出一些蠢事，是有可能对社会产生危害的。（近来看新闻，发生了几起持刀砍人的事件，虽然我们不清楚到底为什么犯罪人会有这种变态行为，但是我可以肯定的是，这样的人面对生活的态度肯定是消极的，消极的情绪会影响一个人的行为）如果我们生活的地方发生类似这样的恶性事件，那么谁最开心？那必然是我们的敌人，所以此时，我大胆揣测他们是某丑国派来扰乱我们这一代年轻人的思想的。\n退一万步说，先不说这是别国发狗粮给公知、洋奴引导的阴谋论，你躺平最有利于的是谁？不劳动工作，那你很可能会在家，作为一个现代年轻人，你会去上网，上网的时候很可能给资本带去流量，他们有了流量，便会有利益，他们甚至可以通过流量来控制舆论，甚至可以大肆宣传他们的消费主义观念，输出种种畸形的文化和消费理念，而导致你在恶性循环，资本却赚得盆满钵满。即使你不消费，流量会吸引更多的人关注，必然会引起人的消费。\n说到房价和薪资涨幅，确实是一个让包括我在内很多人头疼的问题，从前些年来说，房价确实涨得离谱了，但是我看最近出台了很多政策，有关于土地出让金、房地产税等等的政策，说明国家已经逐渐重视”房住不炒“了，个人认为，我们要相信我们的祖国，相信党，给国家调控的时间，不要过度抱怨，做好自己。说说工资，有人说，攒了十年的钱给不起首付，这点我是不太同意的，如果你在一线城市，那我估计一大堆人都给不起，但是你真的有必要在一线城市买房吗？是为了什么呢？还有其他选择吗？如果你说，你从事的行业只有在一线城市有需求，那这样的行业如IT一般都是薪资高的，而且跳槽涨幅很不错的，那你如果真的决定了，只要涨幅低或者薪资不匹配你的实力了，那你不妨试着去跳槽，就拿我自己来说，我是个Android程序员，之前因为不满自己的待遇，觉得薪资无法匹配我自身的工作量，跳了一次槽，最后薪资翻了一倍还多。如果你不是从事我这样的一线城市才有大需求的行业，那不妨回家工作，回家买房的（如果是个小城市），虽然可能薪资降了一点，但是你买房的首付会低个至少1/2到2/3之间吧，那有人说，你自己家本来就在一线城市，或者就不想回家，怎么办？首先，如果你家本来就在一线城市，那不妨先和父母住吧？这样你至少暂时不愁居住，而且，你如果真想买一线城市的房子，要么你可以尝试偏一点的，要么就先暂时买小一点的，少受消费主义洗脑，先攒着钱，理理财，等以后有钱再换大的，如果你希望一劳永逸，我建议你学习编程转行搞IT，薪资确实高，牛逼的有年薪百万的，虽然比较难，但就看个人的能力了。\n你才二十几岁，为什么眼里就没有光了呢。你要明白一件事，你还有好几十年才退休，还有很长的人生等着你去探索与体验，为什么就想着消极面对了呢。大丈夫生于乱世，当带三尺剑立不世之功，今所志未遂，奈何死乎？\n最后总结一下吧，我认为躺平不是什么坏事，但是你应该明白躺平的本质到底应该是什么。躺平不是躺尸，不是贪图享乐，不是混吃等死，不是不思进取，躺平是我们表达抗争的方式，是为了过得更幸福，拒绝被资本家剥削和压迫，拒绝不必要的内卷，拒绝消费主义，拒绝资本制造出来迷惑你的各种光鲜幻象，拒绝消极生活，拒绝不公正的境遇。你要享受生活，享受属于自己的时间，积极面对生活，不断地去读书，增长见识，了解这个世界，亲身体会这个世界，精彩地活着。如果累了，大可躺下休息一下，歇息完毕就继续迎风向前，那就无愧于你自己了。\n","date":"2021-06-26T00:00:00Z","permalink":"https://haolovelin.com/post/%E6%89%80%E8%B0%93%E8%BA%BA%E5%B9%B3%E7%BB%9D%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%B7%B7%E5%90%83%E7%AD%89%E6%AD%BB/","title":"所谓躺平，绝不等于混吃等死"},{"content":"湖南农民运动考察报告 （一九二七年三月）\n文章背景：\n* 毛泽东此文是为了答复当时党内党外对于农民革命斗争的责难而写的。为了这个目的，毛泽东到湖南做了三十二天的考察工作，并写了这一篇报告。当时党内以陈独秀为首的右倾机会主义者，不愿意接受毛泽东的意见，而坚持自己的错误见解。他们的错误，主要是被国民党的反动潮流所吓倒，不敢支持已经起来和正在起来的伟大的农民革命斗争。为了迁就国民党，他们宁愿抛弃农民这个最主要的同盟军，使工人阶级和共产党处于孤立无援的地位。一九二七年春夏国民党之所以敢于叛变，发动“清党运动”和反人民的战争，主要就是乘了共产党的这个弱点。　正文：\n农民问题的严重性 我这回到湖南[1]，实地考察了湘潭、湘乡、衡山、醴陵、长沙五县的情况。从一月四日起至二月五日止，共三十二天，在乡下，在县城，召集有经验的农民和农运工作同志开调查会，仔细听他们的报告，所得材料不少。许多农民运动的道理，和在汉口、长沙从绅士阶级那里听得的道理，完全相反。许多奇事，则见所未见，闻所未闻。我想这些情形，很多地方都有。所有各种反对农民运动的议论，都必须迅速矫正。革命当局对农民运动的各种错误处置，必须迅速变更。这样，才于革命前途有所补益。因为目前农民运动的兴起是一个极大的问题。很短的时间内，将有几万万农民从中国中部、南部和北部各省起来，其势如暴风骤雨，迅猛异常，无论什么大的力量都将压抑不住。他们将冲决一切束缚他们的罗网，朝着解放的路上迅跑。一切帝国主义、军阀、贪官污吏、土豪劣绅，都将被他们葬入坟墓。一切革命的党派、革命的同志，都将在他们面前受他们的检验而决定弃取。站在他们的前头领导他们呢？还是站在他们的后头指手画脚地批评他们呢？还是站在他们的对面反对他们呢？每个中国人对于这三项都有选择的自由，不过时局将强迫你迅速地选择罢了。\n组织起来 湖南的农民运动，就湘中、湘南已发达的各县来说，大约分为两个时期。去年一月至九月为第一时期，即组织时期。此时期内，一月至六月为秘密活动时期，七月至九月革命军驱逐赵恒惕[2]，为公开活动时期。此时期内，农会会员的人数总计不过三四十万，能直接领导的群众也不过百余万，在农村中还没有什么斗争，因此各界对它也没有什么批评。因为农会会员能作向导，作侦探，作挑夫，北伐军的军官们还有说几句好话的。十月至今年一月为第二时期，即革命时期。农会会员激增到二百万，能直接领导的群众增加到一千万。因为农民入农会大多数每家只写一个人的名字，故会员二百万，群众便有约一千万。在湖南农民全数中，差不多组织了一半。如湘潭、湘乡、浏阳、长沙、醴陵、宁乡、平江、湘阴、衡山、衡阳、耒阳、郴县、安化等县，差不多全体农民都集合在农会的组织中，都立在农会领导之下。农民既已有了广大的组织，便开始行动起来，于是在四个月中造成一个空前的农村大革命。\n打倒土豪劣绅，一切权力归农会 农民的主要攻击目标是土豪劣绅，不法地主，旁及各种宗法的思想和制度，城里的贪官污吏，乡村的恶劣习惯。这个攻击的形势，简直是急风暴雨，顺之者存，违之者灭。其结果，把几千年封建地主的特权，打得个落花流水。地主的体面威风，扫地以尽。地主权力既倒，农会便成了唯一的权力机关，真正办到了人们所谓“一切权力归农会”。连两公婆吵架的小事，也要到农民协会去解决。一切事情，农会的人不到场，便不能解决。农会在乡村简直独裁一切，真是“说得出，做得到”。外界的人只能说农会好，不能说农会坏。土豪劣绅，不法地主，则完全被剥夺了发言权，没有人敢说半个不字。在农会威力之下，土豪劣绅们头等的跑到上海，二等的跑到汉口，三等的跑到长沙，四等的跑到县城，五等以下土豪劣绅崽子则在乡里向农会投降。 “我出十块钱，请你们准我进农民协会。”小劣绅说。 “嘻！谁要你的臭钱！”农民这样回答。 好些中小地主、富农乃至中农，从前反对农会的，此刻求入农会不可得。我到各处，常常遇到这种人，这样向我求情：“请省里来的委员作保！” 前清地方造丁口册，有正册、另册二种，好人入正册，匪盗等坏人入另册。现在有些地方的农民便拿了这事吓那些从前反对农会的人：“把他们入另册！” 那些人怕入另册，便多方设法求入农会，一心要想把他们的名字写上那农会的册子才放心。但他们往往遭农会严厉拒绝，所以他们总是悬心吊胆地过日子；摈在农会的门外，好像无家可归的样子，乡里话叫做“打零”。总之，四个月前被一般人看不起的所谓“农民会”，现在却变成顶荣耀的东西。从前拜倒在绅士权力下面的人，现在却拜倒在农民权力之下。无论什么人，都承认去年十月以前和十月以后是两个世界。\n“糟得很”和“好得很” 农民在乡里造反，搅动了绅士们的酣梦。乡里消息传到城里来，城里的绅士立刻大哗。我初到长沙时，会到各方面的人，听到许多的街谈巷议。从中层以上社会至国民党右派，无不一言以蔽之曰：“糟得很。”即使是很革命的人吧，受了那班“糟得很”派的满城风雨的议论的压迫，他闭眼一想乡村的情况，也就气馁起来，没有法子否认这“糟”字。很进步的人也只是说：“这是革命过程中应有的事，虽则是糟。”总而言之，无论什么人都无法完全否认这“糟”字。实在呢，如前所说，乃是广大的农民群众起来完成他们的历史使命，乃是乡村的民主势力起来打翻乡村的封建势力。宗法封建性的土豪劣绅，不法地主阶级，是几千年专制政治的基础，帝国主义、军阀、贪官污吏的墙脚。打翻这个封建势力，乃是国民革命的真正目标。孙中山先生致力国民革命凡四十年，所要做而没有做到的事，农民在几个月内做到了。这是四十年乃至几千年未曾成就过的奇勋。这是好得很。完全没有什么“糟”，完全不是什么“糟得很”。“糟得很”，明明是站在地主利益方面打击农民起来的理论，明明是地主阶级企图保存封建旧秩序，阻碍建设民主新秩序的理论，明明是反革命的理论。每个革命的同志，都不应该跟着瞎说。你若是一个确定了革命观点的人，而且是跑到乡村里去看过一遍的，你必定觉到一种从来未有的痛快。无数万成群的奴隶——农民，在那里打翻他们的吃人的仇敌。农民的举动，完全是对的，他们的举动好得很！“好得很”是农民及其它革命派的理论。一切革命同志须知：国民革命需要一个大的农村变动。辛亥革命[3]没有这个变动，所以失败了。现在有了这个变动，乃是革命完成的重要因素。一切革命同志都要拥护这个变动，否则他就站到反革命立场上去了。\n所谓“过分”的问题 又有一般人说：“农会虽要办，但是现在农会的举动未免太过分了。”这是中派的议论。实际怎样呢？的确的，农民在乡里颇有一点子“乱来”。农会权力无上，不许地主说话，把地主的威风扫光。这等于将地主打翻在地，再踏上一只脚。“把你入另册！”向土豪劣绅罚款捐款，打轿子。反对农会的土豪劣绅的家里，一群人涌进去，杀猪出谷。土豪劣绅的小姐少奶奶的牙床上，也可以踏上去滚一滚。动不动捉人戴高帽子游乡，“劣绅！今天认得我们！”为所欲为，一切反常，竟在乡村造成一种恐怖现象。这就是一些人的所谓“过分”，所谓“矫枉过正”，所谓“未免太不成话”。这派议论貌似有理，其实也是错的。第一，上述那些事，都是土豪劣绅、不法地主自己逼出来的。土豪劣绅、不法地主，历来凭借势力称霸，践踏农民，农民才有这种很大的反抗。凡是反抗最力、乱子闹得最大的地方，都是土豪劣绅、不法地主为恶最甚的地方。农民的眼睛，全然没有错的。谁个劣，谁个不劣，谁个最甚，谁个稍次，谁个惩办要严，谁个处罚从轻，农民都有极明白的计算，罚不当罪的极少。第二，革命不是请客吃饭，不是做文章，不是绘画绣花，不能那样雅致，那样从容不迫，文质彬彬，那样温良恭俭让。革命是暴动，是一个阶级推翻一个阶级的暴烈的行动。农村革命是农民阶级推翻封建地主阶级的权力的革命。农民若不用极大的力量，决不能推翻几千年根深蒂固的地主权力。农村中须有一个大的革命热潮，才能鼓动成千成万的群众，形成一个大的力量。上面所述那些所谓“过分”的举动，都是农民在乡村中由大的革命热潮鼓动出来的力量所造成的。这些举动，在农民运动第二时期（革命时期）是非常之需要的。在第二时期内，必须建立农民的绝对权力。必须不准人恶意地批评农会。必须把一切绅权都打倒，把绅士打在地下，甚至用脚踏上。所有一切所谓“过分”的举动，在第二时期都有革命的意义。质言之，每个农村都必须造成一个短时期的恐怖现象，非如此决不能镇压农村反革命派的活动，决不能打倒绅权。矫枉必须过正，不过正不能矫枉[4]。这一派的议论，表面上和前一派不同，但其实质则和前一派同站在一个观点上，依然是拥护特权阶级利益的地主理论。这种理论，阻碍农民运动的兴起，其结果破坏了革命，我们不能不坚决地反对。\n所谓“痞子运动” 国民党右派说：“农民运动是痞子运动，是惰农运动。”这种议论，在长沙颇盛行。我跑到乡下，听见绅士们说：“农民协会可以办，但是现在办事人不行，要换人啦！”这种议论，和右派的话是一个意思，都是说农运可做（因农民运动已起来，无人敢说不可做），但是现在做农运的人不行，尤其痛恨下级农民协会办事人，说他们都是些“痞子”。总而言之，一切从前为绅士们看不起的人，一切被绅士们打在泥沟里，在社会上没有了立足地位，没有了发言权的人，现在居然伸起头来了。不但伸起头，而且掌权了。他们在乡农民协会（农民协会的最下级）称王，乡农民协会在他们手里弄成很凶的东西了。他们举起他们那粗黑的手，加在绅士们头上了。他们用绳子捆绑了劣绅，给他戴上高帽子，牵着游乡（湘潭、湘乡叫游团，醴陵叫游垅）。他们那粗重无情的斥责声，每天都有些送进绅士们的耳朵里去。他们发号施令，指挥一切。他们站在一切人之上——从前站在一切人之下，所以叫做反常。\n革命先锋 对于一件事或一种人，有相反的两种看法，便出来相反的两种议论。“糟得很”和“好得很”，“痞子”和“革命先锋”，都是适例。 前面说了农民成就了多年未曾成就的革命事业，农民做了国民革命的重要工作。但是这种革命大业，革命重要工作，是不是农民全体做的呢？不是的。农民中有富农、中农、贫农三种。三种状况不同，对于革命的观感也各别。当第一时期，富农耳里听得的是所谓江西一败如水，蒋介石打伤了脚[5]，坐飞机回广东[6]了。吴佩孚[7]重新占了岳州。农民协会必定立不久，三民主义[8]也兴不起，因为这是所谓从来没有的东西。乡农民协会的办事人（多属所谓“痞子”之类），拿了农会的册子，跨进富农的大门，对富农说：“请你进农民协会。”富农怎样回答呢？“农民协会吗？我在这里住了几十年，种了几十年田，没有见过什么农民协会，也吃饭。我劝你们不办的好！”富农中态度好点的这样说。“什么农民协会，砍脑壳会，莫害人！”富农中态度恶劣的这样说。新奇得很，农民协会居然成立了好几个月，而且敢于反对绅士。邻近的绅士因为不肯缴鸦片枪，被农民协会捉了去游乡。县城里并且杀了大绅士，例如湘潭的晏容秋，宁乡的杨致泽。十月革命纪念大会，反英大会，北伐胜利总庆祝，每乡都有上万的农民举起大小旗帜，杂以扁担锄头，浩浩荡荡，出队示威。这时，富农才开始惶惑起来。在北伐胜利总庆祝中，他们听见说，九江也打开了，蒋介石没有伤脚，吴佩孚究竟打败了。而且“三民主义万岁”，“农民协会万岁”，“农民万岁”等等，明明都写在“红绿告示”（标语）上面。“农民万岁，这些人也算作万岁吗？”富农表示很大的惶惑。农会于是神气十足了。农会的人对富农说：“把你们入另册！”或者说：“再过一个月，入会的每人会费十块钱！”在这样的形势之下，富农才慢慢地进了农会[[9]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-192703.htm#_ftn9)，有些是缴过五角钱或一块钱（本来只要一百钱）入会费的，有些是托人说情才邀了农会允许的。亦有好些顽固党，至今还没有入农会。富农入会，多把他那家里一个六七十岁的老头子到农会去上一个名字，因为他们始终怕“抽丁”。入会后，也并不热心替农会做事。他们的态度始终是消极的。 中农呢？他们的态度是游移的。他们想到革命对他们没有什么大的好处。他们锅里有米煮，没有人半夜里敲门来讨账。他们也根据从来有没有的道理，独自皱着眉头在那里想：“农民协会果然立得起来吗？”“三民主义果然兴得起来吗？”他们的结论是：“怕未必！”他们以为这全决于天意：“办农民会，晓得天意顺不顺咧？”在第一时期内，农会的人拿了册子，进了中农的门，对着中农说道：“请你加入农民协会！”中农回答道：“莫性急啦！”一直到第二时期，农会势力大盛，中农方加入农会。他们在农会的表现比富农好，但暂时还不甚积极，他们还要看一看。农会争取中农入会，向他们多作解释工作，是完全必要的。 乡村中一向苦战奋斗的主要力量是贫农。从秘密时期到公开时期，贫农都在那里积极奋斗。他们最听共产党的领导。他们和土豪劣绅是死对头，他们毫不迟疑地向土豪劣绅营垒进攻。他们对着富农说：“我们早进了农会，你们为什么还迟疑？”富农带着讥笑的声调说道：“你们上无片瓦，下无插针之地，有什么不进农会！”的确，贫农们不怕失掉什么。他们中间有很多人，确实是“上无片瓦，下无插针之地”，他们有什么不进农会？据长沙的调查：乡村人口中，贫农占百分之七十，中农占百分之二十，地主和富农占百分之十。百分之七十的贫农中，又分赤贫、次贫二类。全然无业，即既无土地，又无资期金，完全失去生活依据，不得不出外当兵，或出去做工，或打流当乞丐的，都是“赤贫”，占百分之二十。半无业，即略有土地，或略有资金，但吃的多，收的少，终年在劳碌愁苦中过生活的，如手工工人、佃农（富佃除外）、半自耕农[[10]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-192703.htm#_ftn10)等，都是“次贫”，占百分之五十。这个贫农大群众，合共占乡村人口百分之七十，乃是农民协会的中坚，打倒封建势力的先锋，成就那多年未曾成就的革命大业的元勋。没有贫农阶级（照绅士的话说，没有“痞子”），决不能造成现时乡村的革命状态，决不能打倒土豪劣绅，完成民主革命。贫农，因为最革命，所以他们取得了农会的领导权。所有最下一级农民协会的委员长、委员，在第一第二两个时期中，几乎全数是他们（衡山县乡农民协会职员，赤贫阶层占百分之五十，次贫阶层占百分之四十，穷苦知识分子占百分之十）。这个贫农领导，是非常之需要的。没有贫农，便没有革命。若否认他们，便是否认革命。若打击他们，便是打击革命。他们的革命大方向始终没有错。他们损伤了土豪劣绅的体面。他们打翻了大小土豪劣绅在地上，并且踏上一只脚。他们在革命期内的许多所谓“过分”举动，实在正是革命的需要。湖南有些县的县政府、县党部[[11]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-192703.htm#_ftn11)和县农会，已经做了若干错处，竟有循地主之请，派兵拘捕下级农会职员的。衡山、湘乡二县的监狱里，关了好多个乡农民协会委员长、委员。这个错误非常之大，助长了反动派的气焰。只要看拘捕了农民协会委员长、委员，当地的不法地主们便大高兴，反动空气便大增高，就知道这事是否错误。我们要反对那些所谓“痞子运动”、“惰农运动”的反革命议论，尤其要注意不可做出帮助土豪劣绅打击贫农阶级的错误行动。事实上，贫农领袖中，从前虽有些确是有缺点的，但是现在多数都变好了。他们自己在那里努力禁牌赌，清盗匪。农会势盛地方，牌赌禁绝，盗匪潜踪。有些地方真个道不拾遗，夜不闭户。据衡山的调查，贫农领袖百人中八十五人都变得很好，很能干，很努力。只有百分之十五，尚有些不良习惯。这只能叫做“少数不良分子”，决不能跟着土豪劣绅的口白，笼统地骂“痞子”。要解决这“少数不良分子”的问题，也只能在农会整顿纪律的口号之下，对群众做宣传，对他们本人进行训练，把农会的纪律整好，决不能随便派兵捉人，损害贫农阶级的威信，助长土豪劣绅的气势。这一点是非常要注意的。\n十四件大事 一般指摘农会的人说农会做了许多坏事。我在前面已经指出，农民打土豪劣绅这件事完全是革命行为，并没有什么可指摘。但是农民所做的事很多，为了答复人们的指摘，我们须得把农民所有的行动过细检查一遍，逐一来看他们的所作所为究竟是怎么样。我把几个月来农民的行动分类总计起来，农民在农民协会领导之下总共作了十四件大事，如下所记。\n第一件　将农民组织在农会里 这是农民所做的第一件大事。像湘潭、湘乡、衡山这样的县，差不多所有的农民都组织起来了，几乎没有哪一只“角暗里”的农民没有起来，这是第一等。有些县，农民组织起来了一大部分，尚有一小部分没有组织，如益阳、华容等县，这是第二等。有些县，农民组织起来了一小部分，大部分尚未组织起来，如城步、零陵等县，这是第三等。湘西一带，在袁祖铭[12]势力之下，农会宣传未到，许多县的农民还全未组织起来，这是第四等。大概以长沙为中心的湘中各县最发展，湘南各县次之，湘西还在开始组织中。据去年十一月省农民协会统计，全省七十五县中，三十七县有了组织，会员人数一百三十六万七千七百二十七人。此数中，约有一百万是去年十月、十一月两个月内农会势力大盛时期组织的，九月以前还不过三四十万人。现又经过十二月、一月两个月，农民运动正大发展。截至一月底止，会员人数至少满了二百万。因入会一家多只登记一人，平均每家以五口计，群众便约有一千万。这种惊人的加速度的发展，是所以使一切土豪劣绅贪官污吏孤立，使社会惊为前后两个世界，使农村造成大革命的原因。这是农民在农民协会领导之下所做的第一件大事。\n第二件　政治上打击地主 农民有了组织之后，第一个行动，便是从政治上把地主阶级特别是土豪劣绅的威风打下去，即是从农村的社会地位上把地主权力打下去，把农民权力长上来。这是一个极严重极紧要的斗争。这个斗争是第二时期即革命时期的中心斗争。这个斗争不胜利，一切减租减息，要求土地及其它生产手段等等的经济斗争，决无胜利之可能。湖南许多地方，像湘乡、衡山、湘潭等县，地主权力完全推翻，形成了农民的独一权力，自无问题。但是醴陵等县，尚有一部分地方（如醴陵之西南两区），表面上地主权力低于农民权力，实际上因为政治斗争不激烈，地主权力还隐隐和农民权力对抗。这些地方，还不能说农民已得了政治的胜利，还须加劲作政治斗争，至地主权力被农民完全打下去为止。综计农民从政治上打击地主的方法有如下各项： 清算。土豪劣绅经手地方公款，多半从中侵蚀，账目不清。这回农民拿了清算的题目，打翻了很多的土豪劣绅。好多地方组织了清算委员会，专门向土豪劣绅算账，土豪劣绅看了这样的机关就打颤。这样的清算运动，在农民运动起来的各县做得很普遍，意义不重在追回款子，重在宣布土豪劣绅的罪状，把土豪劣绅的政治地位和社会地位打下去。 罚款。清算结果，发现舞弊，或从前有鱼肉农民的劣迹，或现在有破坏农会的行为，或违禁牌赌，或不缴烟枪。在这些罪名之下，农民议决，某土豪罚款若干，某劣绅罚款若干，自数十元至数千元不等。被农民罚过的人，自然体面扫地。 捐款。向为富不仁的地主捐款救济贫民，办合作社，办农民贷款所，或作他用。捐款也是一种惩罚，不过较罚款为轻。地主为免祸计，自动地捐款给农会的，亦颇不少。 小质问。遇有破坏农会的言论行动而罪状较轻的，则邀集多人涌入其家，提出比较不甚严重的质问。结果，多要写个“休息字”，写明从此终止破坏农会名誉的言论行动了事。 大示威。统率大众，向着和农会结仇的土豪劣绅示威，在他家里吃饭，少不得要杀猪出谷，此类事颇不少。最近湘潭马家河，有率领一万五千群众向六个劣绅问罪，延时四日，杀猪百三十余个的事。示威的结果，多半要罚款。 戴高帽子游乡。这种事各地做得很多。把土豪劣绅戴上一顶纸扎的高帽子，在那帽子上面写上土豪某某或劣绅某某字样。用绳子牵着，前后簇拥着一大群人。也有敲打铜锣，高举旗帜，引人注目的。这种处罚，最使土豪劣绅颤栗。戴过一次高帽子的，从此颜面扫地，做不起人。故有钱的多愿罚款，不愿戴高帽子。但农民不依时，还是要戴。有一个乡农会很巧妙，捉了一个劣绅来，声言今天要给他戴高帽子。劣绅于是吓黑了脸。但是，农会议决，今天不给他戴高帽子。因为今天给他戴过了，这劣绅横了心，不畏罪了，不如放他回去，等日再戴。那劣绅不知何日要戴高帽子，每日在家放心不下，坐卧不宁。 关进县监狱。这是比戴高帽子更重的罪。把土豪劣绅捉了，送进知事公署的监狱，关起来，要知事办他的罪。现在监狱里关人和从前两样，从前是绅士送农民来关，现在是农民送绅士来关。 驱逐。土豪劣绅中罪恶昭著的，农民不是要驱逐，而是要捉他们，或杀他们。他们怕捉怕杀，逃跑出外。重要的土豪劣绅，在农民运动发达县份，几乎都跑光了，结果等于被驱逐。他们中间，头等的跑到上海，次等的跑到汉口，三等的跑到长沙，四等的跑到县城。这些逃跑的土豪劣绅，以逃到上海的为最安全。逃到汉口的，如华容的三个劣绅，终被捉回。逃到长沙的，更随时有被各县旅省学生捕获之虞，我在长沙就亲眼看见捕获两个。逃到县城的，资格已是第四等了，农民耳目甚多，发觉甚易。湖南政府财政困难，财政当局曾归咎于农民驱逐阔人，以致筹款不易，亦可见土豪劣绅不容于乡里之一斑。 枪毙。这必是很大的土豪劣绅，农民和各界民众共同做的。例如宁乡的杨致泽，岳阳的周嘉淦，华容的傅道南、孙伯助，是农民和各界人民督促政府枪毙的。湘潭的晏容秋，则是农民和各界人民强迫县长同意从监狱取出，由农民自己动手枪毙的。宁乡的刘昭，是农民直接打死的。醴陵的彭志蕃，益阳的周天爵、曹云，则正待“审判土豪劣绅特别法庭”判罪处决。这样的大劣绅、大土豪，枪毙一个，全县震动，于肃清封建余孽，极有效力。这样的大土豪劣绅，各县多的有几十个，少的也有几个，每县至少要把几个罪大恶极的处决了，才是镇压反动派的有效方法。土豪劣绅势盛时，杀农民真是杀人不眨眼。长沙新康镇团防局长何迈泉，办团十年，在他手里杀死的贫苦农民将近一千人，美其名曰“杀匪”。我的家乡湘潭县银田镇团防局长汤峻岩、罗叔林二人，民国二年以来十四年间，杀人五十多，活埋四人。被杀的五十多人中，最先被杀的两人是完全无罪的乞丐。汤峻岩说：“杀两个叫化子开张！”这两个叫化子就是这样一命呜呼了。以前土豪劣绅的残忍，土豪劣绅造成的农村白色恐怖是这样，现在农民起来枪毙几个土豪劣绅，造成一点小小的镇压反革命派的恐怖现象，有什么理由说不应该？\n第三件　经济上打击地主 不准谷米出境，不准高抬谷价，不准囤积居奇。这是近月湖南农民经济斗争上一件大事。从去年十月至现在，贫农把地主富农的谷米阻止出境，并禁止高抬谷价和囤积居奇。结果，贫农的目的完全达到，谷米阻得水泄不通，谷价大减，囤积居奇的绝迹。 不准加租加押，宣传减租减押。去年七八月间，农会还在势力弱小时期，地主依然按照剥削从重老例，纷纷通知佃农定要加租加押。但是到了十月，农会势力大增，一致反对加租加押，地主便不敢再提加租加押四字。及至十一月后，农民势力压倒地主势力，农民乃进一步宣传减租减押。农民说：可惜去秋交租时农会尚无力量，不然去秋就减了租了。对于今秋减租，农民正大做宣传，地主们亦在问减租办法。至于减押，衡山等县目下已在进行。 不准退佃。去年七八月间，地主还有好多退佃另佃的事。十月以后，无人敢退佃了。现在退佃另佃已完全不消说起，只有退佃自耕略有点问题。有些地方，地主退佃自耕，农民也不准。有些地方，地主如自耕，可以允许退佃，但同时发生了佃农失业问题。此问题尚无一致的解决办法。 减息。安化已普遍地减了息，他县亦有减息的事。惟农会势盛地方，地主惧怕“共产”，完全“卡借”，农村几无放债的事。此时所谓减息，限于旧债。旧债不仅减息，连老本也不许债主有逼取之事。贫农说：“怪不得，年岁大了，明年再还吧！”\n第四件　推翻土豪劣绅的封建统治——打倒都团 旧式的都团（即区乡）政权机关，尤其是都之一级，即接近县之一级，几乎完全是土豪劣绅占领。“都”管辖的人口有一万至五六万之多，有独立的武装如团防局，有独立的财政征收权如亩捐[13]等，有独立的司法权如随意对农民施行逮捕、监禁、审问、处罚。这样的机关里的劣绅，简直是乡里王。农民对政府如总统、督军[14]、县长等还比较不留心，这班乡里王才真正是他们的“长上”，他们鼻子里哼一声，农民晓得这是要十分注意的。这回农村造反的结果，地主阶级的威风普遍地打下来，土豪劣绅把持的乡政机关，自然跟了倒塌。都总团总[15]躲起不敢出面，一切地方上的事都推到农民协会去办。他们应付的话是： “不探（管）闲事！” 农民们相与议论，谈到都团总，则愤然说： “那班东西么，不作用了！” “不作用”三个字，的确描画了经过革命风潮地方的旧式乡政机关。\n第五件　推翻地主武装，建立农民武装 湖南地主阶级的武装，中路较少，西南两路较多。平均每县以六百枝步枪计，七十五县共有步枪四万五千枝，事实上或者还要多。农民运动发展区域之中南两路，因农民起来形势甚猛，地主阶级招架不住，其武装势力大部分投降农会，站在农民利益这边，例如宁乡、平江、浏阳、长沙、醴陵、湘潭、湘乡、安化、衡山、衡阳等县。小部分站在中立地位，但倾向于投降，例如宝庆等县。再一小部分则站在和农会敌对地位，例如宜章、临武、嘉禾等县，但现时农民正在加以打击，可能于不久时间消灭其势力。这样由反动的地主手里拿过来的武装，将一律改为“挨户团常备队”[16]，放在新的乡村自治机关——农民政权的乡村自治机关管理之下。这种旧武装拿过来，是建设农民武装的一方面。建设农民武装另有一个新的方面，即农会的梭镖队。梭镖——一种接以长柄的单尖两刃刀，单湘乡一县有十万枝。其它各县，如湘潭、衡山、醴陵、长沙等，七八万枝、五六万枝、三四万枝不等。凡有农民运动各县，梭镖队便迅速地发展。这种有梭镖的农民，将成为“挨户团非常备队”。这个广大的梭镖势力，大于前述旧武装势力，是使一切土豪劣绅看了打颤的一种新起的武装力量。湖南的革命当局，应使这种武装力量确实普及于七十五县二千余万农民之中，应使每个青年壮年农民都有一柄梭镖，而不应限制它，以为这是可以使人害怕的东西。若被这种梭镖队吓翻了，那真是胆小鬼！只有土豪劣绅看了害怕，革命党决不应该看了害怕。\n第六件　推翻县官老爷衙门差役的政权 县政治必须农民起来才能澄清，广东的海丰已经有了证明。这回在湖南，尤其得到了充分的证明。在土豪劣绅霸占权力的县，无论什么人去做知事，几乎都是贪官污吏。在农民已经起来的县，无论什么人去，都是廉洁政府。我走过的几县，知事遇事要先问农民协会。在农民势力极盛的县，农民协会说话是“飞灵的”。农民协会要早晨捉土豪劣绅，知事不敢挨到中午，要中午捉，不敢挨到下午。农民的权力在乡间初涨起来的时候，县知事和土豪劣绅是勾结一起共同对付农民的。在农民的权力涨至和地主权力平行的时候，县知事取了向地主农民两边敷衍的态度，农民协会的话，有一些被他接受，有一些被他拒绝。上头所说农会说话飞灵，是在地主权力被农民权力完全打下去了的时候。现在像湘乡、湘潭、醴陵、衡山等县的县政治状况是： （一）凡事取决于县长和革命民众团体的联合会议。这种会议，由县长召集，在县署开。有些县名之曰“公法团联席会议”，有些县名之曰“县务会议”。出席的人，县长以外，为县农民协会、县总工会、县商民协会、县女界联合会、县教职员联合会、县学生联合会以及国民党县党部[17]的代表们。在这样的会议里，各民众团体的意见影响县长，县长总是唯命是听。所以，在湖南采用民主的委员制县政治组织，应当是没有问题的了。现在的县政府，形式和实质，都已经是颇民主的了。达到这种形势，是最近两三个月的事，即农民从四乡起来打倒了土豪劣绅权力以后的事。知事看见旧靠山已倒，要做官除非另找靠山，这才开始巴结民众团体，变成了上述的局面。 （二）承审员没有案子。湖南的司法制度，还是知事兼理司法，承审员助知事审案。知事及其僚佐要发财，全靠经手钱粮捐派，办兵差和在民刑诉讼上颠倒敲诈这几件事，尤以后一件为经常可靠的财源。几个月来，土豪劣绅倒了，没有了讼棍。农民的大小事，又一概在各级农会里处理。所以，县公署的承审员，简直没有事做。湘乡的承审员告诉我：“没有农民协会以前，县公署平均每日可收六十件民刑诉讼禀帖；有农会后，平均每日只有四五件了。”于是知事及其僚佐们的荷包，只好空着。 （三）警备队、警察、差役，一概敛迹，不敢下乡敲诈。从前乡里人怕城里人，现在城里人怕乡里人。尤其是县政府豢养的警察、警备队、差役这班恶狗，他们怕下乡，下乡也不敢再敲诈。他们看见农民的梭镖就发抖。\n第七件　推翻祠堂族长的族权和城隍土地菩萨的神权以至丈夫的男权 中国的男子，普通要受三种有系统的权力的支配，即：（一）由一国、一省、一县以至一乡的国家系统（政权）；（二）由宗祠、支祠以至家长的家族系统（族权）；（三）由阎罗天子、城隍庙王以至土地菩萨的阴间系统以及由玉皇上帝以至各种神怪的神仙系统——总称之为鬼神系统（神权）。至于女子，除受上述三种权力的支配以外，还受男子的支配（夫权）。这四种权力——政权、族权、神权、夫权，代表了全部封建宗法的思想和制度，是束缚中国人民特别是农民的四条极大的绳索。农民在乡下怎样推翻地主的政权，已如前头所述。地主政权，是一切权力的基干。地主政权既被打翻，族权、神权、夫权便一概跟着动摇起来。农会势盛地方，族长及祠款经管人不敢再压迫族下子孙，不敢再侵蚀祠款。坏的族长、经管，已被当作土豪劣绅打掉了。从前祠堂里“打屁股”、“沉潭”、“活埋”等残酷的肉刑和死刑，再也不敢拿出来了。女子和穷人不能进祠堂吃酒的老例，也被打破。衡山白果地方的女子们，结队拥入祠堂，一屁股坐下便吃酒，族尊老爷们只好听她们的便。又有一处地方，因禁止贫农进祠堂吃酒，一批贫农拥进去，大喝大嚼，土豪劣绅长褂先生吓得都跑了。神权的动摇，也是跟着农民运动的发展而普遍。许多地方，农民协会占了神的庙宇做会所。一切地方的农民协会，都主张提取庙产办农民学校，做农会经费，名之曰“迷信公款”。醴陵禁迷信、打菩萨之风颇盛行。北乡各区农民禁止家神老爷（傩神）游香。渌口伏波岭庙内有许多菩萨，因为办国民党区党部房屋不够，把大小菩萨堆于一角，农民无异言。自此以后，人家死了人，敬神、做道场、送大王灯的，就很少了。这事，因为是农会委员长孙小山倡首，当地的道士们颇恨孙小山。北三区龙凤庵农民和小学教员，砍了木菩萨煮肉吃。南区东富寺三十几个菩萨都给学生和农民共同烧掉了，只有两个小菩萨名“包公老爷”者，被一个老年农民抢去了，他说：“莫造孽！”在农民势力占了统治地位的地方，信神的只有老年农民和妇女，青年和壮年农民都不信了。农民协会是青年和壮年农民当权，所以对于推翻神权，破除迷信，是各处都在进行中的。夫权这种东西，自来在贫农中就比较地弱一点，因为经济上贫农妇女不能不较富有阶级的女子多参加劳动，所以她们取得对于家事的发言权以至决定权的是比较多些。至近年，农村经济益发破产，男子控制女子的基本条件，业已破坏了。最近农民运动一起，许多地方，妇女跟着组织了乡村女界联合会，妇女抬头的机会已到，夫权便一天一天地动摇起来。总而言之，所有一切封建的宗法的思想和制度，都随着农民权力的升涨而动摇。但是现在时期，农民的精力集中于破坏地主的政治权力这一点。要是地主的政治权力破坏完了的地方，农民对家族神道男女关系这三点便开始进攻了。但是这种进攻，现在到底还在“开始”，要完全推翻这三项，还要待农民的经济斗争全部胜利之后。因此，目前我们对农民应该领导他们极力做政治斗争，期于彻底推翻地主权力。并随即开始经济斗争，期于根本解决贫农的土地及其它经济问题。至于家族主义、迷信观念和不正确的男女关系之破坏，乃是政治斗争和经济斗争胜利以后自然而然的结果。若用过大的力量生硬地勉强地从事这些东西的破坏，那就必被土豪劣绅借为口实，提出“农民协会不孝祖宗”、“农民协会欺神灭道”、“农民协会主张共妻”等反革命宣传口号，来破坏农民运动。湖南的湘乡、湖北的阳新，最近都发生地主利用了农民反对打菩萨的事，就是明证。菩萨是农民立起来的，到了一定时期农民会用他们自己的双手丢开这些菩萨，无须旁人过早地代庖丢菩萨。共产党对于这些东西的宣传政策应当是：“引而不发，跃如也。”[18]菩萨要农民自己去丢，烈女祠、节孝坊要农民自己去摧毁，别人代庖是不对的。 我在乡里也曾向农民宣传破除迷信。我的话是： “信八字望走好运，信风水望坟山贯气。今年几个月光景，土豪劣绅贪官污吏一齐倒台了。难道这几个月以前土豪劣绅贪官污吏还大家走好运，大家坟山都贯气，这几个月忽然大家走坏运，坟山也一齐不贯气了吗？土豪劣绅形容你们农会的话是：‘巧得很啰，如今是委员世界呀，你看，屙尿都碰了委员。’的确不错，城里、乡里、工会、农会、国民党、共产党无一不有执行委员，确实是委员世界。但这也是八字坟山出的吗？巧得很！乡下穷光蛋八字忽然都好了！坟山也忽然都贯气了！神明吗？那是很可敬的。但是不要农民会，只要关圣帝君、观音大士，能够打倒土豪劣绅吗？那些帝君、大士们也可怜，敬了几百年，一个土豪劣绅不曾替你们打倒！现在你们想减租，我请问你们有什么法子，信神呀，还是信农民会？” 我这些话，说得农民都笑起来。\n第八件　普及政治宣传 开一万个法政学校，能不能在这样短时间内普及政治教育于穷乡僻壤的男女老少，像现在农会所做的政治教育一样呢？我想不能吧。打倒帝国主义，打倒军阀，打倒贪官污吏，打倒土豪劣绅，这几个政治口号，真是不翼而飞，飞到无数乡村的青年壮年老头子小孩子妇女们的面前，一直钻进他们的脑子里去，又从他们的脑子里流到了他们的嘴上。比如有一群小孩子在那里玩吧，如果你看见一个小孩子对着另一个小孩子鼓眼蹬脚扬手动气时，你就立刻可以听到一种尖锐的声音，那便是：“打倒帝国主义！” 湘潭一带的小孩子看牛时打起架来，一个做唐生智，一个做叶开鑫[19]，一会儿一个打败了，一个跟着追，那追的就是唐生智，被追的就是叶开鑫。“打倒列强……”这个歌，街上的小孩子固然几乎人人晓得唱了，就是乡下的小孩子也有很多晓得唱了的。 孙中山先生的那篇遗嘱，乡下农民也有些晓得念了。他们从那篇遗嘱里取出了“自由”、“平等”、“三民主义”、“不平等条约”这些名词，颇生硬地应用在他们的生活上。一个绅士模样的人在路上碰了一个农民，那绅士摆格不肯让路，那农民便愤然说：“土豪劣绅！晓得三民主义吗？”长沙近郊菜园农民进城卖菜，老被警察欺负。现在，农民可找到武器了，这武器就是三民主义。当警察打骂卖菜农民时，农民便立即抬出三民主义以相抵制，警察没有话说。湘潭一个区的农民协会，为了一件事和一个乡农民协会不和，那乡农民协会的委员长便宣言：“反对区农民协会的不平等条约！” 政治宣传的普及乡村，全是共产党和农民协会的功绩。很简单的一些标语、图画和讲演，使得农民如同每个都进过一下子政治学校一样，收效非常之广而速。据农村工作同志的报告，政治宣传在反英示威、十月革命纪念和北伐胜利总庆祝这三次大的群众集会时做得很普遍。在这些集会里，有农会的地方普遍地举行了政治宣传，引动了整个农村，效力很大。今后值得注意的，就是要利用各种机会，把上述那些简单的口号，内容渐渐充实，意义渐渐明了起来。\n第九件　农民诸禁 共产党领导农会在乡下树立了威权，农民便把他们所不喜欢的事禁止或限制起来。最禁得严的便是牌、赌、鸦片这三件。 牌：农会势盛地方，麻雀、骨牌、纸叶子，一概禁绝。 湘乡十四都地方一个区农会，曾烧了一担麻雀牌。 跑到乡间去，什么牌都没有打，犯禁的即刻处罚，一点客气也没有。 赌：从前的“赌痞”，现在自己在那里禁赌了，农会势盛地方，和牌一样弊绝风清。 鸦片：禁得非常之严。农会下命令缴烟枪，不敢稍违抗不缴。醴陵一个劣绅不缴烟枪，被捉去游乡。 农民这个“缴枪运动”，其声势不弱于北伐军对吴佩孚、孙传芳[20]军队的缴枪。好些革命军军官家里的年尊老太爷，烟瘾极重，靠一杆“枪”救命的，都被“万岁”（劣绅讥诮农民之称）们缴了去。“万岁”们不仅禁种禁吃，还要禁运。由贵州经宝庆、湘乡、攸县、醴陵到江西去的鸦片，被拦截焚烧不少。这一来，和政府的财政发生了冲突。结果，还是省农会为了顾全北伐军饷，命令下级农会“暂缓禁运”。但农民在那里愤愤不乐。 三者以外，农民禁止或限制的东西还有很多，略举之则有： 花鼓。一种小戏，许多地方禁止演唱。 轿子。许多县有打轿子的事，湘乡特甚。农民最恨那些坐轿子的，总想打，但农会禁止他们。办农会的人对农民说：“你们打轿子，反倒替阔人省了钱，轿工要失业，岂非害了自己？”农民们想清了，出了新法子，就是大涨轿工价，以此惩富人。 煮酒熬糖。普遍禁止用谷米煮酒熬糖，糟行糖行叫苦不迭。衡山福田铺地方，不禁止煮酒，但限定酒价于一极小数目，酒店无钱赚，只好不煮了。 猪。限制每家喂猪的数目，因为猪吃去谷米。 鸡鸭。湘乡禁喂鸡鸭，但妇女们反对。衡山洋塘地方限制每家只准喂三个，福田铺地方只准喂五个。好些地方完全禁止喂鸭，因为鸭比鸡更无用，它不仅吃掉谷，而且搓死禾。 酒席。丰盛酒席普遍地被禁止。湘潭韶山地方议决客来吃三牲，即只吃鸡鱼猪。笋子、海带、南粉都禁止吃。衡山则议决吃八碗，不准多一碗。醴陵东三区只准吃五碗，北二区只准吃三荤三素，西三区禁止请春客。湘乡禁止“蛋糕席”——一种并不丰盛的席面。湘乡二都有一家讨媳妇，用了蛋糕席，农民以他不服从禁令，一群人涌进去，搅得稀烂。湘乡的嘉谟镇实行不吃好饮食，用果品祭祖。 牛。这是农民的宝贝。“杀牛的来生变牛”，简直成了宗教，故牛是杀不得的。农民没有权力时，只能用宗教观念反对杀牛，没有实力去禁止。农会起来后，权力管到牛身上去了，禁止城里杀牛。湘潭城内从前有六家牛肉店，现在倒了五家，剩下一家是杀病牛和废牛的。衡山全县禁绝了杀牛。一个农民他有一头牛跌脱了脚，问过农会，才敢杀。株洲商会冒失地杀了一头牛，农民上街问罪，罚钱而外，放爆竹赔礼。 游民生活。如打春、赞土地、打莲花落，醴陵议决禁止。各县有禁止的，有自然消灭没人干这些事的。有一种“强告化”又叫“流民”者，平素非常之凶，现在亦只得屈服于农会之下。湘潭韶山地方有个雨神庙，素聚流民，谁也不怕，农会起来，悄悄地走了。同地湖堤乡农会，捉了三个流民挑土烧窑。拜年陋俗，议决禁止。 此外各地的小禁令还很多，如醴陵禁傩神游香，禁买南货斋果送情，禁中元烧衣包，禁新春贴瑞签。湘乡的谷水地方水烟也禁了。二都禁放鞭炮和三眼铳，放鞭炮的罚洋一元二角，放铳的罚洋二元四角。七都和二十都禁做道场。十八都禁送奠仪。诸如此类，不胜枚举，统名之曰农民诸禁。 这些禁令中，包含两个重要意义：第一是对于社会恶习之反抗，如禁牌赌鸦片等。这些东西是跟了地主阶级恶劣政治环境来的，地主权力既倒，这些东西也跟着扫光。第二是对于城市商人剥削之自卫，如禁吃酒席，禁买南货斋果送情等等。因为工业品特贵，农产品特贱，农民极为贫困，受商人剥削厉害，不得不提倡节俭，借以自卫。至于前述之农民阻谷出境，是因为贫农自己粮食不够吃，还要向市上买，所以不许粮价高涨。这都是农民贫困和城乡矛盾的缘故，并非农民拒绝工业品和城乡贸易，实行所谓东方文化主义[[21]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-192703.htm#_ftn21)。农民为了经济自卫，必须组织合作社，实行共同买货和消费。还须政府予以援助，使农民协会能组织信用（放款）合作社。如此，农民自然不必以阻谷为限制食粮价格的方法，也不会以拒绝某些工业品入乡为经济自卫的方法了。\n第十件　清　匪 从禹汤文武起吧，一直到清朝皇帝，民国总统，我想没有哪一个朝代的统治者有现在农民协会这样肃清盗匪的威力。什么盗匪，在农会势盛地方，连影子都不见了。巧得很，许多地方，连偷小菜的小偷都没有了。有些地方，还有小偷。至于土匪，则我所走过的各县全然绝了迹，哪怕从前是出土匪很多的地方。原因：一是农会会员漫山遍野，梭镖短棍一呼百应，土匪无处藏踪。二是农民运动起后，谷子价廉，去春每担六元的，去冬只二元，民食问题不如从前那样严重。三是会党[22]加入了农会，在农会里公开地合法地逞英雄，吐怨气，“山、堂、香、水”[23]的秘密组织，没有存在的必要了。杀猪宰羊，重捐重罚，对压迫他们的土豪劣绅阶级出气也出够了。四是各军大招兵，“不逞之徒”去了许多。因此，农运一起，匪患告绝。对于这一点，绅富方面也同情于农会。他们的议论是：“农民协会吗？讲良心话，也有一点点好处。” 对于禁牌、赌、鸦片和清匪，农民协会是博得一般人的同情的。\n第十一件　废苛捐 全国未统一，帝国主义军阀势力未推翻，农民对政府税捐的繁重负担，质言之，即革命军的军费负担，还是没有法子解除的。但是土豪劣绅把持乡政时加于农民的苛捐如亩捐等，却因农民运动的兴起、土豪劣绅的倒塌而取消，至少也减轻了。这也要算是农民协会的功绩之一。\n第十二件　文化运动 中国历来只是地主有文化，农民没有文化。可是地主的文化是由农民造成的，因为造成地主文化的东西，不是别的，正是从农民身上掠取的血汗。中国有百分之九十未受文化教育的人民，这个里面，最大多数是农民。农村里地主势力一倒，农民的文化运动便开始了。试看农民一向痛恶学校，如今却在努力办夜学。“洋学堂”，农民是一向看不惯的。我从前做学生时，回乡看见农民反对“洋学堂”，也和一般“洋学生”、“洋教习”一鼻孔出气，站在洋学堂的利益上面，总觉得农民未免有些不对。民国十四年在乡下住了半年，这时我是一个共产党员，有了马克思主义的观点，方才明白我是错了，农民的道理是对的。乡村小学校的教材，完全说些城里的东西，不合农村的需要。小学教师对待农民的态度又非常之不好，不但不是农民的帮助者，反而变成了农民所讨厌的人。故农民宁欢迎私塾（他们叫“汉学”），不欢迎学校（他们叫“洋学”），宁欢迎私塾老师，不欢迎小学教员。如今他们却大办其夜学，名之曰农民学校。有些已经举办，有些正在筹备，平均每乡有一所。他们非常热心开办这种学校，认为这样的学校才是他们自己的。夜学经费，提取迷信公款、祠堂公款及其它闲公闲产。这些公款，县教育局要提了办国民学校即是那不合农民需要的“洋学堂”，农民要提了办农民学校，争议结果，各得若干，有些地方是农民全得了。农民运动发展的结果，农民的文化程度迅速地提高了。不久的时间内，全省当有几万所学校在乡村中涌出来，不若知识阶级和所谓“教育家”者流，空唤“普及教育”，唤来唤去还是一句废话。\n第十三件　合作社运动 合作社，特别是消费、贩卖、信用三种合作社，确是农民所需要的。他们买进货物要受商人的剥削，卖出农产要受商人的勒抑，钱米借贷要受重利盘剥者的剥削，他们很迫切地要解决这三个问题。去冬长江打仗，商旅路断，湖南盐贵，农民为盐的需要组织合作社的很多。地主“卡借”，农民因借钱而企图组织“借贷所”的，亦所在多有。大问题，就是详细的正规的组织法没有。各地农民自动组织的，往往不合合作社的原则，因此做农民工作的同志，总是殷勤地问“章程”。假如有适当的指导，合作社运动可以随农会的发展而发展到各地。\n第十四件　修道路，修塘坝 这也是农会的一件功绩。没有农会以前，乡村的道路非常之坏。无钱不能修路，有钱的人不肯拿出来，只好让它坏。略有修理，也当作慈善事业，从那些“肯积阴功”的人家化募几个，修出些又狭又薄的路。农会起来了，把命令发出去，三尺、五尺、七尺、一丈，按照路径所宜，分等定出宽狭，勒令沿路地主，各修一段。号令一出，谁敢不依？不久时间，许多好走的路都出来了。这却并非慈善事业，乃是出于强迫，但是这一点子强迫实在强迫得还可以。塘坝也是一样。无情的地主总是要从佃农身上取得东西，却不肯花几个大钱修理塘坝，让塘干旱，饿死佃农，他们却只知收租。有了农会，可以不客气地发命令强迫地主修塘坝了。地主不修时，农会却很和气地对地主说道：“好！你们不修，你们出谷吧，斗谷一工！”地主为斗谷一工划不来，赶快自己修。因此，许多不好的塘坝变成了好塘坝。 总上十四件事，都是农民在农会领导之下做出来的。就其基本的精神说来，就其革命意义说来，请读者们想一想，哪一件不好？说这些事不好的，我想，只有土豪劣绅们吧！很奇怪，南昌方面[24]传来消息，说蒋介石、张静江[25]诸位先生的意见，颇不以湖南农民的举动为然。湖南的右派领袖刘岳峙[26]辈，与蒋、张诸公一个意见，都说：“这简直是赤化了！”我想，这一点子赤化若没有时，还成个什么国民革命！嘴里天天说“唤起民众”，民众起来了又害怕得要死，这和叶公好龙[27]有什么两样！\n注释\n[1] 湖南是当时全国农民运动的中心。\n[2] 赵恒惕（一八八○——一九七一），湖南衡山人。一九二○年以后，他是统治湖南的军阀。一九二六年三月，在湖南人民掀起反赵高潮的形势下，被迫辞去湖南省长的职务。同年七月至九月，他的旧部被北伐军击溃。\n[3] 辛亥革命是以孙中山为首的资产阶级革命团体同盟会所领导的推翻清朝专制王朝的革命。一九一一年（辛亥年）十月十日，革命党人发动新军在湖北武昌举行起义，接着各省响应，外国帝国主义所支持的清朝反动统治迅速瓦解。一九一二年一月在南京成立了中华民国临时政府，孙中山就任临时大总统。统治中国两千多年的君主专制制度从此结束，民主共和国的观念从此深入人心。但是资产阶级革命派力量很弱，并具有妥协性，没有能力发动广大人民的力量比较彻底地进行反帝反封建的革命。辛亥革命的成果迅即被北洋军阀袁世凯篡夺，中国仍然没有摆脱半殖民地、半封建的状态。\n[4] “矫枉过正”是一句成语，原意是纠正错误而超过了应有的限度。但旧时有人常用这句话去拘束人们的活动，要人们只在修正旧成规的范围内活动，而不许完全破坏旧成规。在修正旧成规的范围内活动，叫做合乎“正”，如果完全破坏旧成规，就叫做“过正”。这也正是改良派和革命队伍内机会主义者的理论。毛泽东在这里驳斥了这类改良派的理论。这里说“矫枉必须过正，不过正不能矫枉”，就是说，要终结旧的封建秩序，必须用群众的革命方法，而不是用修正的——改良的方法。\n[5] 一九二六年九月北伐军进军江西的时候，排斥共产党人的蒋介石嫡系部队打了败仗。许多报刊刊登消息说蒋介石受了伤。当时蒋介石的反革命面目还没有充分暴露出来，农民群众还认为他是革命的；地主富农则反对他，听到北伐军打败仗和蒋介石受伤的消息后很高兴。一九二七年四月十二日，蒋介石在上海发动反革命政变，他的反革命面目才完全暴露出来。从这时起，地主富农就对他改取拥护态度了。\n[6] 广东是第一次国内革命战争时期的最早的革命根据地。\n[7] 吴佩孚（一八七四——一九三九），山东蓬莱人，北洋直系军阀首领之一。一九二○年七月，他打败皖系军阀段祺瑞，开始左右北洋军阀的中央政权，为英美帝国主义的代理人。一九二四年十月，他在军阀混战中失败。一年后再起，到一九二六年北伐战争前，他据有直隶（今河北）南部和湖北、湖南、河南等省。北伐军从广东出发，首先打倒的敌人就是吴佩孚。\n[8] 三民主义是孙中山在中国资产阶级民主革命中提出的民族、民权、民生三个问题的原则和纲领。随着时代的不同，三民主义的内容有新旧的区别。旧三民主义是中国旧民主主义革命的纲领。一九二四年一月，孙中山接受共产党人的建议，在中国国民党第一次全国代表大会上，对三民主义重新作了解释，旧三民主义从此发展为新三民主义。新三民主义包含联俄、联共、扶助农工的三大政策和反对帝国主义、反对封建主义的纲领，是第一次国内革命战争时期中国共产党同国民党合作的政治基础。参见本书第二卷《新民主主义论》第十节。\n[9] 不应当容许富农加入农会。一九二七年时期，农民群众还不知道这一点。\n[10] 见本卷《中国社会各阶级的分析》注〔10〕。\n[11] 指当时的国民党县党部。\n[12] 袁祖铭，贵州军阀，在一九二六年六月至一九二七年一月期间曾经盘据湘西一带。\n[13] 亩捐是当时县、区、乡豪绅政权除抽收原有田赋之外，另行按田亩摊派的一种苛捐。这种捐税连租种地主土地的贫苦农民都要直接负担。\n[14] 督军是北洋军阀统治时期管辖一省的军事首脑。督军大都总揽全省的军事政治大权，对外勾结帝国主义，对内实行地方性的封建军事割据，是一省范围内的独裁者。\n[15] 都总、团总是都、团政权机关的头领。\n[16] “挨户团”是当时湖南农村武装的一种，它分常备队和非常备队两部分。“挨户”是形容几乎每一户人家都要参加的意思。在一九二七年革命失败以后，许多地方的“挨户团”被地主所夺取，变成了反革命的武装组织。\n[17] 当时在武汉国民党中央领导下的各地国民党县党部，很多是属于执行孙中山联俄、联共、扶助农工三大政策的组织，是共产党人、左派国民党员和其它革命分子的革命联盟。\n[18] 这句话引自《孟子•尽心上》，大意是说善于教人射箭的人，引满了弓，却不射出去，只摆着跃跃欲动的姿势。毛泽东在这里是借来比喻共产党人应当善于教育和启发农民，使农民自觉地去破除迷信和其它不良的风俗习惯，而不是不顾农民的觉悟程度，靠发号施令代替农民去破除。\n[19] 唐生智是当时站在革命方面参加北伐的一个将军。叶开鑫是当时站在北洋军阀方面反对革命的一个将军。\n[20] 孙传芳（一八八五——一九三五），山东泰安人，北洋直系军阀。一九二五年十一月以后，曾经统治浙江、福建、江苏、安徽、江西五省。他镇压过上海工人的起义。一九二六年九月至十一月间，他的军队主力在江西的南昌、九江一带，被北伐军击溃。\n[21] 东方文化主义，是排斥近代科学文明，标榜和宣扬东方落后的农业生产和封建文化的一种反动思想。\n[22] 会党指哥老会等旧中国民间秘密团体。参见本卷《中国社会各阶级的分析》注〔17〕。\n[23] 山、堂、香、水，是旧中国民间秘密团体的一些宗派的称号。\n[24] 一九二六年十一月至一九二七年三月，蒋介石把国民革命军总司令部设在南昌。蒋介石在南昌集合了国民党右派和一部分北洋军阀的政客，勾结帝国主义，策划反革命的阴谋，形成了与当时的革命中心武汉对抗的局面。\n[25] 张静江（一八七七——一九五○），浙江湖州人。当时任国民党中央执行委员会常务委员会代理主席，是国民党右派头子之一，为蒋介石设谋画策的人。\n[26] 刘岳峙，湖南国民党右派组织“左社”的头子。一九二七年二月，他被当时还执行革命政策的国民党湖南省党部清洗出党，成为人所共知的反动分子。\n[27] 叶公好龙，见汉朝刘向所作《新序•杂事》：“叶公子高好龙，钩以写龙，凿以写龙，屋室雕文以写龙。于是天龙闻而下之，窥头于牖，施尾于堂。叶公见之，弃而还走，失其魂魄，五色无主。是叶公非好龙也，好夫似龙而非龙者也。”毛泽东在这里用以比喻蒋介石辈口谈革命，实际上畏惧革命，反对革命。\n","date":"2021-06-20T00:00:00Z","permalink":"https://haolovelin.com/post/%E8%AF%BB%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86%E7%AC%AC%E4%B8%80%E5%8D%B7%E6%B9%96%E5%8D%97%E5%86%9C%E6%B0%91%E8%BF%90%E5%8A%A8%E8%80%83%E5%AF%9F%E6%8A%A5%E5%91%8A/","title":"读《毛泽东选集（第一卷）》湖南农民运动考察报告"},{"content":"《中国社会各阶级的分析》原文 （一九二五年十二月一日）\n文章背景：\n毛泽东此文是为反对当时党内存在着的两种倾向而写的。当时党内的第一种倾向，以陈独秀为代表，只注意同国民党合作，忘记了农民，这是右倾机会主义。第二种倾向，以张国焘为代表，只注意工人运动，同样忘记了农民，这是“左”倾机会主义。这两种机会主义都感觉自己力量不足，而不知道到何处去寻找力量，到何处去取得广大的同盟军。毛泽东指出中国无产阶级的最广大和最忠实的同盟军是农民，这样就解决了中国革命中的最主要的同盟军问题。毛泽东并且预见到当时的民族资产阶级是一个动摇的阶级，他们在革命高涨时将要分化，其右翼将要跑到帝国主义方面去。一九二七年所发生的事变，证明了这一点。\n正文：　​\t谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。中国过去一切革命斗争成效甚少，其基本原因就是因为不能团结真正的朋友，以攻击真正的敌人。革命党是群众的向导，在革命中未有革命党领错了路而革命不失败的。我们的革命要有不领错路和一定成功的把握，不可不注意团结我们的真正的朋友，以攻击我们的真正的敌人。我们要分辨真正的敌友，不可不将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析。 中国社会各阶级的情况是怎样的呢？ 地主阶级和买办阶级。在经济落后的半殖民地的中国，地主阶级和买办阶级完全是国际资产阶级的附庸，其生存和发展，是附属于帝国主义的。这些阶级代表中国最落后的和最反动的生产关系，阻碍中国生产力的发展。他们和中国革命的目的完全不兼容。特别是大地主阶级和大买办阶级，他们始终站在帝国主义一边，是极端的反革命派。其政治代表是国家主义派[1]和国民党右派。 中产阶级。这个阶级代表中国城乡资本主义的生产关系。中产阶级主要是指民族资产阶级，他们对于中国革命具有矛盾的态度：他们在受外资打击、军阀压迫感觉痛苦时，需要革命，赞成反帝国主义反军阀的革命运动；但是当着革命在国内有本国无产阶级的勇猛参加，在国外有国际无产阶级的积极援助，对于其欲达到大资产阶级地位的阶级的发展感觉到威胁时，他们又怀疑革命。其政治主张为实现民族资产阶级一阶级统治的国家。有一个自称为戴季陶[2]“真实信徒”的，在北京《晨报》[3]上发表议论说：“举起你的左手打倒帝国主义，举起你的右手打倒共产党。”这两句话，画出了这个阶级的矛盾惶遽状态。他们反对以阶级斗争学说解释国民党的民生主义，他们反对国民党联俄和容纳共产党[[4]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn4)及左派分子。但是这个阶级的企图——实现民族资产阶级统治的国家，是完全行不通的，因为现在世界上的局面，是革命和反革命两大势力作最后斗争的局面。这两大势力竖起了两面大旗：一面是红色的革命的大旗，第三国际[[5]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn5)高举着，号召全世界一切被压迫阶级集合于其旗帜之下；一面是白色的反革命的大旗，国际联盟[[6]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn6)高举着，号召全世界一切反革命分子集合于其旗帜之下。那些中间阶级，必定很快地分化，或者向左跑入革命派，或者向右跑入反革命派，没有他们“独立”的余地。所以，中国的中产阶级，以其本阶级为主体的“独立”革命思想，仅仅是一个幻想。 小资产阶级。如自耕农[[7]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn7)，手工业主，小知识阶层——学生界、中小学教员、小员司、小事务员、小律师，小商人等都属于这一类。这一个阶级，在人数上，在阶级性上，都值得大大注意。自耕农和手工业主所经营的，都是小生产的经济。这个小资产阶级内的各阶层虽然同处在小资产阶级经济地位，但有三个不同的部分。第一部分是有余钱剩米的，即用其体力或脑力劳动所得，除自给外，每年有余剩。这种人发财观念极重，对赵公元帅礼拜最勤，虽不妄想发大财，却总想爬上中产阶级地位。他们看见那些受人尊敬的小财东，往往垂着一尺长的涎水。这种人胆子小，他们怕官，也有点怕革命。因为他们的经济地位和中产阶级颇接近，故对于中产阶级的宣传颇相信，对于革命取怀疑的态度。这一部分人在小资产阶级中占少数，是小资产阶级的右翼。第二部分是在经济上大体上可以自给的。这一部分人比较第一部分人大不相同，他们也想发财，但是赵公元帅[[8]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn8)总不让他们发财，而且因为近年以来帝国主义、军阀、封建地主、买办大资产阶级的压迫和剥削，他们感觉现在的世界已经不是从前的世界。他们觉得现在如果只使用和从前相等的劳动，就会不能维持生活。必须增加劳动时间，每天起早散晚，对于职业加倍注意，方能维持生活。他们有点骂人了，骂洋人叫“洋鬼子”，骂军阀叫“抢钱司令”，骂土豪劣绅叫“为富不仁”。对于反帝国主义反军阀的运动，仅怀疑其未必成功（理由是：洋人和军阀的来头那么大），不肯贸然参加，取了中立的态度，但是绝不反对革命。这一部分人数甚多，大概占小资产阶级的一半。第三部分是生活下降的。这一部分人好些大概原先是所谓殷实人家，渐渐变得仅仅可以保住，渐渐变得生活下降了。他们每逢年终结账一次，就吃惊一次，说：“咳，又亏了！”这种人因为他们过去过着好日子，后来逐年下降，负债渐多，渐次过着凄凉的日子，“瞻念前途，不寒而栗”。这种人在精神上感觉的痛苦很大，因为他们有一个从前和现在相反的比较。这种人在革命运动中颇要紧，是一个数量不小的群众，是小资产阶级的左翼。以上所说小资产阶级的三部分，对于革命的态度，在平时各不相同；但到战时，即到革命潮流高涨、可以看得见胜利的曙光时，不但小资产阶级的左派参加革命，中派亦可参加革命，即右派分子受了无产阶级和小资产阶级左派的革命大潮所裹挟，也只得附和着革命。我们从一九二五年的五卅运动[[9]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn9)和各地农民运动的经验看来，这个断定是不错的。 半无产阶级。此处所谓半无产阶级，包含：（一）绝大部分半自耕农[[10]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn10)，（二）贫农，（三）小手工业者，（四）店员[[11]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn11)，（五）小贩等五种。绝大部分半自耕农和贫农是农村中一个数量极大的群众。所谓农民问题，主要就是他们的问题。半自耕农、贫农和小手工业者所经营的，都是更细小的小生产的经济。绝大部分半自耕农和贫农虽同属半无产阶级，但其经济状况仍有上、中、下三个细别。半自耕农，其生活苦于自耕农，因其食粮每年大约有一半不够，须租别人田地，或者出卖一部分劳动力，或经营小商，以资弥补。春夏之间，青黄不接，高利向别人借债，重价向别人籴粮，较之自耕农的无求于人，自然景遇要苦，但是优于贫农。因为贫农无土地，每年耕种只得收获之一半或不足一半；半自耕农则租于别人的部分虽只收获一半或不足一半，然自有的部分却可全得。故半自耕农的革命性优于自耕农而不及贫农。贫农是农村中的佃农，受地主的剥削。其经济地位又分两部分。一部分贫农有比较充足的农具和相当数量的资金。此种农民，每年劳动结果，自己可得一半。不足部分，可以种杂粮、捞鱼虾、饲鸡豕，或出卖一部分劳动力，勉强维持生活，于艰难竭蹶之中，存聊以卒岁之想。故其生活苦于半自耕农，然较另一部分贫农为优。其革命性，则优于半自耕农而不及另一部分贫农。所谓另一部分贫农，则既无充足的农具，又无资金，肥料不足，土地歉收，送租之外，所得无几，更需要出卖一部分劳动力。荒时暴月，向亲友乞哀告怜，借得几斗几升，敷衍三日五日，债务丛集，如牛负重。他们是农民中极艰苦者，极易接受革命的宣传。小手工业者所以称为半无产阶级，是因为他们虽然自有简单的生产手段，且系一种自由职业，但他们也常常被迫出卖一部分劳动力，其经济地位略与农村中的贫农相当。因其家庭负担之重，工资和生活费用之不相称，时有贫困的压迫和失业的恐慌，和贫农亦大致相同。店员是商店的雇员，以微薄的薪资，供家庭的费用，物价年年增长，薪给往往须数年一增，偶与此辈倾谈，便见叫苦不迭。其地位和贫农及小手工业者不相上下，对于革命宣传极易接受。小贩不论肩挑叫卖，或街畔摊售，总之本小利微，吃着不够。其地位和贫农不相上下，其需要一个变更现状的革命，也和贫农相同。 无产阶级。现代工业无产阶级约二百万人。中国因经济落后，故现代工业无产阶级人数不多。二百万左右的产业工人中，主要为铁路、矿山、海运、纺织、造船五种产业的工人，而其中很大一个数量是在外资产业的奴役下。工业无产阶级人数虽不多，却是中国新的生产力的代表者，是近代中国最进步的阶级，做了革命运动的领导力量。我们看四年以来的罢工运动，如海员罢工[[12]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn12)、铁路罢工[[13]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn13)、开滦和焦作煤矿罢工[[14]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn14)、沙面罢工[[15]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn15)以及“五卅”后上海香港两处的大罢工[[16]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn16)所表现的力量，就可知工业无产阶级在中国革命中所处地位的重要。他们所以能如此，第一个原因是集中。无论哪种人都不如他们的集中。第二个原因是经济地位低下。他们失了生产手段，剩下两手，绝了发财的望，又受着帝国主义、军阀、资产阶级的极残酷的待遇，所以他们特别能战斗。都市苦力工人的力量也很可注意。以码头搬运夫和人力车夫占多数，粪夫清道夫等亦属于这一类。他们除双手外，别无长物，其经济地位和产业工人相似，惟不及产业工人的集中和在生产上的重要。中国尚少新式的资本主义的农业。所谓农村无产阶级，是指长工、月工、零工等雇农而言。此等雇农不仅无土地，无农具，又无丝毫资金，只得营工度日。其劳动时间之长，工资之少，待遇之薄，职业之不安定，超过其它工人。此种人在乡村中是最感困难者，在农民运动中和贫农处于同一紧要的地位。 此外，还有数量不小的游民无产者，为失了土地的农民和失了工作机会的手工业工人。他们是人类生活中最不安定者。他们在各地都有秘密组织，如闽粤的“三合会”，湘鄂黔蜀的“哥老会”，皖豫鲁等省的“大刀会”，直隶及东三省的“在理会”，上海等处的“青帮”[[17]](https://www.marxists.org/chinese/maozedong/marxist.org-chinese-mao-19251201.htm#_ftn17)，都曾经是他们的政治和经济斗争的互助团体。处置这一批人，是中国的困难的问题之一。这一批人很能勇敢奋斗，但有破坏性，如引导得法，可以变成一种革命力量。 综上所述，可知一切勾结帝国主义的军阀、官僚、买办阶级、大地主阶级以及附属于他们的一部分反动知识界，是我们的敌人。工业无产阶级是我们革命的领导力量。一切半无产阶级、小资产阶级，是我们最接近的朋友。那动摇不定的中产阶级，其右翼可能是我们的敌人，其左翼可能是我们的朋友——但我们要时常提防他们，不要让他们扰乱了我们的阵线。\n注释\n[1] 国家主义派指中国青年党，当时以其外围组织“中国国家主义青年团”的名义公开进行活动。组织这个政团的是一些反动政客，他们投靠帝国主义和当权的反动派，把反对中国共产党和苏联当作职业。\n[2] 戴季陶（一八九一——一九四九），又名传贤，原籍浙江湖州，生于四川广汉。早年参加中国同盟会，从事过反对清政府和袁世凯的活动。后曾和蒋介石在上海共同经营交易所的投机事业。一九二五年随着孙中山的逝世和革命高潮的到来，他歪曲孙中山学说的革命内容，散布反对国共合作、反对工农革命运动的谬论，为后来蒋介石的反共活动作了准备。一九二七年南京国民政府成立后，历任国民政府委员、考试院院长等职。一九四九年二月，蒋介石的统治即将崩溃，戴季陶感到绝望而自杀。\n[3] 北京《晨报》，初名《晨钟报》，一九一六年八月创刊于北京，一九一八年十二月改名为《晨报》，一九二八年六月停刊。\n[4] 一九二二年和一九二三年间，孙中山在共产党人的帮助下，决定改组国民党，实行国共合作，容纳共产党人参加国民党，并于一九二四年一月在广州召开国民党第一次全国代表大会，实行联俄、联共、扶助农工的三大政策。李大钊、谭平山、毛泽东、林伯渠、瞿秋白等共产党人参加了这次大会。他们曾经被选为国民党中央执行委员会的委员或候补委员，担任过国民党的许多领导工作，对于帮助国民党走上革命的道路，起了重大的作用。\n[5] 第三国际即共产国际，一九一九年三月在列宁领导下成立。一九二二年中国共产党参加共产国际，成为它的一个支部。一九四三年五月，共产国际执行委员会主席团通过决定，提议解散共产国际，同年六月共产国际正式宣布解散。\n[6] 国际联盟简称国联，一九二○年一月正式成立。先后参加的有六十多个国家。国际联盟标榜以“促进国际合作，维持国际和平与安全”为目的，实际上日益成为帝国主义国家推行侵略政策的工具。第二次世界大战爆发后无形瓦解，一九四六年四月正式宣布解散。\n[7] 这里是指中农。\n[8] 赵公元帅是中国民间传说的财神，叫赵公明。\n[9] 指一九二五年五月三十日爆发的反帝爱国运动。一九二五年五月间，上海、青岛的日本纱厂先后发生工人罢工的斗争，遭到日本帝国主义和北洋军阀的镇压。上海内外棉第七厂日本资本家在五月十五日枪杀了工人顾正红，并伤工人十余人。二十九日青岛工人被反动政府屠杀八人。五月三十日，上海二千余学生分头在公共租界各马路进行宣传讲演，一百余名遭巡捕（租界内的警察）逮捕，被拘押在南京路老闸巡捕房内，引起了学生和市民的极大愤慨，有近万人聚集在巡捕房门口，要求释放被捕学生。英帝国主义的巡捕向群众开枪，打死打伤许多人。这就是震惊中外的五卅惨案。六月，英日等帝国主义在上海和其它地方继续进行屠杀。这些屠杀事件激起了全国人民的公愤。广大的工人、学生和部分工商业者，在许多城市和县镇举行游行示威和罢工、罢课、罢市，形成了全国规模的反帝爱国运动高潮。\n[10] 这里是指自己有一部分土地，同时租种一部分土地，或出卖一部分劳动力，或兼营小商的贫农。\n[11] 店员有不同的阶层，他们一般不占有生产资料，生活来源的全部或者主要部分是依靠向店主出卖劳动力所取得的工资。毛泽东在这里所指的是店员中的一部分，还有一部分下层店员过着无产阶级的生活。\n[12] 指一九二二年香港和上海的海员罢工。香港海员罢工爆发于一月十二日，坚持了八个星期。最后，香港英帝国主义当局被迫答应增加工资，恢复原工会，释放被捕工人，抚恤在罢工中死难烈士的家属。上海海员罢工于八月五日开始，坚持了三个星期，也得到胜利。\n[13] 指一九二二年和一九二三年中国共产党领导的各主要铁路线的工人罢工。在罢工过程中，工人群众的觉悟迅速提高，要求改善生活的经济斗争迅速发展为反对军阀的政治斗争。一九二三年二月四日，京汉铁路工人为争取组织总工会的自由，举行总罢工。其它许多铁路的工人也纷纷响应。二月七日，英帝国主义支持的北洋军阀吴佩孚、萧耀南等，残酷地屠杀京汉铁路的工人，造成了二七惨案。\n[14] 开滦煤矿是直隶省（今河北省）开平、滦县一带煤矿的总称，当时为英帝国主义者所控制。开滦罢工指一九二二年十月、十一月间矿工三万余人举行的大罢工。英帝国主义者和北洋军阀对这次罢工进行残酷的镇压，工人死伤很多，但是仍然坚持斗争。最后，英帝国主义者不得不答应给工人增加一部分工资。焦作煤矿，在河南省北部，当时也为英帝国主义者所控制。焦作罢工指一九二五年七月爆发的罢工。这次罢工是为响应五卅运动而发动的，前后坚持七个多月。最后，英帝国主义者不得不承认工会有代表工人的权利，并且被迫接受增加工资、不无故开除工人和补偿工人因罢工所受的损失等项条件。\n[15] 沙面当时是英法帝国主义在广州的租界。一九二四年七月，统治沙面的帝国主义者颁布新警律，规定沙面的中国人出入租界必须携带贴有本人相片的执照，在租界内行动必须受各种苛刻的限制，但是外国人却可以自由出入活动。沙面工人于七月十五日宣告罢工，抗议这些无理措施。这次沙面罢工迫使英法帝国主义者取消了新警律。\n[16] 指一九二五年六月一日开始的上海大罢工和六月十九日开始的香港大罢工。这两处罢工是当时全国反帝爱国运动的支柱。前者有二十多万工人参加，坚持了三四个月；后者有二十五万工人参加，坚持了一年零四个月，是截至当时为止的世界工人运动史中时间最长的一次罢工。\n[17] 三合会、哥老会、大刀会、在理会、青帮是旧中国的一些民间秘密团体，参加者主要的是破产农民、失业手工业工人和流氓无产者。这类团体大都用宗教迷信为团聚成员的工具，采取家长制的组织形式，有的还拥有武装。参加这类团体的人，在社会生活中有互相援助的义务，有时还共同反抗压迫他们的地主、官僚和外国侵略者。但是，农民和手工业工人不可能依靠这类团体得到出路。同时，由于这类团体带有严重的封建性和盲目的破坏性，它们又往往容易被反动统治阶级和帝国主义势力所操纵和利用。随着工人阶级力量的壮大和中国共产党的成立，农民和手工业工人在共产党的领导之下逐步地建立了完全新式的群众组织，这类落后的团体就失掉了它们的存在价值。\n感悟 教员开篇说：谁是我们的敌人？谁是我们的朋友？这个问题是革命的首要问题。\n为什么是首要问题？因为当时处于国共合作的革命时期，而革命想要取得成效应该要明确敌友，如果不能正确地分辨敌人，则即使每个人都出了力地去革命，如果力气没有使用在针对敌人的方面，则是在做徒劳的事情。同时也需要分清楚谁是我们的朋友，因为革命需要人的力量，而如果单单仅靠共产党以及领导的工人群众的力量（左倾），是不足够的，而依靠国民党的支持，是不完全可靠的（右倾），因为国民党在当时有排外的心理，不能很好地和我们互帮互助，而无论是左倾还是右倾，都会感到革命力量的不足，因此我们需要去寻找更多的朋友来增强我们的力量。\n那么教员是如何区分敌友的呢？他将中国社会各阶级的经济地位及其对于革命的态度，作一个大概的分析来得出谁是敌人，谁是朋友。教员对以下几个阶级做了分析：\n地主阶级和买办阶级 中产阶级 小资产阶级 半无产阶级 无产阶级 游民无产者 教员对当时的阶级情况已经划分得非常清楚了，我们也按照现今社会的收入状况和收入来源，来划分一下上述的阶级。收入状况决定生活水平。收入来源分成两种，一种叫做主动收入，就是必须每天劳动，才能获得的收入，叫做主动收入。一种叫做被动收入，就是月底就有的租金，年底就有的分红，叫做被动收入，这种收入，归根结底，是由于他们拥有生产资料（也就是工厂、地皮、资金股票之类的）。\n地主阶级和买办阶级、中产阶级这几个解析基本上大部分的收入来源就是被动收入，他们手中掌握着生产资料，而自己却没有去为社会创造价值，他们依靠剥削劳动人民来获得利益。\n剩下的阶级几乎都是没有掌握生产资料，依靠劳动，来获得主动收入，是真正为社会创造价值的主要群体。\n举几个具体的例子：\n地主阶级如马x、马xx、王xx 中产阶级如中小企业的老板 小资产阶级如程序员、财务、作家、公司中管等职业 半无产阶级如快递员、外卖员、农民 游民阶级如三和大神 当然只是大概而论，不能代表极个别特殊情况，比如唐家xx，本来大部分作家应该属于小资产阶级，但是部分名气大的却属于中产阶级。依靠主动收入的，都是属于广大劳动人民，都是我们可以团结的朋友。教员认为我们是可以争取中间阶级的支持的，因为那些中间阶级，必定很快的分化，或者向左跑入革命派，或者向右跑入反革命派，没有他们“独立”的余地。就如电影中的那一句话：“谁赢他们支持谁。”但我们要时常提防他们，不要让他们扰乱了我们的阵线。\n","date":"2021-06-14T00:00:00Z","permalink":"https://haolovelin.com/post/%E8%AF%BB%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86%E7%AC%AC%E4%B8%80%E5%8D%B7%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E5%90%84%E9%98%B6%E7%BA%A7%E7%9A%84%E5%88%86%E6%9E%90/","title":"读《毛泽东选集（第一卷）》中国社会各阶级的分析"},{"content":"十六、一些Java有关面试题 1.为什么局部内部类访问局部变量需要final? 用final修饰实际上就是为了保护数据的一致性。\n这里所说的数据一致性，对引用变量来说是引用地址的一致性，对基本类型来说就是值的一致性。\n这里我插一点，final修饰符对变量来说，深层次的理解就是保障变量值的一致性。为什么这么说呢？因为引用类型变量其本质是存入的是一个引用地址，说白了还是一个值（可以理解为内存中的地址值）。用final修饰后，这个这个引用变量的地址值不能改变，所以这个引用变量就无法再指向其它对象了。\n回到正题，为什么需要用final保护数据的一致性呢？\n因为将数据拷贝完成后，如果不用final修饰，则原先的局部变量可以发生变化。这里到了问题的核心了，如果局部变量发生变化后，匿名内部类是不知道的（因为他只是拷贝了局不变量的值，并不是直接使用的局部变量）。这里举个栗子：原先局部变量指向的是对象A，在创建匿名内部类后，匿名内部类中的成员变量也指向A对象。但过了一段时间局部变量的值指向另外一个B对象，但此时匿名内部类中还是指向原先的A对象。那么程序再接着运行下去，可能就会导致程序运行的结果与预期不同。\n2.String、StringBuffer、StringBuilder、CharSequence的区别。 String是final类型的，内部是一个char型的数组每次进行增加操作需要生成新的对象，频繁增加会效率低下还容易出现内存抖动\nStringBuffer是线程安全的，增删操作在原有的对象进行改变，不会新建对象，适合多线程的情况下\nStringBuilder是线程不安全的，增删操作在原有的对象进行改变，不会新建对象，适合单线程的情况下，效率最高，最快。\nCharSequence是一个描述字符串结构的接口，String、StringBuffer、StringBuilder都实现了该接口。\n现在只要有字符串就可以为CharSequence实例化，CharSequence本身是一个接口，在该接口中有如下方法：\n获取指定索引的字符：public char charAt(int index)； 获取字符串长度：public int length()； 截取部分字符串：public CharSequence subSequence(int start, int end)； 范例：字符串截取 public static void main(String[] args) { CharSequence str = \u0026#34;hello world\u0026#34;; CharSequence sub = str.subSequence(6,11); System.out.println(sub); } CharSequence描述的就是一个字符串，以后见到就不要感觉的陌生了。\n3.equals和==的区别？ 如果不重写equals方法，那么默认继承的是Object类的equals，这样就会使用==去比较两个对象。\n由equals的源码可以看出这里定义的equals与==是等效的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）对equals进行了重写。\n但是没有对equals进行重写的类就只能从Object类中继承equals方法，其equals方法与==就也是等效的，除非在此类中重写equals。\n对equals重新需要注意五点：\n1、自反性：对任意引用值X，x.equals(x)的返回值一定为true；\n2、对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；\n3、传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ；\n4、一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；\n5、非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。\n==：\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。\n1、比较的是操作符两端的操作数是否是同一个对象。\n2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\n3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\n4.关于字符串的拼接你在项目中常常怎么操作的？为什么不能用“+”的方式进行拼接呢？ 如果是小量的操作一般是直接+，但是如果需要频繁地去进行拼接，那我先看是不是需要多线程进行操作，多线程我使用StringBuffer，单线程我使用StringBuilder。\n5.什么是Callback,讲讲你项目中使用的一些有关Callback的栗子。 Callback是回调的意思，一般我们需要2个类需要相互掉用，一个类把数据动态传递给另外一个类的时候，可以用这种方式，比如Android里面的Launcher类和LauncherModel类，LauncherModel里面有接口很多没有实现的方法，Launcher实现LauncherModel的接口，实现方法，传递数据给LauncherModel类。\nAndroid播放器事件的回调。\n6.retrun \u0026amp; break \u0026amp; continue 区别？ return语句就是用于指定方法返回的值。return语句只能出现在方法内，出现在代码中的其他任何地方都会造成语法错误！\nbreak用于完全结束一个循环或者switch，跳出循环体，当在循环体中遇到break时，该循环会终止，开始执行该循环之后的代码。\ncontinue语句和break语句相似。不同的是，它不是退出一个循环，而是开始循环的一次新迭代。\n7.如何判断一个字符串是回文字符串？ 逐步比较charAt(i)和charAt(s.length()-1-i)，直到i过半。\n8.final,finally,finalize的区别？ final修饰的变量、方法、类，声明成最终类型，类无法被继承，方法无法被重写、变量无法被修改。\nfinally是异常处理的一个语句块，作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行。（不一定，如果被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。）\nfinalize是对象被GC回收的时候才会调用。\n1、final 修饰符（关键字）\nfinal用于控制成员、方法或者是一个类是否可以被重写或者继承等功能。 （1）如果类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。 （2）将变量或者方法声明为final，可以保证他们在使用中不被改变。其初始化可以在两个地方：一是其定义处，也就是说，在final变量定义时直接给其赋值；二是构造函数中。这2个地方只能选其一，要么在定义处直接给其赋值，要么在构造函数中给值，并且在以后的引用中，只能读取，不可修改。被声明为final的方法也同样只能使用，不能重写。\n2、finally(用于异常处理)\n一般是用于异常处理中，提供finally块来执行任何的清楚操作，try{} catch(){} finally{}。finally关键字是对java异常处理模型的最佳补充。**finally结构使代码总会执行，不关有无异常发生。**使得finally可以维护对象的内部状态，并可以清理非内存资源。 finally在try,catch中可以有，可以没有。如果trycatch中有finally则必须执行finally块中的操作。一般情况下，用于关闭文件的读写操作，或者是关闭数据库的连接等等。\n3、finalize（用于垃圾回收）\nfinalize这个是方法名。在java中，允许使用finalize()方法在垃圾收集器将对象从内存中清理出去之前做必要的清理工作。这个方法是Object类中定义的，因此，所有的类都继承了它。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 一旦垃圾回收器准备释放对象所占的内存空间，如果对象覆盖了Object的finalize()并且函数体内不为空，就会首先调用对象的finalize()，然后在下一次垃圾回收动作发生的时候真正回收对象所占的空间。 尽量避免使用finalize()： 1、finalize()不一定会被调用, 因为java的垃圾回收器的特性就决定了它不一定会被调用. 2、就算finalize()函数被调用, 它被调用的时间充满了不确定性, 因为程序中其他线程的优先级远远高于执行finalize()函数线程的优先级。也许等到finalize()被调用,数据库的连接池或者文件句柄早就耗尽了. 3、如果一种未被捕获的异常在使用finalize方法时被抛出，这个异常不会被捕获，finalize方法的终结过程也会终止，造成对象出于破坏的状态。被破坏的对象又很可能导致部分资源无法被回收, 造成浪费. 4、finalize()和垃圾回收器的运行本身就要耗费资源, 也许会导致程序的暂时停止.\n9.什么是动态代理 \u0026amp; 什么是静态代理？ 更通俗的说，代理解决的问题当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可，而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理，但是切记，代理类和委托类要实现相同的接口，因为代理真正调用的还是委托类的方法。\n按照代理的创建时期，代理类可以分为两种：\n静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的**.class文件就已经存在了**。\n动态：在程序运行时运用反射机制动态创建而成。\n10.String为什么会加final？ 为了效率。若允许被继承，则其高度的被使用率可能会降低程序的性能。\n为了安全。JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了， 就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性\n11.OOM可以try{}catch{}吗？ 可以，但是没必要，而且也不建议这样做，因为catch了之后并不能解决什么问题。\n在catch语句中，可以释放掉这些对象，解决OOM的问题，继续执行剩余语句。\n但是这通常不是合适的做法。\nJava中管理内存除了显式地catch OOM之外还有更多有效的方法：比如SoftReference, WeakReference, 硬盘缓存等。 在JVM用光内存之前，会多次触发GC，这些GC会降低程序运行的效率。\n12.给我谈谈正则表达式。 在Java里面来学习正则表达式的目的主要就是使用正则表达式来处理字符串复杂的 查找find/替换replace/匹配matches/分割split工作\n使用步骤: 1.通过大量的字符串找规律定义规则\n2.使用这种规则去匹配新的字符串\n3.匹配成功作出相应的操作(匹配 查找 替换 分割)\n13.如何将String转成int? int i = Integer.valueOf(s);\nint j = Integer.parseInt(s);\n14.谈谈你对String的理解。 两种创建字符串的方式，拼接用StringBuffer或者StringBuilder比较好，直接+拼接会产生新的对象\n内部是个final类型的char[]，重写了hashcode和equals方法\n15.你如何理解序列化？有哪些方式序列化？ 只要对象实现了Serializable接口，该对象就可以进行序列化。Serializable接口只是一个标记接口，不包括任何属性和方法。\ntransient是Java关键字之一，可以用来修饰属性，可以防止属性被序列化。\n子类能够继承父类的序列化功能\n引用类型的属性会随着对象序列化而序列化\nAndroid：Parcelable\n鉴于Serializable在内存序列化上开销比较大，而内存资源属于android系统中的稀有资源（android系统分配给每个应用的内存开销都是有限的），为此android中提供了Parcelable接口来实现序列化操作，Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如通过Intent在activity间传输数据，而Parcelable的缺点就使用起来比较麻烦。\n简单用一句话概括来说就是通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。也可以将Parcel看成是一个类似Serliazable的读写流，通过writeToParcel把对象写到流里面，在通过createFromParcel从流里读取对象，这个过程需要我们自己来实现并且写的顺序和读的顺序必须一致。\npublic class User implements Parcelable { public int id; public String name; public User friend; /** * 当前对象的内容描述,一般返回0即可 */ @Override public int describeContents() { return 0; } /** * 将当前对象写入序列化结构中 */ @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(this.id); dest.writeString(this.name); dest.writeParcelable(this.friend, 0); } public NewClient() {} /** * 从序列化后的对象中创建原始对象 */ protected NewClient(Parcel in) { this.id = in.readInt(); this.name = in.readString(); //friend是另一个序列化对象，此方法序列需要传递当前线程的上下文类加载器，否则会报无法找到类的错误 this.friend=in.readParcelable(Thread.currentThread().getContextClassLoader()); } /** * public static final一个都不能少，内部对象CREATOR的名称也不能改变，必须全部大写。 * 重写接口中的两个方法： * createFromParcel(Parcel in) 实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层， * newArray(int size) 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。 */ public static final Parcelable.Creator\u0026lt;User\u0026gt; CREATOR = new Parcelable.Creator\u0026lt;User\u0026gt;() { /** * 从序列化后的对象中创建原始对象 */ @Override public User createFromParcel(Parcel source) { return new User(source); } /** * 创建指定长度的原始对象数组 */ @Override public User[] newArray(int size) { return new User[size]; } }; } 16.谈谈你对依赖注入的理解。 ***DI—Dependency Injection，即“依赖注入”：*组件之间依赖关系由容器在运行期决定（由容器动态的将某个依赖关系注入到组件之中）。\n依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：\n谁依赖于谁：当然是应用程序依赖于IoC容器； 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 ****IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。****比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，告诉依赖注入框架，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。\n在系统运行时，**依赖注入框架会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。**A需要依赖 Connection才能正常运行，而这个Connection是由依赖注入框架注入到A中的，依赖注入的名字就这么来的。\n17.给我谈谈你对分派的理解。 首先什么是分派呢？所谓分派，主要是针对一个方法来讲的，即方法分派。那么所谓方法分派，就是虚拟机如何确定应该执行哪个方法！ 通过了解分派，可以让我们了解到面向对象编程三大特性（继承、封装、多态）之一的多态，在JAVA语言中实现的原理。\n说到分派，它又可以为静态分派、动态分派、单分派、多分派 多态是依赖于类的继承关系的，下面的概念都是基于继承环境下解释的 下面对每一个概念进行解释\n静态分派 静态类型与实际类型\n在介绍静态分派之前，需要先了解什么是另外两个词，静态类型与实际类型 静态类型(或外观类型)，如有这样的两个类，其继承关系为Cat extends Animal, 在调用时这样调用\nAnimal tomcat = new Cat(); 那么这里的tomcat变量它的静态类型就是Animal 它的动态类型就是Cat\n静态类型解释\n在了解了静态类型与动态概念后，再了解下静态类型的定义：所有依赖静态类型来定位方法执行的分派动作称为静态分派 其比较典型的在JAVA中的应用是重载的实现原理。这里不就说DEMO了，DEMO参见下方的链接。 对于重载(overload)这个概念想必大家都非常了解，也就是方法名称相同，但参数类型或个数不同。 上面的定义用比较通俗的话来解释是，JVM在重载时（发生在编译阶段），是通过参数的静态类型来作为判断依据去找相关的执行方法的，以静态类型的方法为准。\n动态分派 上面说了重载(overload)的实现原理，这里说下重写(overWrite)的原理。 定义：在运行期根据实际类型确定执行方法的过程称为动态分派。 也就是重写时JVM选择哪个执行的方法，是根据变量的实际类型来判断的，执行实际类型的那个方法。\n单分派\n宗量\n由于单分派与多分派是根据宗量这个基准来划分的。所以首先了解下什么是宗量。 宗量：方法的接收者与方法的参数统称为方法的宗量。\n单分派定义\n根据一个宗量对目标方法进行选择，即为单分派。(动态分派属于单分派)\n多分派\n根据多于一个宗量对目标方法进行选择，即为多分派。(静态分派属于多分派)\n","date":"2021-06-13T00:00:00Z","permalink":"https://haolovelin.com/post/java16%E4%B8%80%E4%BA%9Bjava%E6%9C%89%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Java（16）一些Java有关面试题"},{"content":"十五、高级Java知识点 1.AOP是什么 \u0026amp; 和OOP区别？实现的方式有哪些？Android中如何实现？ 一、AOP概念 百度百科中对AOP的解释如下: 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\nAOP是OOP的延续，是软件开发中的一个热点，也是很多框架如 java中的Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\nAOP只是一种思想的统称，实现这种思想的方法有挺多。AOP通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发效率。\n二、AOP主要应用场景 日志记录，性能统计，安全控制，事务处理，异常处理等等。\n主要目标：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。\nAOP代码注入时机\n代码注入主要注解机制，根据注解时机的不同，主要分为运行时、加载时和编译时。\n运行时：你的代码对增强代码的需求很明确，比如，必须使用动态代理（这可以说并不是真正的代码注入）。 加载时：当目标类被Dalvik或者ART加载的时候修改才会被执行。这是对Java字节码文件或者Android的dex文件进行的注入操作。 编译时：在打包发布程序之前，通过向编译过程添加额外的步骤来修改被编译的类。aspect切面编程正是运用到编译时\nAOP的几种实现方式\nJava 中的动态代理，运行时动态创建 Proxy 类实例 APT，注解处理器，编译时生成 .java 代码 Javassist for Android：一个移植到Android平台的非常知名的操纵字节码的java库，对 class 字节码进行修改 AspectJ：和Java语言无缝衔接的面向切面的编程的扩展工具（可用于Android）。 Android中使用 AspectJ 代表项目：Hugo(打印每个方法的执行时间) sa-sdk-android（全埋点技术）\n（1）原理 AspectJ 意思就是Java的Aspect，Java的AOP。它的核心是ajc（编译器 aspectjtools）和 weaver（织入器 aspectjweaver）。\najc编译器：基于Java编译器之上的，它是用来编译.aj文件，aspectj在Java编译器的基础上增加了一些它自己的关键字和方法。因此，ajc也可以编译Java代码。\nweaver织入器：为了在java编译器上使用AspectJ而不依赖于Ajc编译器，aspectJ 5出现了 @AspectJ，使用注释的方式编写AspectJ代码，可以在任何Java编译器上使用。 由于AndroidStudio默认是没有ajc编译器的，所以在Android中使用@AspectJ来编写。它在代码的编译期间扫描目标程序，根据切点（PointCut）匹配,将开发者编写的Aspect程序编织（Weave）到目标程序的.class文件中，对目标程序作了重构（重构单位是JoinPoint），目的就是建立目标程序与Aspect程序的连接（获得执行的对象、方法、参数等上下文信息），从而达到AOP的目的。\n（2）AspectJ 术语 切面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。其实就是共有功能的实现。如日志切面、权限切面、事务切面等。\n通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为\n前置通知（Before）、 后置通知（AfterReturning）、 异常通知（AfterThrowing）、 最终通知（After） 环绕通知（Around）5种。 在实际应用中通常是切面类中的一个方法，具体属于哪类通知由配置指定的。\n切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。 连接点（JoinPoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等。\n目标对象（Target Object）：包含连接点的对象，也被称作被通知或被代理对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能等代码则是等待AOP容器的切入。\nAOP代理（AOP Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。\n编织（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器（如AspectJ编译器）；\n发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现（如摇一摇）。\n**引入（Introduction）：**添加方法或字段到被通知的类。\nAspectj：\nAspectJ除了hook之外，AspectJ还可以为目标类添加变量，接口。另外，AspectJ也有抽象，继承等各种更高级的玩法。它能够在编译期间直接修改源代码生成class。 AspectJ语法比较多，但是掌握几个简单常用的，就能实现绝大多数切片，完全兼容Java（纯Java语言开发，然后使用AspectJ注解，简称@AspectJ。） 2.APT是什么？例举一些基于它实现的轮子 \u0026amp; 自己有玩过它吗 \u0026amp; 做了些什么？ 1.什么是APT Apt编译时注解-是javac的一个工具，中文名字注解处理器。APT可以用来在编译期间扫描和处理注解。通过APT可以获取注解和备注解的相关信息，通过这些信息 动态的生成代码省去手动编写。反射是在运行时处理注解，相比反射APT效率更高。APT的核心类的是AbstractProcessor 2.用到的APT的框架 ButterKnife，EventBus，Dragger2，ARouter等 3.如何构建一个APT项目 APT项目至少需要2个Java libaray组成。 1.首先需要Annotation模块，用来存放自定义注解。 2.另外需要一个Compiler模块，这个模块依赖Annotation模块。 3.项目的App模块和其它业务模块都需要依赖Annotation模块，同时需要通过annotationProcessor依赖Complier模块。 注意：android是基于openJDK，openJDK不包括APT的相关代码。因此APT必须在java libaray中进行。\n3.字节码篡改技术了解吗？ 字节码修改技术 对Java Class字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。\n那通过了解字节码，我们可以做些什么呢？\n其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节。\nASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。\n目前字节码修改技术有ASM，javassist，cglib，BCEL等。cglib就是基于封装的Asm. Spring 就是使用cglib代理库。\nJavassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。\n4.依赖倒置（DIP）、依赖注入（DI）和控制反转（IOC） 1、依赖（Dependency） 定义 依赖是类与类之间的连接，依赖关系表示一个类依赖于另一个类的定义，通俗来讲就是需要\n2、依赖倒置(Dependence Inversion Principle) 定义 高层模块不应该依赖低层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；通俗来讲，依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。 类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。此时将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。\n3、控制反转(Inversion of Control) 定义 IoC 是一种新的设计模式，它对上层模块与底层模块进行了更进一步的解耦。控制反转的意思是反转了上层模块对于底层模块的依赖控制。\n4、依赖注入(Dependency injection) 为了不因为依赖实现的变动而去修改 Person，也就是说以可能在 Driveable 实现类的改变下不改动 Person 这个类的代码，尽可能减少两者之间的耦合需要采用IoC 模式来进行改写代码。 这个需要我们移交出对于依赖实例化的控制权，Person 无法实例化依赖了，它就需要在外部（IoC 容器）赋值给它，这个赋值的动作有个专门的术语叫做注入（injection），需要注意的是在 IoC 概念中，这个注入依赖的地方被称为 IoC 容器，但在依赖注入概念中，一般被称为注射器 （injector)。 表达通俗一点就是：我不想自己实例化依赖，你（injector）创建它们，然后在合适的时候注入给我\n实现依赖注入有 3 种方式：\n构造函数中注入 setter 方式注入 接口注入\n5.代理模式 1、代理模式基本概念及分类\n（1.1）基本概念\n为其他对象提供一种代理以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理对象起到中介的作用，可去掉功能服务或增加额外的服务。负责为委托类预处理消息，过滤消息并将请求分派给委托类处理，以及进行消息被委托类执行后的后续操作。 例如火车票代售处是火车站的代理，相对于火车站，可以提供额外的服务，如电话预约，提供额外服务的同时，会收取一定金额的手续费。也可以将原有的功能去掉，如代售处不能提供退票服务。\n（1.2）代理模式模型\n代理模式一般设计到角色有4 种： 1、抽象角色：对应代理接口（\u0026laquo; interface \u0026raquo;Subject），用来定义代理类和委托类的公共对外方法/接口； 2、真实角色：对应委托类（接口实现类RealSubject），真正实现业务逻辑的类，是代理角色所代表的真实对象，是最终要引用的对象； 3、代理角色：对应代理类（Proxy），用来代理和封装真实角色。代理角色内部含有对真实对象的引用，从而可以操作真实对象。同时，代理对象可以在执行真是对象操作时，添加或去除其他操作，相当于对真实对象进行封装； 4、客户角色：对应客户端，使用代理类和主题接口完成一些工作。在代理模式中真实角色对于客户端角色来说的透明的，也就是客户端不知道也无需知道真实角色的存在。 为了保持行为的一致性，代理角色和真实角色通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。 通过代理角色这中间一层，能有效控制对真实角色（委托类对象）的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。\n（1.3）代理模式特点\n（1.3.1）代理模式优点\n隐藏委托类的实现，调用者只需要和代理类进行交互即可。 解耦，在不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作\n（1.3.2）代理模式应用场景\n代理的使用场景很多，struts2中的 action 调用， hibernate的懒加载， spring的 AOP无一不用到代理。总结起来可分为以下几类： 1、在原方法执行之前和之后做一些操作，可以用代理来实现（比如记录Log，做事务控制等）。 2、封装真实的主题类，将真实的业务逻辑隐藏，只暴露给调用者公共的主题接口。 3、在延迟加载上的应用。\n（1.4）常见代理模式\n（1）远程代理：为不同地理的对象，提供局域网代表对象。类似客户端-服务器代理模式。 （2）虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建。如网络图片缓存。 （3）保护代理：控制用户的访问权限，如网页需要注册才能浏览发帖。 （4）智能引用代理：提供对目标对象额外的服务。如日志处理、权限管理、事务处理……\n根据代理类的生成时间不同可以将代理分为静态代理和动态代理。\n所谓静态代理也就是在程序运行前就已经存在代理类的.class文件，代理类和委托类的关系在运行前就确定了。\n通过动态代码可实现对不同类、不同方法的代理。动态代理的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件（.class）。代理类和委托类的关系在程序运行时确定。\nJDK动态代理与cglib动态代理的区别 JDK动态代理：只能代理实现了接口的类，没有实现接口的类不能实现JDK的动态代理 CGLIB动态代理：针对类来实现代理，对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用。\n静态代理与动态代理对比：\n1、静态代理 优点： 业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。 缺点： （1）代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。 （2）如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。 （3）采用静态代理模式，那么真实角色（委托类）必须事先已经存在的，并将其作为代理对象代理对象内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀。 2、动态代理 优点 1、动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。 2、动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。 缺点 JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。\n","date":"2021-06-12T00:00:00Z","permalink":"https://haolovelin.com/post/java15%E9%AB%98%E7%BA%A7java%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"Java（15）高级Java知识点"},{"content":"十四、JVM相关 1.JVM定义 JVM（虚拟机）：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的计算机系统，是物理机的软件实现。常见虚拟机有VMWare、VirtualBox、Java Virtual Machine… Java虚拟机阵营：Sun HotSpot VM、BEA JRockit VM（JDK1.8合并）… Java虚拟机是采用虚拟化技术，隔离出一块独立的子操作系统，使Java软件不受任何影响在虚拟机内进行执行。 JVM由三个主要的子系统构成：\n类加载子系统：装载具有适合名称的类或接口 运行时数据区（内存结构）：包含方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器 执行引擎：负责执行包含在已装载的类或接口中的指令\nJVM实现了Java平台的无关性\nJava是一种技术，由四个方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口（Java API） 开发人员编写Java代码，并将Java源代码文件（.java文件）通过Java编译器进行编译后形成java字节码文件（.class文件），通过类加载子系统加载到运行时数据区（内存空间），再通过JVM执行引擎进行执行。 运行期环境称为Java平台。Java平台由Java虚拟机和Java应用程序接口搭建，Java语言是进入这个平台的通道，用Java语言编写的Java源文件可以运行在这个平台上。这个平台的结构如下：\n在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。 JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。\n2.类加载子系统 （1）什么是类的加载\n类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。\n（2）类的生命周期\n类的生命周期包括加载、连接、初始化、使用和卸载：\n加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用 初始化，为类的静态变量赋予正确的初始值 使用，new出对象程序中使用 卸载，执行垃圾回收\n（3）类加载器\n启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器\n（4）类加载机制\n全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效\n3.JVM内存管理 （1）JVM内存结构（运行时数据区）\n方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行时线程私有的内存区域。 一个.class文件装载到内存后会划分为以下五部分： 方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用），程序计数器\n（1.1）Java堆（Heap） 堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的通过new创建的对象实例都在这里分配内存。当对象无法在该空间申请到内存时抛出OutOfMemoryEroor异常。同时也是垃圾收集器管理的主要区域。\nJava的堆内存基于Generation算法（Generational Collector）划分为新生代、年老代和持久代。新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。 分代收集，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，可以将不同生命周期的对象分代，不同的代采取不同的回收算法进行垃圾回收（GC），以便提高回收效率。 三区域及对象的迁移过程： （1）新生代Young Generation（1/3堆空间） 几乎所有新生成的对象首先都是放在年轻代的。新生代内存按照8:1:1的比例分为一个Eden区和两个Survivor(Survivor0,Survivor1)区。大部分对象在Eden区中生成。当新对象生成，Eden Space申请失败（因为空间不足等），则会发起一次GC(Scavenge GC)。回收时先将Eden区存活对象复制到一个Survivor0区，然后清空Eden区，当这个Survivor0区也存放满了时，则将Eden区和Survivor0区存活对象复制到另一个Survivor1区，然后清空Eden和这个Survivor0区，此时Survivor0区是空的，然后将Survivor0区和Survivor1区交换，即保持Survivor1区为空， 如此往复。当Survivor1区不足以存放 Eden和Survivor0的存活对象时，就将存活对象直接存放到老年代。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。 （2）老年代Old Generation（2/3堆空间） 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。一般来说，大对象会被直接分配到老年代。所谓的大对象是指需要大量连续存储空间的对象。 （3）元数据MetaData Space（直接内存JDK1.8后） 不属于堆内存，属于内存空间。真正与堆隔离。方法区是类逻辑上的一个抽象模板，而元空间是方法区的实现，是真实存在的内存。\n对象会首先会进入年轻代的Eden中.在GC之前对象是存在Eden和from中的，进行GC的时候Eden中的对象被拷贝到To这样一个survive空间中，From中的对象到一定次数会被复制到老年代。如果没到次数From中的对象会被复制到To中，复制完成后To中保存的是有效的对象，Eden和From中剩下的都是无效的对象，这个时候就把Eden和From中所有的对象清空。在复制的时候Eden中的对象进入To中，To可能已经满了，这个时候Eden和From中的对象就会被直接复制到Old Generation中.复制完成后，To和From的名字会对调一下，因为Eden和From都是空的，对调后Eden和To都是空的，下次分配就会分配到Eden。一直循环这个流程。好处：使用对象最多和效率最高的就是在Young Generation中，通过From to就避免过于频繁的产生FullGC（Old Generation满了一般都会产生FullGC）\n虚拟机在进行MinorGC（新生代的GC）的时候，会判断要进入OldGeneration区域对象的大小，是否大于Old Generation剩余空间大小，如果大于就会发生Full GC。 刚分配对象在Eden中，如果空间不足尝试进行GC，回收空间，如果进行了MinorGC空间依旧不够就放入Old Generation，如果OldGeneration空间还不够就OOM了。 比较大的对象，数组等，大于某值（可配置）就直接分配到老年代，（避免频繁内存拷贝） 年轻代和年老代属于Heap空间的，Permanent Generation（永久代）可以理解成方法区，（它属于方法区）也有可能发生GC，例如类的实例对象全部被GC了，同时它的类加载器也被GC掉了，这个时候就会触发永久代中对象的GC。 如果OldGeneration满了就会产生FullGC。老年代满原因：1、from survive中对象的生命周期到一定阈值2、分配的对象直接是大对象3、由于To 空间不够，进行GC直接把对象拷贝到年老代（年老代GC时候采用不同的算法） 如果Young Generation大小分配不合理或空间比较小，这个时候导致对象很容易进入Old Generation中，而Old Generation中回收具体对象的时候速度是远远低于Young Generation回收速度。 因此实际分配要考虑年老代和新生代的比例，考虑Eden和survives的比例，提升系统性能。 Permanent Generation中发生GC的时候也对性能影响非常大，也是Full GC。 （1.2）方法区（Method Area） 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，类的所有字段和方法的字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在方法区中\n（1.3）程序计数器（Program Counter Register） 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。他是线程私有的。可看做一个指针，指向方法区中的方法字节码（用来存储指向下一跳指令的地址，也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计。 每个方法在运行时都存储着一个独立的程序计数器，程序计数器是指定程序运行的行数指针。\n（1.4）JVM栈（JVM Stacks） 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。Java栈描述的是Java方法执行的内存模型：一个线程对应一个栈，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。不存在垃圾回收问题，只要线程已结束栈就出栈，生命周期与线程一致。 方法出口指向下次执行的栈帧（方法）\n内存说明： 基础数据类型直接在栈空间分配 方法的形式参数直接在栈空间分配，方法调用完成后从栈空间回收 引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量。栈中的地址空间指向堆空间的对象区。 方法的引用参数，在栈空间分配一个地址空间，指向堆空间的对象区，方法调用完成后从栈空间回收。 创建new的局部变量，在栈中和堆中分配空间，当局部变量生命周期结束后，栈空间立刻回收，堆空间区域等待GC回收。 字符串常量,static静态变量在方法区分配空间。\n（1.5）本地方法栈（Native Method Stacks） 线程私有，可理解为java中jni调用。用于支持native方法执行，存储了每个native方法调用的状态。本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。执行引擎通过本地方法接口，利用本地方法库（C语言库）执行。\n（2）对象分配规则 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。\n4.GC算法 垃圾回收 垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。 注意：垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。但不能说是回收对象，可以理解为一种文字游戏。 引用：如果Reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 垃圾：无任何对象引用的对象。 回收：清理“垃圾”占用的内存空间而非对象本身。 发生地点：一般发生在堆内存中，因为大部分的对象都储存在堆内存中。 发生时间：程序空闲时间不定时回收。\n（1）对象的生命周期 创建阶段(Created) 在创建阶段系统通过下面的几个步骤来完成对象的创建过程： （1）为对象分配存储空间 （2）开始构造对象 （3）从超类到子类对static成员进行初始化 （4）超累成员变量按顺序初始化，递归调用超累的构造方法 （5）子类成员变量按顺序初始化，子类构造方法调用 一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到应用状态 应用阶段(In Use) 对象至少被一个强引用持有。 不可见阶段(Invisible) 当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。 简单说就是程序的执行已经超出了该对象的作用域了。 不可达阶段(Unreachable) 对象处于不可达阶段是指该对象不再被任何强引用所持有。 与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。 收集阶段(Collected) 当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。 不要重载finazlie()方法！原因有两点： （1）会影响JVM的对象分配与回收速度 在分配该对象时，JVM需要在垃圾回收器上注册该对象，以便在回收时能够执行该重载方法；在该方法的执行时需要消耗CPU时间且在执行完该方法后才会重新执行回收操作，即至少需要垃圾回收器对该对象执行两次GC。 （2）可能造成该对象的再次“复活” 在finalize()方法中，如果有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又重新变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利用后续的代码管理。\n终结阶段(Finalized) 当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。 对象空间重分配阶段(De-allocated) 垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。 （2）判断对象是否是垃圾算法 （2.1）引用计数算法 堆中每个对象（不是引用）都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数设置为1。每当有一个地方引用它时，计数器值就加1（a = b， b被引用，则b引用的对象计数+1）。当引用失效时（一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时），计数器值就减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。\n（2.2）根搜索算法 首先了解一个概念：根集(Root Set) 所谓根集(Root Set)就是正在执行的Java程序可以访问的引用变量（注意：不是对象）的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。 这种算法的基本思路： （1）通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点。 （2）找到这些引用节点后，从这些节点开始向下继续寻找它们的引用节点。 （3）重复（2）。 （4）搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。 Java和C#中都是采用根搜索算法来判定对象是否存活的。\n首先，垃圾回收器将某些特殊的对象定义为GC根对象。所谓的GC根对象包括： （1）虚拟机栈中引用的对象（栈帧中的本地变量表）； （2）方法区中的常量引用的对象； （3）方法区中的类静态属性引用的对象； （4）本地方法栈中JNI（Native方法）的引用对象。 （5）活跃线程。\n接下来，垃圾回收器会对内存中的整个对象图进行遍历，它先从GC根对象开始，然后是根对象引用的其它对象，比如实例变量。回收器将访问到的所有对象都标记为存活。 存活对象在上图中被标记为蓝色。当标记阶段完成了之后，所有的存活对象都已经被标记完了。其它的那些（上图中灰色的那些）也就是GC根对象不可达的对象，也就是说你的应用不会再用到它们了。这些就是垃圾对象，回收器将会在接下来的阶段中清除它们。\n（3）GC算法 GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。\n（3.1）标记 -清除算法 “标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 内存中的对象构成一棵树，当有效的内存被耗尽的时候，程序就会停止，做两件事，第一：标记，标记从树根可达的对象（途中水红色），第二：清除（清楚不可达的对象）。标记清除的时候有停止程序运行，如果不停止，此时如果存在新产生的对象，这个对象是树根可达的，但是没有被标记（标记已经完成了），会清除掉。\n缺点：递归效率低性能低；释放空间不连续容易导致内存碎片；会停止整个程序运行；\n（3.2）复制算法 “复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 把内存分成两块区域：空闲区域和活动区域，第一还是标记（标记谁是可达的对象），标记之后把可达的对象复制到空闲区，将空闲区变成活动区，同时把以前活动区对象1，4清除掉，变成空闲区。\n速度快但耗费空间，假定活动区域全部是活动对象，这个时候进行交换的时候就相当于多占用了一倍空间，但是没啥用。\n（3.3）标记-压缩算法 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。\nJVM垃圾回收分代收集算法： 综合了上述算法优略 1， 分代GC在新生代的算法：采用了GC的复制算法，速度快，因为新生代一般是新对象，都是瞬态的用了可能很快被释放的对象。 2， 分代GC在年老代的算法 标记／整理算法，GC后会执行压缩，整理到一个连续的空间，这样就维护着下一次分配对象的指针，下一次对象分配就可以采用碰撞指针技术，将新对象分配在第一个空闲的区域。\n（4）垃圾回收器 Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。\n（4.1）串行垃圾回收器 串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序（单CPU、新生代空间较小及对暂停时间要求不是非常高的应用）。是client级别默认的GC方式。\n（4.2）并行垃圾回收器 并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，当执行垃圾回收的时候它也会冻结所有的应用程序线程。 适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。\n（4.3）并发标记扫描垃圾回收器 并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。 （1）当标记的引用对象在Tenured区域； （2）在进行垃圾回收的时候，堆内存的数据被并发的改变。 相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。\n5.GC分析 命令调优 JVM调优，调的是什么？ 每一次Full GC都会使JVM停止运行–\u0026gt;使Full GC不执行，使Minor GC尽可能少地执行\n（1）GC日志分析 摘录GC日志一部分\n（2）调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo\njps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。\n（3）调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。\njconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具\n（4）减少GC开销的措施 根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面: (1)不要显式调用System.gc() 此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。 (2)尽量减少临时对象的使用 临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。 (3)对象不用时最好显式置为Null 一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。 (4)尽量使用StringBuffer,而不用String来累加字符串 由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。 (5)能用基本类型如Int,Long,就不用Integer,Long对象 基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。 (6)尽量少用静态对象变量 静态变量属于全局变量,不会被GC回收,它们会一直占用内存。 (7)分散对象创建或删除的时间 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。\n6.执行引擎 分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐段执行。 解释器能快速的解释字节码，但执行却很慢。 解释器的缺点就是,当一个方法被调用多次，每次都需要重新解释。\n7.Java代码编译和执行整个过程 开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被类加载器装入内存，一旦字节码进入虚拟机，它就会被解释器（执行引擎）解释执行。 步骤1：Java代码编译是由Java源码编译器来完成，也就是Java代码到JVM字节码（.class文件）的过程。\n步骤2：Java字节码的执行是由JVM执行引擎来完成\nJava代码编译和执行的整个过程包含了三个重要机制：\nJava源码编译机制 类加载机制 类执行机制\n1、Java源码编译机制 Java源码编译由以下三个过程组成：\n分析和输入到符号表 注解处理 语义分析和生成class文件\n最后生成的class文件由以下部分组成： ①结构信息：包括class文件格式版本号及各部分的数量与大小的信息 ②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池 ③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息 例：\n//Math.java class Math{ public static final Integer CONSTANT_1 = 666; public static Object obj = new Object(); public int math(){ int a = 1; int b = 2; int c = (a+b)*10; return c;\t} public static void main(String[] args){ Math math = new Math(); Math math2 = new Math(); System.out.println(math.math()); } } 使用javac Math.java编译生成Math.class文件，再调用javap Math.class \u0026gt; Math.txt进行反编译生成可读的字节码文件 Math.txt\nCompiled from \u0026#34;Math.java\u0026#34; class Math{ Math(); Code: 0:aload_0 1:invokespecial #1\t//Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4:return public int math(); Code: //int a = 1; 0:iconst_1\t//将Int类型常量1压入操作数栈（操作数栈：操作数栈用于对操作数进行中间的承接） 1:istore_1\t//将int类型值存入局部变量1 （将操作数1出栈并放入局部变量栈a） //int b =2 2:iconst_2 3:istore_2 4:iload_1\t//从局部变量1中装载int类型值（获得a的值1）将1压入操作数栈 5:iload_2 //将2压入操作数栈 6:iadd\t//执行加法：操作数栈从栈中弹出2个操作数（1，2），执行加法操作数后得到结果3，重新压入栈 7:bipush\t10//将整数10压入栈 9:imul\t//执行乘法运算 10:istore_3//将int类型存入局部变量栈 11:iload_3//加载局部变量3并返回 12:ireturn public static void main(java.lang.String[]); Code: 0:new #2\t//class Math 3:dup 4:invokespecial #3\t//Method\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 7:astore_1 8:getstatic #4\t//Field java/lang/System.out:L java/io/PrintStream; 11:aload_1 12:invokevirtual #5\t//Method math:()I 15:invokevirtual #6\t//Method java/io/PrintStream.println:(I)V 18:return } 2、类加载机制 JVM类加载通过ClassLoader及其子类完成的，类的层次关系和加载顺序可以由下图描述：\n①Bootstrap ClassLoader 负责加载JAVAHOME 中 jre/lib/rt.jar里所有的class ， 由C++实现 ， 不是ClassLoader子类 ② ExtensionClassLoader负责加载java平台中 扩展功能的一些jar包，包括JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类 ②Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括JAVAHOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类②ExtensionClassLoader负责加载java平台中扩展功能的一些jar包，包括JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包 ③App ClassLoader 负责记载classpath中指定的jar包及目录中class ④Custom ClassLoader 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader\n加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。\n3、类执行机制 JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。\nJVM执行class字节码，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。\n例： 调用java Math.class，即采用执行引擎去执行Java文件。开启一个进程，其中主线程以main方法为入口执行执行Math类文件。线程在运行时，JVM为每一个线程分配一个独立的java栈，java栈里存储着栈帧，每个栈帧存储着每个方法运行时的局部变量、数据。本例Math.java存储着两个栈帧，一个为指向main方法的栈帧，一个为指向math函数的栈帧。\n8.Java虚拟机和Dalvik虚拟机区别 java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。 Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。 java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多.\n9.面试题 1.什么是class文件？ java编译出来的字节码文件，我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。\n2.Java代码执行流程？ 源文件-\u0026gt;.class字节码文件-\u0026gt;机器码（虚拟机解析字节码文件）\n3.Java内存结构 \u0026amp; 内存模型。 内存结构：PC、java栈（创建线程的时候，存放栈帧）、堆内存、常量池（存放各种字符串常量等，jdk8之后运行时常量池放在方法区（元空间），字符串常量池放在堆中）、方法区（类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息）、本地方法栈（本地方法）\n内存模型：Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。\nJMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\n线程1和线程2要想进行数据的交换一般要经历下面的步骤：\n1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。\n2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。\nJava内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的\n4.GC回收机制。 前面6种用于分代模型，后面3种用于分区模型，Epsilon用于debug，没用，跟踪垃圾回收过程。\njdk1.8分代模型居多，可以用G1，默认PS+PO\n从计算机组成的角度来讲，所有的程序都是要驻留在内存中运行的。而内存是一个限制因素(大小)。除此之外，托管堆也有大小限制。因为地址空间和存储的限制因素，托管堆要通过垃圾回收机制，来维持它的正常运作，保证对象的分配，尽可能不造成“内存溢出”。\nGC如其名，就是垃圾收集，当然这里仅就内存而言。Garbage Collector（垃圾收集器）以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，垃圾判断方法：引用计数法和根可达算法。需要被回收（回收的是该对象占用的内存空间）。这就是GC工作的原理。为了实现这个原理，GC有多种算法。比较常见的算法有，Mark Sweep（标记清理法），Copy Collection（复制收集法）,Mark Compress（标记压缩法）等等。目前主流的虚拟系统.NET CLR，Java VM和Rotor都是采用的Mark Sweep算法。\nJVM堆：分为**新生代、老年代（新域中的对象，经过了一定次数的GC循环后，被移入旧域 ）、元空间（永久代，存储类和方法对象，从配置的角度看，这个域是独立的，不包括在JVM堆内。默认为4M。）**其中新生代分为伊甸园、from幸存者区、to幸存者区（8：1：1）\n垃圾回收的基本原理（算法思路都是一致的：把所有对象组成一个集合，或可以理解为树状结构，从树根开始找，只要可以找到的都是活动对象，如果找不到，这个对象就被回收了）\n垃圾回收分为两个阶段：\n标记 \u0026ndash;\u0026gt; 压缩标记的过程，其实就是判断对象是否可达的过程。当所有的根都检查完毕后，堆中将包含可达(已标记)与不可达(未标记)对象。标记完成后，进入压缩阶段。在这个阶段中，垃圾回收器线性的遍历堆，以寻找不可达对象的连续内存块。并把可达对象移动到这里以节约内存空间。\n垃圾收集算法\nMark-Sweep 标记清理算法\n阶段1: Mark-Sweep 标记清除阶段，先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；\n阶段2: Compact 压缩阶段，对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列（节省内存资源）。\nHeap内存经过回收、压缩之后，可以继续采用前面的heap内存分配方法， 即仅用一个指针记录heap分配的起始地址就可以。主要处理步骤：将线程挂起→确定roots→创建reachable objects graph→对象回收→heap压缩→指针修复。可以这样理解roots：heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的 graph，roots是CLR在heap之外可以找到的各种入口点。\nGC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalization queue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register）\n指针修复是因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPU register中的指针以及heap中其他对象的引用指针。\n复制算法\n新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和Survivor区的比例为8:1，意思是每次新生代中可用内存空间为整个新生代容量的90%。当然，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。\n标记整理算法\n与标记清理算法过程一样，只是不直接清理可回收对象，而是将所有存活对象移动到一端，之后清理边界之外的对象内存\n分代收集算法\n现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法没什么特别的，无非是上面内容的结合罢了，根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。\nCMS:并发标记清除\n5.Java虚拟机是如何加载一个类的？ Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。\n加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。\n链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。\n初始化，则是为标记为常量值的字段赋值**，以及执行 \u0026lt; clinit \u0026gt; 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。** 6.给我谈谈类加载器。 每个编写的\u0026quot;.java\u0026quot;拓展名类文件都存储着需要执行的程序逻辑，这些\u0026quot;.java\u0026quot;文件经过Java编译器编译成拓展名为\u0026quot;.class\u0026quot;的文件，\u0026quot;.class\u0026quot;文件中保存着Java代码经转换后的虚拟机指令，当需要使用某个类时，虚拟机将会加载它的\u0026quot;.class\u0026quot;文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程称为类加载\n加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象\n验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。\n准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。\n解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。\n初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。\n在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）\nloadClass(String)\n该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。\nfindClass(String) 在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的\ndefineClass(byte[] b, int off, int len) defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象\nresolveClass(Class c) 使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。\n上述4个方法是ClassLoader类中的比较重要的方法，也是我们可能会经常用到的方法。\n类加载器间的关系 我们进一步了解类加载器间的关系(并非指继承关系)，主要可以分为以下4点\n启动类加载器，由C++实现，没有父类。 拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null 系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader 自定义类加载器，父类加载器肯定为AppClassLoader。 7.谈谈static编译运行时的流程，在虚拟机中如何保存的？ 当类第一次被调用时加载（静态方法，静态属性的加载就是类加载）。保存在方法区中\n1、类中的静态属性会被加入到类对象（也可以叫做类的模板，是类的描述） 的构造器中，静态方法也会被加入到类对象中。\n2、当第一次使用类时，JVM会通过类加载器，加载类对象，从而初始化静态属性，并装入类的方法，包括静态方法和实例方法（方法不会被调用，只是加载，从这个意义上来说，静态方法和实例方法是类似的）。\n3、当创建类的实例对象时，JVM会调用类的构造器，从而初始化类的属性。\n8.说说Java种的4种引用以及用法？ 强、软、弱、虚\n一般的写法就是强引用，只要有被强引用的对象，不会被GC回收\n软引用在内存充足的时候不会被GC回收，内存不足才会回收，可以用作缓存\n弱引用在GC必定会回收\n虚引用可以用来管理堆外内存，引用队列里面有对象的虚引用才可以回收该对象\n9.如何判断一个对象是死亡的？ 有以下两种算法判断对象实例是否死亡： 1、引用计数算法：给每个对象添加一个引用计数器，当有对象引用时加1，当引用失效时减1，任何引用计数器为0的对象实例就是不可能再被使用的——对象实例死亡。但它无法解决对象相互引用的情况。 2、可达性分析算法：通过一系列被称为**“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则说明此对象不能再被使用——对象实例已死亡**。可作为GC Roots的对象包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区常量引用的对象，本地方法栈中本地方法引用的对象。\n10.代码中直接调用System.gc()会发生什么？ System.gc(); //告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的，justRanFinalization=true的时候才会执行 System.runFinalization(); //调用runFinalization()的时候justRanFinalization变为true，强制调用已经失去引用的对象的finalize方法，回收掉失去引用的对象以及回收掉所有内存不足情况下的软引用以及被弱引用的对象\n11.一个强引用直接被null赋值，那么这个对象会被立刻回收吗？ 不一定会，会在GC的时候才被回收，并不是说一定立刻去释放。\n12.String a = “a”+“b”+“c”;在内存中创建了几个对象？ 1个String对象 \u0026ldquo;a\u0026rdquo;+\u0026ldquo;b\u0026rdquo;+\u0026ldquo;c\u0026quot;在编译期已经常量折叠为\u0026quot;abc\u0026rdquo;\n变量a获得是\u0026quot;abc\u0026quot;。\n13.谈谈你对字符集的理解。 字符集可以理解成一个对照表，某种编码规则的字符集规定：机器内某个长度一定二进制数表示代表一个对应的字符\nASCII 0-127\nAt the first start, computer is invented. The data is stored in computer by byte. The character is represented by one byte from 0 - 127. So the ASCII sums up 128 characters.\nISO8859 0-255\nIt is similar with ASCII.\n属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。比如，字母*\u0026lsquo;a\u0026rsquo;的编码为0x61=97*。\n*GB2312/GBK*\n这就是汉字的国标码，专门用来表示汉字，变长的编码，英文字母和ASCII一致（兼容ASCII编码，用一个字节（0-127）表示）, 一个汉字用两个字节表示，事实上，第一个字节是用扩展的ASCII（128-255）表示，而第二个字节是任何字节（0-255）。\n*Unicode*\nFor all the character used in different counties, a character is represented by 2 bytes, for example, “*中国”* *is encoded \u0026ldquo;4e2d 6587\u0026rdquo;, it is not compatible with* ASCII and ISO8859. By default, windows can not show it, but if the sign FF EE exists, it can be shown as usual. But it is suitable for the intern processing in computer. The windows can not show it by default if the sign FF EE is not specified, and windows only show the UTF8(ASCII) and GB2312(ASCII).\n这是最统一的编码，可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容iso8859-1编码的，也不兼容任何编码。不过，相对于iso8859-1编码来说，unicode编码只是在前面增加了一个0字节，比如字母*\u0026lsquo;a\u0026rsquo;为\u0026ldquo;00 61\u0026rdquo;*。\n*UTF-8*\n*UTF is variant character set, for the English, it is compatible with ASCII, so it stands for the English with one byte. Then for the Chinese, it use the 3 bytes to show it. For example,* “中国” is encoded as \u0026ldquo;e4b8ad e69687\u0026rdquo; as UTF-8。\n考虑到unicode编码不兼容iso8859-1编码，而且容易占用更多的空间：因为对于英文字母，unicode也需要两个字节来表示。所以unicode不便于传输和存储。因此而产生了utf编码，utf编码兼容iso8859-1编码，同时也可以用来表示所有语言的字符，不过，utf编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节。\n14.常见的编码格式有哪些？ ASCII 码\n学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0~31 是控制字符如换行回车删除等；32~126 是打印字符，可以通过键盘输入并且能够显示出来。　ISO-8859-1（扩展ASCII编码）\n128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。　GB2312\n它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。　GBK（扩展GB2312）\n全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。　GB18030（兼容GB2312）\n全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。　Unicode编码集\nISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。 UTF-16 UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 UTF-8 UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。 UTF-8 有以下编码规则： 如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。 如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。 如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 15.utf-8中的中文占几个字节？int型占几个字节？ 3字节、4字节\n16.谈谈你对逻辑地址和物理地址的理解？ 逻辑地址：虚拟地址\n物理地址：在（内存）磁盘的地址\n17.你知道对象什么时候会回调finalize方法吗？ 被GC回收的时候会回调finalize方法，GC强制调用runFinalization()的时候\n18.什么是Java内存模型 \u0026amp; Java7、8、9内存模型的区别. 内存模型：Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。\nJMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\n​\n线程1和线程2要想进行数据的交换一般要经历下面的步骤：\n1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。\n2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。\nJava内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的.\n所以对于方法区，Java8之后的变化：\n移除了永久代（PermGen），替换为元空间（Metaspace）； 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）； 永久代中的 interned Strings 和 class static variables 转移到了 Java heap； 永久代参数 （PermSize MaxPermSize） -\u0026gt; 元空间参数（MetaspaceSize MaxMetaspaceSize） JDK1.8对JVM架构的改造将类元数据放到本地内存中，另外，将常量池和静态变量放到Java堆里。HotSpot VM将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来-XX:MaxPermSize的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成大量类造成经常Full GC问题，如运行时使用反射、代理等。所以升级以后Java堆空间可能会增加。\n元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制\n","date":"2021-06-11T00:00:00Z","permalink":"https://haolovelin.com/post/java14jvm%E7%9B%B8%E5%85%B3/","title":"Java（14）JVM相关"},{"content":"十三、设计模式 1.说说设计模式的六大原则。 单一职责原则告诉我们实现类要职责单一\n里氏替换原则告诉我们不要破坏继承体系，不轻易重写方法，父类能用的地方，子类也能用\n依赖倒置原则告诉我们要面向接口编程\n接口隔离原则告诉我们在设计接口的时候要精简单一\n迪米特原则告诉我们要降低耦合\n开闭原则是总纲，告诉我们要对扩展开放，对修改关闭\n2.请讲讲你会使用的一些设计模式？ 单例模式，适配器模式，命令模式，建造者模式，抽象工厂模式，观察者模式，享元模式。\n创建型设计模式：这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复⽤性\n结构型模式：这类模式介绍如何将对象和类组装成较⼤的结构， 并同时保持结构的灵活和⾼效。\n行为模式：这类模式负责对象间的⾼效沟通和职责委派。\n3.请说说单例模式 \u0026amp; 你项目中常用的单例模式。 单例模式的目的是保证系统中只有类的一个实例对象，并且提供一个全局的入口点来获取并使用这个实例对象。\n使用单例模式可以防止用户“胡乱”创建对象，耗费内存。而且有些对象从逻辑上来讲一个系统中只应该存在一个，比如说Runtime类，使用单例模式也能很好的保证这一点。binder的ProcessState是在系统中唯一的，它是以单例模式存在的。他的使命就是打开Binder设备，分配Binder所需要的内存。\nAndroid的ActivityManagerNative中调用了getDefault()方法，源码如下：\nprivate static final Singleton\u0026lt;IActivityManager\u0026gt; gDefault = new Singleton\u0026lt;IActivityManager\u0026gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(\u0026#34;activity\u0026#34;); if (false) { Log.v(\u0026#34;ActivityManager\u0026#34;, \u0026#34;default service binder = \u0026#34; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(\u0026#34;ActivityManager\u0026#34;, \u0026#34;default service = \u0026#34; + am); } return am; } }; 首先这是一个单例模式，最终返回了一个叫am的对象。\n其中，IBinder b = ServiceManager.getService(\u0026quot;activity\u0026quot;)通过ServiceManager获取了一个系统服务的引用。\nJDK中的单例模式 Runtime类封装了Java运行时的环境。每一个java程序实际上都是启动了一个JVM进程，那么每个JVM进程都是对应这一个Runtime实例，此实例是由JVM为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。\n由于Java是单进程的，所以，在一个JVM中，Runtime的实例应该只有一个。所以应该使用单例来实现。\nCopypublic class Runtime { private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() { return currentRuntime; } private Runtime() {} } 以上代码为JDK中Runtime类的部分实现，可以看到，这其实是饿汉式单例模式。在该类第一次被classloader加载的时候，这个实例就被创建出来了。\n4.懒汉单例模式为什么要加volaitle？ 基本上，把synchronized移动到代码内部是没有什么意义的，每次调用getInstance()还是要进行同步。同步本身没有问题，但是我们只希望在第一次创建instance实例的时候进行同步，因此有了下面的写法——双重锁定检查（DCL,Double Check Lock）。\npublic class Singleton { private static Singleton instance = null; public static Singleton getInstance() { if(null == instance) { // 线程二检测到instance不为空 synchronized (Singleton.class) { if(null == instance) { instance = new Singleton(); // 线程一被指令重排，先执行了赋值，但还没执行完构造函数（即未完成初始化） } } } return instance; // 后面线程二执行时将引发：对象尚未初始化错误 } } 如上代码段中的注释：假设线程一执行到instance = new Singleton()这句，这里看起来是一句话，但实际上其被编译后在JVM执行的对应会变代码就发现，这句话被编译成8条汇编指令，大致做了三件事情：\n1）给instance实例分配内存；\n2）初始化instance的构造器；\n3）将instance对象指向分配的内存空间（注意到这步时instance就非null了）\n如果指令按照顺序执行倒也无妨，但JVM为了优化指令，提高程序运行效率，允许指令重排序。如此，在程序真正运行时以上指令执行顺序可能是这样的：\na）给instance实例分配内存；\nb）将instance对象指向分配的内存空间；\nc）初始化instance的构造器；\n这时候，当线程一执行b）完毕，在执行c）之前，被切换到线程二上，这时候instance判断为非空，此时线程二直接来到return instance语句，拿走instance然后使用，接着就顺理成章地报错（对象尚未初始化）。\n具体来说就是synchronized虽然保证了线程的原子性（即synchronized块中的语句要么全部执行，要么一条也不执行），但单条语句编译后形成的指令并不是一个原子操作（即可能该条语句的部分指令未得到执行，就被切换到另一个线程了）。\n根据以上分析可知，解决这个问题的方法是：禁止指令重排序优化，即使用volatile变量。\npublic class Singleton { private volatile static Singleton instance = null; public static Singleton getInstance() { if(null == instance) { synchronized (Singleton.class) { if(null == instance) { instance = new Singleton(); } } } return instance; } } 将变量instance使用volatile修饰即可实现单例模式的线程安全。\n5.能否给我说说Android中至少3个用到设计模式的例子？ 控件的监听、BroadcastReceiver、一些著名的第三方事件总线库,比如RxJava、RxAndroid、EventBus、otto都是：观察者模式\ndialog：建造者模式\nGridView、ListView与Adapter：适配器模式\nHandler：命令模式\nInputMethodManager.getInstance：单例模式\nMessage.obtain：享元模式\nBaseActivity：抽象工厂模式\nbinder：单例、代理\n","date":"2021-06-10T00:00:00Z","permalink":"https://haolovelin.com/post/java13%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"Java（13）设计模式"},{"content":"十二、Socket编程 1.什么是Socket编程？ 所谓socket通常也称作\u0026quot;套接字\u0026quot;，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过\u0026quot;套接字\u0026quot;向网络发出请求或者应答网络请求。\n我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢？在应用层和传输层之间，则是使用套接字来进行分离。\n套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据；而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次的工作。\nSocket实际是传输层供给应用层的编程接口。传输层则在网络层的基础上提供进程到进程问的逻辑通道，而应用层的进程则利用传输层向另一台主机的某一进程通信。Socket就是应用层与传输层之间的桥梁\n2.什么是TCP,什么是UDP,二者之间区别如何？ TCP是一种可靠的面向连接的传输协议，UDP是不可靠的无连接传输协议。TCP头部20字节，UDP头部8字节。区别：\n1.TCP\nTCP面向连接（如打电话要先拨号码建立连接）；\nTCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差距，不丢失，不重复，且按序到达；\nTCP通过校验和重传控制，序号标识，滑动窗口，确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉 的分包进行顺序控制。\n每一条TCP连接只能是点到点的；\nTCP对系统资源要求较多\n需要三次握手和四次挥手\n2.UDP\nUDP是无连接的，及发送数据之前不需要建立连接\nUDP尽最大努力交付，即不保证可靠交付\nUDP具有较好的实时性，工作效率比TCP高，使用与对高速传输和实时性有较高的通信或广播通信\nUDP支持一对一，一对多，多对一和多对多的交互通信\nUDP对系统资源要求较少\n","date":"2021-06-09T00:00:00Z","permalink":"https://haolovelin.com/post/java12socket%E7%BC%96%E7%A8%8B/","title":"Java（12）Socket编程"},{"content":"十一、注解 1.什么是注解 \u0026amp; 它和注释的区别？ 注解 ：参与代码编译，以@开头的。它是给应用程序看的，单独使用注解毫无意义，一定要跟工具一起使用,这个所谓的工具实际就是能读懂注解的应用程序 。 注释 ：对代码没有影响。对代码起到解释、说明的作用；\n2.注解的工作机制是什么？ 做Java开发我们常常用到注解，如@Service、@Overrided、@Autowired、@Param等，但这些注解的工作原理是怎么样的恐怕不是每个人都说的清楚，在没了解注解的工作原理之前倒是可以大致推断一下：当注解标注到某个类或者方法或者某个成员变量或者某个输入参数上的时候，一定有一个对应的机制来对注解标注的类、方法、成员变量和参数进行某些处理。比如Bean扫描、编译检查、注入值、约束是否为空等等。\n1、注解定义： 注解就是用来描述包、类、成员变量、方法或者参数的元数据，注解本身也是一个类（Java里一切都是对象）。配置过Spring的同学肯定很清楚，Spring中的Bean需要在xml里面声明，比如说一个Bean他的构造方法是啥，他依赖哪些其他bean，初始化变量值是多少，这些都是描述性的数据告知Spring按照这个描述去创建这个Bean。我们随便找个例子：\n\u0026lt;bean id=\u0026#34;Kenny\u0026#34; class=\u0026#34;com.springinaction.springidol.Instrumentalist\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;song\u0026#34; value=\u0026#34;Jingle Bells\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;37\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;instrument\u0026#34; ref=\u0026#34;saxphone\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;instrument\u0026#34; ref=\u0026#34;piano\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;instrument\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.springinaction.springidol.piano\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 这些对类和变量等的描述实际上就是元数据，而这些都可以用注解取代，因为注解也是元数据。比如@Component注解标注在一个类上就可以说明该类是一个bean，@Autowire标注在成员变量上就直接给该成员变量赋值。看起来注解标注在代码上耦合性更强了，但实际上本着约定优于配置的原则，代码更加清晰，也容易维护。\n2、注解分类 注解大体上可以分成两类，一类是系统带的如@Override，这类注解对其标注的目标的处理在JVM层面进行；另一类是我们自定义的注解，自己定义的注解自己要进行解析。还有一类是描述注解的注解，共有4个，分别是： @Documented 注解信息是否添加到javadoc中 @Retention 注解的生命周期\nRetentionPolicy.SOURCE（编译结束后失效如@Override）、RetentionPolicy.CLASS（JVM加载类的时候失效，默认。不能通过反射获取）、RetentionPolicy.RUNTIME（始终不失效，一般用于自定义注解，可通过反射获取）\n@Target 注解用在什么地方，分别有几个地方：\nElementType.TYPE:类上 ElementType.FIELD:成员变量 ElementType.METHOD 方法 ElementType.PARAMETER 参数 ElementType.CONSTRUCTOR 构造方法 ElementType.LOCAL_VARIABLE 本地变量 ElementType.ANNOTATION_TYPE 另一个注释 ElementType.PACKAGE 包上\n@Inherited 注解作用被子类继承\n3、自定义注解 3.1 定义一个注解需要几步？ 首先、@Target肯定要有； 其次、生命周期尽量RUNTIME； 然后、使用@interface声明； 再次、内部只支持基本类型、String类型和枚举类型； 最后、所有属性都必须写成field（），并可提供默认值default；\n3.2 如何使用注解？ 首先、在对应位置（@Target）标注； 然后、给注解中的属性赋值；\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Company { public enum Status {RUNNING, CLOSED} String name() default \u0026#34;NETEASE\u0026#34;； //有默认值 Status status() default Status.RIUNNING; String location（）；//没有默认值 } public class Demo{ @Company（name=\u0026#34;阿里巴巴\u0026#34;，status=Company.Status.RUNNING,location=\u0026#34;北京\u0026#34;） public void companyInfo（）{} } @interface Country{ String value（）； } @Country（\u0026#34;中国\u0026#34;） public void method(){}; 上面是第一个自定义注解的例子，该注解需要标注在方法上，在运行期间一直存在。如果注解中只有一个属性可以命名为value（）这种的好处是注解标注的时候不用写value=xxx而是直接写xxx即可。\n3.3 注解标注完如何处理？ 首先、定义一个注解处理类和注解处理方法； 然后、通过反射获取注解标注的类或者方法或者变量等等并对其做相应处理；\nimport java.lang.reflect.Field; public class AnnotationProccessor { public static void process(Demo demo){ Class demoClazz = Demo.class; for(Method method : demoClazz.getMethods()) { Company companyAnnotation = (Company)method.getAnnotation(Company.class); if(companyAnnotation !=null) { System.out.println(\u0026#34; Method Name : \u0026#34;+ method.getName()); System.out.println(\u0026#34; name : \u0026#34;+ companyAnnotation.name()); System.out.println(\u0026#34; Status : \u0026#34;+ companyAnnotation.status()); } } } 上面的类只对特定的类进行了处理，在Spring中一个如@Service这种注解，Spring在启动IOC容器的时候会对每个类进行扫描，把所有标注@Component及其子注解如@Service的类进行Bean处理。\n总结： 以上就是注解的相关原理和机制，我们前面的猜测是正确的，其处理机制主要是JVM内部处理和使用反射的自定义处理。\n3.如何解析注解？ 其处理机制主要是JVM内部处理和使用反射的自定义处理。\n首先、定义一个注解处理类和注解处理方法； 然后、通过反射获取注解标注的类或者方法或者变量等等并对其做相应处理；\nimport java.lang.reflect.Field; public class AnnotationProccessor { public static void process(Demo demo){ Class demoClazz = Demo.class; for(Method method : demoClazz.getMethods()) { Company companyAnnotation = (Company)method.getAnnotation(Company.class); if(companyAnnotation !=null) { System.out.println(\u0026#34; Method Name : \u0026#34;+ method.getName()); System.out.println(\u0026#34; name : \u0026#34;+ companyAnnotation.name()); System.out.println(\u0026#34; Status : \u0026#34;+ companyAnnotation.status()); } } } 上面的类只对特定的类进行了处理。\n4.知识点总结 1、什么是注解 注解与注释： 注解：说明程序的。给计算机看得。 注释：用文字描述程序，给程序员看的。方便程序员理解。 注解(Annotation)是插入代码中的元数据，一种代码级别的说明。它是在JDK5.0及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 （1）JDK 1.5 之后的新特性 （2）用来说明程序 （3）使用注解：@注解名称 Annotation的作用大致可分为三类：\n编写文档：通过代码里标识的注解生成文档（生成java doc文档(api)）\n代码分析：通过代码里标识的注解对代码进行分析（使用反射）\n编译检查：通过代码里标识的注解让编译器能实现基本的编译检查\nJava提供了一种源程序中的元素关联任何信息和任何元数据的途径和方法。 它可以在编译期使用预编译工具进行处理, 也可以在运行期使用 Java 反射机制进行处理，用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。 本质上，Annotion是一种特殊的接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。（元数据metadata:关于数据的数据）\n注解很常用 注解一般给编译器、解析程序使用 注解不是程序的一部分，可理解为一个标签 2、常见注解 JDK注解\n@Override重写、@Deprecated废弃、@SuppressWarnnings压制警告\nJava第三方注解 Spring:@Autowired、@Service、@Repository Mybatis:@InsertProvider、@UpdateProvider、@Options\n自定义注解\npublic @interface 注解名称{ ... 属性列表 } 注解本质上就是一个接口，该接口默认继承java.lang.annotation.Annotation接口。\npublic interface MyAnno extends java.lang.annotation.Annotation{} 元注解 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。\n@Target 作用： 描述注解能够作用的位置 取值(ElementType)： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention 作用： 描述该注解的生命周期，表示在什么编译级别上保存该注解的信息。Annotation被保留的时间有长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。 取值（RetentionPoicy）： 1.SOURCE:当前被描述的注解只在源文件中有效，不会保留到class字节码文件中，也不会被JVM读取到。 2.CLASS:当前被描述的注解，会保留到class字节码文件中，不会被JVM读取到。 3.RUNTIME:当前被描述的注解，会保留到class字节码文件中，并被JVM读取到。 @Documented @Documented 用来描述注解是否被抽取到api文档中。在生成javadoc文档的时候将该Annotation也写入到文档中。 @Inherited @Inherited 元注解是一个标记注解，@Inherited用来描述注解是否被子类继承。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n@Target({ElementType.TYPE,ElementType.METHOD,ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited public @interface MyAnno{} 反射框架、测试框架、数据库框架都可以使用注解实现\n","date":"2021-06-08T00:00:00Z","permalink":"https://haolovelin.com/post/java11%E6%B3%A8%E8%A7%A3/","title":"Java（11）注解"},{"content":"十、反射 1.什么是反射？ JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\nClass类\n这个类用于操纵（反向解析）一个类的属性，方法，构造器等。\nPerson: name,age,address(Class只要知道你这个Person类，那么它便可知道你所有的属性，不止属性，甚至方法上的注解等等，都会知道。)\n范例：获取一个Class对象\nimport java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.Arrays; public class Test01 { public static void main(String[] args) throws ClassNotFoundException { String a = \u0026#34;java.lang.String\u0026#34;; // String a = \u0026#34;java.lang.HashMap\u0026#34;; // 根据一类的全名字符串来获得一个类的类对象 Class\u0026lt;?\u0026gt; clazz = Class.forName(a); // 获得传递过来的类的所有方法 Method[] methods = clazz.getDeclaredMethods(); // String s = Arrays.toString(methods); for (Method m: methods) { System.out.println(m); } System.out.println(\u0026#34;------------------------------------------\u0026#34;); // 获得类的所有属性 Field[] declaredFields = clazz.getDeclaredFields(); for(Field d : declaredFields) { System.out.println(d); } System.out.println(\u0026#34;-------------------------------------\u0026#34;); // 获得类的所有构造器 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getDeclaredConstructors(); for (Constructor c : constructors) { System.out.println(c); } } } 2.如何获取一个类的成员变量 \u0026amp; 成员方法 \u0026amp; 注解信息 \u0026amp; …。 //获取类 Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;java.lang.String\u0026#34;); // 获得类的所有属性变量 Field[] declaredFields = clazz.getDeclaredFields(); // 获得传递过来的类的所有方法 Method[] methods = clazz.getDeclaredMethods(); // 获得类的所有构造器 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getDeclaredConstructors(); 3.通常在项目当中用到反射多吗？都是用来干嘛？ 用于某些模块集成场合。\n当不能在开发时即得到其目标类完整接口定义，只能根据命名规则去进行集成时。\n不改版原有的类定义的时候，绕过private关键字获取成员变量和成员方法。\nAndroid热修复技术\n4.如何反射一个匿名内部类(考察对匿名内部类的认识) Field field = clazz.getDeclaredField(\u0026#34;runnable\u0026#34;); field.setAccessible(true); Runnable r = (Runnable) field.get(container); r.run(); /* private Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\u0026#34;cxx 匿名内部类run方法\u0026#34;); } }; */ 5.知识点总结 1、什么是反射？——框架设计的灵魂 框架：半成品软件。可以在框架的基础上进行软件开发，简化代码。 java代码在计算机中经历的阶段（三阶段）\n反射：就是把Java类中的各种成分映射成相应的Java类，然后对这些类进行操作。（如：类的成员属性-\u0026gt;Field、类的成员方法-\u0026gt;Method、类的构造方法-\u0026gt;Constructor等等） 反射的好处包括： （1）可以在程序运行过程中，操作这些对象。 （2）可以解耦，提高程序可扩展性。 Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。 我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。\n2、字节码Class对象 （1）Class类对象——描述.class字节码文件 将（.java类文件）经过编译后的.class字节码文件（位于硬盘上）通过类加载器（ClassLoader）加载进内存，通过java.lang.Class类对象对字节码文件进行描述。每一个类都是一个Class类的实例对象。 Class类对象是用来对.class文件进行描述。主要包括三个成员变量：\n类成员变量 Field[] fields 类构造方法 Constructor[] constructors 类成员方法 Method[] methods （2）获取Class对象的方式\nClass.forName(“全类名”)：将字节码文件加载进内存，返回class对象 在Source源代码阶段，此时java类仍位于硬盘上。多用于配置文件，将类名定义在配置文件中。读取文件，并触发类构造器加载类。 Class.forName() 方法如果写错类的路径会报 ClassNotFoundException 的异常。 类名.class：通过类名的属性class获取 在Class类对象阶段，此时java类位于内存中，但没有实际对象。多用于参数的传递。 通过这种方式时，只会加载Dog类，并不会触发其类构造器的初始化。 对象.getClass()：getClass（）方法在Object类中定义 在运行阶段，此时已经获取类的实例对象，多用于对象的获取字节码的方式。 // 方法1：Class.forName(\u0026#34;全类名\u0026#34;) try { Class cls1 = Class.forName(\u0026#34;com.test.demo.Dog\u0026#34;); } catch (ClassNotFoundException e) {} // 方法2：类名.class Class cls2 = Dog.class; // 方法3：对象.getClass() Dog dog = new Dog(); Class cls3 = dog.getClass(); // 用 == 比较3个对象是否为同一个对象（指向同一物理地址） System.out.print(cls1 == cls2);\t//\ttrue System.out.print(cls1 == cls3);\t//\ttrue 结论：同一个字节码文件（*.class）在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的class对象都是同一个。\n3、反射机制 反射机制reflect可以在运行期间获取类的字段、方法、父类和接口等信息。\n（3.1）类成员变量的反射 获取类成员变量： Field[] getFields()：获取所有public 修饰的成员变量 Field getField(String name)：获取指定名称的public修饰的成员变量 Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符 Filed getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符 Filed：成员变量 get(Object object) ：获取值 void set(Object obj, Object value)：设置值 setAccessible(true) ：忽略访问权限修饰符的安全检查，用于暴力反射，修改私有成员变量的值\n（3.2）类成员方法的反射 获取类成员方法： Method[] getMethods()：获取所有public修饰的成员方法 Method getMethod(String name,类… parameterTypes)：获取指定的public修饰的成员方法，name 为方法名，parameterTypes为参数列表（重载） Method[] getDeclaredMethods()：获取所有成员方法 Method getDeclaredMethod(String name,类… parameterTypes)：获取指定的成员方法，name 为方法名，parameterTypes为参数列表（重载） Method invoke(obj … args)：执行方法 setAccessible(true) ：忽略访问权限修饰符的安全检查，用于暴力反射，修改私有成员方法的值\n（3.3）类构造方法的反射 获取类构造方法： Constructor[] getConstructors()：获取public修饰的构造方法 Constructor getConstructor(类… parameterTypes)：获取指定的public修饰的构造方法（构造方法的方法名 = 类名），parameterTypes为参数列表 Constructor[] getDeclaredConstructors()：获取所有构造方法 Constructor getDeclaredConstructor(类… parameterTypes)：获取指定的构造方法，name为方法名（构造方法的方法名 = 类名），parameterTypes为参数列表 Constructor：构造方法 T.newInstance(Object… init args)：创建对象 Class.newInstance()：如果使用空参数构造方法创建对象，操作可以简化为：Class对象的newInstance方法 setAccessible(true) ：忽略访问权限修饰符的安全检查，用于暴力反射，修改私有构造方法的值\n（3.4）类名的获取 String getName()\n4、反射案例 （4.1）Class类的动态加载 编译时刻加载的类是静态加载类，运行时刻加载的类是动态加载类。 写一个\u0026quot;框架\u0026quot;，在不能改变该类任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。 实现: 配置文件+反射 步骤: 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射奇数来加载类文件进内存 创建对象，执行方法\n（4.2）JDBC数据库连接 在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成\n通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包） 通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码 通过Connection 接口接收连接\n（4.3）Spring框架使用——反射 在 Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。 Spring通过XML配置模式装载Bean的过程：\n将程序内所有XML或Properties配置文件加载入内存中 Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关属性信息 使用反射机制，根据这个字符串获得某个类的Class实例 动态配置实例的属性 通过反射，Spring框架可以在不改变代码的前提下，直接修改配置文件。模拟Spring加载XML配置文件：\npublic class BeanFactory { private Map\u0026lt;String, Object\u0026gt; beanMap = new HashMap\u0026lt;String, Object\u0026gt;(); /** * bean工厂的初始化. * @param xml xml配置文件 */ public void init(String xml) { try { //读取指定的配置文件 SAXReader reader = new SAXReader(); ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); //从class目录下获取指定的xml文件 InputStream ins = classLoader.getResourceAsStream(xml); Document doc = reader.read(ins); Element root = doc.getRootElement(); Element foo; //遍历bean for (Iterator i = root.elementIterator(\u0026#34;bean\u0026#34;); i.hasNext();) { foo = (Element) i.next(); //获取bean的属性id和class Attribute id = foo.attribute(\u0026#34;id\u0026#34;); Attribute cls = foo.attribute(\u0026#34;class\u0026#34;); //利用Java反射机制，通过class的名称获取Class对象 Class bean = Class.forName(cls.getText()); //获取对应class的信息 java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(bean); //获取其属性描述 java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); //设置值的方法 Method mSet = null; //创建一个对象 Object obj = bean.newInstance(); //遍历该bean的property属性 for (Iterator ite = foo.elementIterator(\u0026#34;property\u0026#34;); ite.hasNext();) { Element foo2 = (Element) ite.next(); //获取该property的name属性 Attribute name = foo2.attribute(\u0026#34;name\u0026#34;); String value = null; //获取该property的子元素value的值 for(Iterator ite1 = foo2.elementIterator(\u0026#34;value\u0026#34;); ite1.hasNext();) { Element node = (Element) ite1.next(); value = node.getText(); break; } for (int k = 0; k \u0026lt; pd.length; k++) { if (pd[k].getName().equalsIgnoreCase(name.getText())) { mSet = pd[k].getWriteMethod(); //利用Java的反射极致调用对象的某个set方法，并将值设置进去 mSet.invoke(obj, value); } } } //将对象放入beanMap中，其中key为id值，value为对象 beanMap.put(id.getText(), obj); } } catch (Exception e) { System.out.println(e.toString()); } } //other codes } ","date":"2021-06-07T00:00:00Z","permalink":"https://haolovelin.com/post/java10%E5%8F%8D%E5%B0%84/","title":"Java（10）反射"},{"content":"九、泛型 1.什么是泛型？能解决什么问题？ 泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。在 Java SE 1.5 之前没有泛型的情况的下只能通过对类型 Object 的引用来实现参数的任意化，其带来的缺点是要做显式强制类型转换，而这种强制转换编译期是不做检查的，容易把问题留到运行时，所以 泛型的好处是在编译时检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率，避免在运行时出现 ClassCastException。\nJDK 1.5 引入了泛型来允许强类型在编译时进行类型检查；JDK 1.7 泛型实例化类型具备了自动推断能力，譬如 List list = new ArrayList(); 可以写成 List llist = new ArrayList\u0026lt;\u0026gt;(); 了，JDK 具备自动推断能力。\n我们在编写程序时，经常遇到两个模块的功能非常相似，只是一个是处理int数据，另一个是处理string数据，或者其他自定义的数据类型，但我们没有办法，只能分别写多个方法处理每个数据类型，因为方法的参数类型不同。有没有一种办法，在方法中传入通用的数据类型，这样不就可以合并代码了吗？泛型的出现就是专门解决这个问题的。\n2.说说Java中泛型的工作机制？ 在java中，官方强烈推荐我们使用泛型。就是因为他有很多优点。\n（1）类型安全：我们在使用泛型之后，可以指定输入的类型，比如只能输入String类型的值，输入其他的就会报错，这在代码编写时，为我们提供了极大的方便。\n（2）消除强制类型转换：也就是说我们不需要进行类型转化，直接存储、直接输出。\n（3）只在编译器有效：也就是说在运行时泛型是无效的。这避免了jvm花费时间在运行时做额外的操作。\n这种语法机制，只在程序编译阶段起作用，只是给编译器参考的。（运行阶段泛型没用） 使用了泛型好处是什么？ 第一：集合中存储的元素类型统一。 第二：从集合中取出的元素类型是泛型指定的类型，不需要进行大量的向下转型。 泛型的缺点是什么？ 导致集合中存储的元素缺乏多样性。 3.在泛型中extends和super关键字的区别是什么？ \u0026lt;? extends T\u0026gt;和\u0026lt;? super T\u0026gt;是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。\n为什么要用通配符和边界？ 使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。\nclass Fruit {} class Apple extends Fruit {} 然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。\nclass Plate\u0026lt;T\u0026gt;{ private T item; public Plate(T t){item=t;} public void set(T t){item=t;} public T get(){return item;} } 现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。\nPlate\u0026lt;Fruit\u0026gt; p=new Plate\u0026lt;Apple\u0026gt;(new Apple()); 但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。\nerror: incompatible types: Plate\u0026lt;Apple\u0026gt; cannot be converted to Plate\u0026lt;Fruit\u0026gt; 为了让泛型用起来更舒服，Sun的大脑袋们就想出了\u0026lt;? extends T\u0026gt;和\u0026lt;? super T\u0026gt;的办法，来让”水果盘子“和”苹果盘子“之间发生关系。\n什么是上界？ 下面代码就是“上界通配符（Upper Bounds Wildcards）”：\nPlate\u0026lt;？ extends Fruit\u0026gt; 翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。Plate\u0026lt;？ extends Fruit\u0026gt;和Plate\u0026lt;Apple\u0026gt;最大的区别就是：Plate\u0026lt;？ extends Fruit\u0026gt;是Plate\u0026lt;Fruit\u0026gt;以及Plate\u0026lt;Apple\u0026gt;的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。\nPlate\u0026lt;? extends Fruit\u0026gt; p=new Plate\u0026lt;Apple\u0026gt;(new Apple()); 如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。\n//Lev 1 class Food{} //Lev 2 class Fruit extends Food{} class Meat extends Food{} //Lev 3 class Apple extends Fruit{} class Banana extends Fruit{} class Pork extends Meat{} class Beef extends Meat{} //Lev 4 class RedApple extends Apple{} class GreenApple extends Apple{} 在这个体系中，上界通配符 Plate\u0026lt;？ extends Fruit\u0026gt; 覆盖下图中蓝色的区域。\n什么是下界？ 相对应的，“下界通配符（Lower Bounds Wildcards）”：\nPlate\u0026lt;？ super Fruit\u0026gt; 表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。Plate\u0026lt;？ super Fruit\u0026gt;是Plate\u0026lt;Fruit\u0026gt;的基类，但不是Plate\u0026lt;Apple\u0026gt;的基类。对应刚才那个例子，Plate\u0026lt;？ super Fruit\u0026gt;覆盖下图中红色的区域。\n上下界通配符的副作用 边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。\n还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。\nclass Plate\u0026lt;T\u0026gt;{ private T item; public Plate(T t){item=t;} public void set(T t){item=t;} public T get(){return item;} } 上界\u0026lt;? extends T\u0026gt;不能往里存，只能往外取 public \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; fill(T... t); 但通配符\u0026lt;?\u0026gt;没有这种约束，Plate\u0026lt;?\u0026gt;单纯的就表示：盘子里放了一个东西，是什么我不知道。\n所以题主问题里的错误就在这里，Plate\u0026lt;？ extends Fruit\u0026gt;里什么都放不进去。\n下界\u0026lt;? super T\u0026gt;不影响往里存，但往外取只能放在Object对象里 使用下界\u0026lt;? super Fruit\u0026gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。\nPlate\u0026lt;? super Fruit\u0026gt; p=new Plate\u0026lt;Fruit\u0026gt;(new Fruit()); //存入元素正常 p.set(new Fruit()); p.set(new Apple()); //读取出来的东西只能存放在Object类里。 Apple newFruit3=p.get(); //Error Fruit newFruit1=p.get(); //Error Object newFruit2=p.get(); 因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。\nPECS原则 最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：\n频繁往外读取内容的，适合用上界Extends。 经常往里插入的，适合用下界Super。 4.比较一下其它语言中的泛型和Java泛型的区别。 Java泛型为了向前兼容，采取运行期类型擦出泛型参数的方式来实现。这就意味着，你在使用泛型的时候，任何具体的类型都已经被擦除。因此，以上的ArrayList和ArrayList实际上都恢复到他们的原生类型List，是同一种类型。正确理解Java泛型的类型擦除，能帮我们理解Java泛型中的很多奇怪特性。\n按C#对泛型的理解，泛型实质就是类的模板。我们认为很容易知道类ArrayList和ArrayList应该是不同的类型。Java运行结果判断ArrayList和ArrayList是相同的类型。Java的泛型不是真正的泛型，只是编译器的泛型，不是运行时的泛型。\n5.在Java中List\u0026lt; A \u0026gt;和List\u0026lt; B \u0026gt;是一样的类型还是不一样的类型？为什么？ 一样的类型Java的类型。因为java的泛型不是真正的泛型，只是编译器的泛型，不是运行时的泛型，java的泛型通过类型擦除实现，在编译器阶段实现，会生成同样的字节码。\n6.你可以例举一些自己使用泛型的栗子吗？ class Plate\u0026lt;T\u0026gt;{ private T item; public Plate(T t){item=t;} public void set(T t){item=t;} public T get(){return item;} } ","date":"2021-06-06T00:00:00Z","permalink":"https://haolovelin.com/post/java9%E6%B3%9B%E5%9E%8B/","title":"Java（9）泛型"},{"content":"八、线程 1.ThreadLocal 使用方法很简单\nstatic final ThreadLocal\u0026lt;T\u0026gt; sThreadLocal = new ThreadLocal\u0026lt;T\u0026gt;(); sThreadLocal.set() sThreadLocal.get() Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，官方解释如下。\n/** * This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * {@code get} or {@code set} method) has its own, independently initialized * copy of the variable. {@code ThreadLocal} instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). */ 大致意思就是ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。\n做个不恰当的比喻，从表面上看ThreadLocal相当于维护了一个map，key就是当前的线程，value就是需要存储的对象。\n这里的这个比喻是不恰当的，实际上是ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。。\n作为一个存储数据的类，关键点就在get和set方法。\n//set 方法 public void set(T value) { //获取当前线程 Thread t = Thread.currentThread(); //实际存储的数据结构类型 ThreadLocalMap map = getMap(t); //如果存在map就直接set，没有则创建map并set if (map != null) map.set(this, value); else createMap(t, value); } //getMap方法 ThreadLocalMap getMap(Thread t) { //thred中维护了一个ThreadLocalMap return t.threadLocals; } //createMap void createMap(Thread t, T firstValue) { //实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals t.threadLocals = new ThreadLocalMap(this, firstValue); } 从上面代码可以看出每个线程持有一个ThreadLocalMap对象。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。\n2.Thread /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; Thread中关于ThreadLocalMap部分的相关声明，接下来看一下createMap方法中的实例化过程。\n3.ThreadLocalMap set方法 //Entry为ThreadLocalMap静态内部类，对ThreadLocal的若引用 //同时让ThreadLocal和储值形成key-value的关系 static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } //ThreadLocalMap构造方法 ThreadLocalMap(ThreadLocal\u0026lt;?\u0026gt; firstKey, Object firstValue) { //内部成员数组，INITIAL_CAPACITY值为16的常量 table = new Entry[INITIAL_CAPACITY]; //位运算，结果与取模相同，计算出需要存放的位置 //threadLocalHashCode比较有趣 int i = firstKey.threadLocalHashCode \u0026amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); } 通过上面的代码不难看出在实例化ThreadLocalMap时创建了一个长度为16的Entry数组。通过hashCode与length位运算确定出一个索引值i，这个i就是被存储在table数组中的位置。\n前面讲过每个线程Thread持有一个ThreadLocalMap类型的实例threadLocals，结合此处的构造方法可以理解成每个线程Thread都持有一个Entry型的数组table，而一切的读取过程都是通过操作这个数组table完成的。\n显然table是set和get的焦点，在看具体的set和get方法前，先看下面这段代码。\n//在某一线程声明了ABC三种类型的ThreadLocal ThreadLocal\u0026lt;A\u0026gt; sThreadLocalA = new ThreadLocal\u0026lt;A\u0026gt;(); ThreadLocal\u0026lt;B\u0026gt; sThreadLocalB = new ThreadLocal\u0026lt;B\u0026gt;(); ThreadLocal\u0026lt;C\u0026gt; sThreadLocalC = new ThreadLocal\u0026lt;C\u0026gt;(); 由前面我们知道对于一个Thread来说只有持有一个ThreadLocalMap，所以ABC对应同一个ThreadLocalMap对象。为了管理ABC，于是将他们存储在一个数组的不同位置，而这个数组就是上面提到的Entry型的数组table。\n那么问题来了，ABC在table中的位置是如何确定的？为了能正常够正常的访问对应的值，肯定存在一种方法计算出确定的索引值i，show me code。\n//ThreadLocalMap中set方法。 private void set(ThreadLocal\u0026lt;?\u0026gt; key, Object value) { // We don\u0026#39;t use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; //获取索引值，这个地方是比较特别的地方 int i = key.threadLocalHashCode \u0026amp; (len-1); //遍历tab如果已经存在则更新值 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u0026lt;?\u0026gt; k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } //如果上面没有遍历成功则创建新值 tab[i] = new Entry(key, value); int sz = ++size; //满足条件数组扩容x2 if (!cleanSomeSlots(i, sz) \u0026amp;\u0026amp; sz \u0026gt;= threshold) rehash(); } 在ThreadLocalMap中的set方法与构造方法能看到以下代码片段。\nint i = key.threadLocalHashCode \u0026amp; (len-1) int i = firstKey.threadLocalHashCode \u0026amp; (INITIAL_CAPACITY - 1) 简而言之就是将threadLocalHashCode进行一个位运算（取模）得到索引i，threadLocalHashCode代码如下。 //ThreadLocal中threadLocalHashCode相关代码. private final int threadLocalHashCode = nextHashCode(); /** * The next hash code to be given out. Updated atomically. Starts at * zero. */ private static AtomicInteger nextHashCode = new AtomicInteger(); /** * The difference between successively generated hash codes - turns * implicit sequential thread-local IDs into near-optimally spread * multiplicative hash values for power-of-two-sized tables. */ private static final int HASH_INCREMENT = 0x61c88647; /** * Returns the next hash code. */ private static int nextHashCode() { //自增 return nextHashCode.getAndAdd(HASH_INCREMENT); } 因为static的原因，在每次new ThreadLocal时因为threadLocalHashCode的初始化，会使threadLocalHashCode值自增一次，增量为0x61c88647。\n0x61c88647是斐波那契散列乘数,它的优点是通过它散列(hash)出来的结果分布会比较均匀，可以很大程度上避免hash冲突，已初始容量16为例，hash并与15位运算计算数组下标结果如下：\nhashCode 数组下标 0x61c88647 7 0xc3910c8e 14 0x255992d5 5 0x8722191c 12 0xe8ea9f63 3 0x4ab325aa 10 0xac7babf1 1 0xe443238 8 0x700cb87f 15 总结如下：\n对于某一ThreadLocal来讲，他的索引值i是确定的，在不同线程之间访问时访问的是不同的table数组的同一位置即都为table[i]，只不过这个不同线程之间的table是独立的。 对于同一线程的不同ThreadLocal来讲，这些ThreadLocal实例共享一个table数组，然后每个ThreadLocal实例在table中的索引i是不同的。 get()方法 //ThreadLocal中get方法 public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; } } return setInitialValue(); } //ThreadLocalMap中getEntry方法 private Entry getEntry(ThreadLocal\u0026lt;?\u0026gt; key) { int i = key.threadLocalHashCode \u0026amp; (table.length - 1); Entry e = table[i]; if (e != null \u0026amp;\u0026amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); } 理解了set方法，get方法也就清楚明了，无非是通过计算出索引直接从数组对应位置读取即可。\nThreadLocal实现主要涉及Thread，ThreadLocal，ThreadLocalMap这三个类。关于ThreadLocal的实现流程正如上面写的那样，实际代码还有许多细节处理的部分并没有在这里写出来。\n4.ThreadLocal特性 ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题，不同的点是\nSynchronized是通过线程等待，牺牲时间来解决访问冲突 ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。 正因为ThreadLocal的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了ThreadLocal。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。\n5.线程相关的一些问题 1.什么是线程？能解决什么问题。 Thread，是程序执行的基本单位，处理并发场景的时候使用，Java虚拟机运行程序同时运行多个执行线程。\n2.Java中创建线程的2种方式 \u0026amp; 区别？ ​\t1.重写run方法（可以声明一个类去继承Thread，也可以不声明，直接new，但是声明了可以方便复用）\nclass MyThread extends Thread { @Override public void run() { //具体的方法 System.out.println(Calendar.getInstance().getTime());//系统时间 } } //使用 MyThread myThread=new MyThread(); myThread.start(); ​\t2.实现Runnable接口，实现 run 方法\nclass MyRunnable implements Runnable { public void run() { System.out.println(Calendar.getInstance().getTime()); } } //使用 MyRunnable p = new MyRunnable(); new Thread(p).start(); 3.给我说说线程的生命周期。 新建：当使用new操作符创建新线程时，线程处于“新建“状态\n运行(可运行):调用start()方法\n阻塞：当线程需要获得对象的内置锁，而该锁正在被其他线程拥有\n等待：当线程等待其他线程通知调度表可以运行时\n计时等待：对于一些含有时间参数的方法，如Thread类的sleep()\n终止：当run()方法运行完毕或出现异常时\n4.线程死锁的原因 \u0026amp; 举个栗子 \u0026amp; 如何避免死锁。 死锁的四个条件：互斥、请求与保持、不剥夺、循环等待\n​ 1、互斥条件：所谓互斥就是线程在某一时间内独占资源。\n2、请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。\n3、不剥夺条件：线程已获得资源，在未使用完之前，不能强行剥夺。\n4、循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。\n哲学家就餐问题：5个哲学家和5根筷子。\n只要破坏死锁的四个条件之一即可。\n5.Synchronized放在静态方法和非静态方法上的锁对象分别是什么？ static的方法属于类方法，它属于这个Class（注意：这里的Class不是指Class的某个具体对象），那么static获取到的锁，是属于类的锁。而非static方法获取到的锁，是属于当前对象的锁。所以，他们之间不会产生互斥。\n那当我们想让所有这个类下面的方法都同步的时候，也就是让所有这个类下面的静态方法和非静态方法共用同一把锁的时候，我们如何办呢？此时我们可以使用Lock。\n6.如何停止掉一个线程？ 1、设置标志位\n2、调用stop方法：但官方不推荐，会可能造成出现数据不一致的问题。\n3、调用interrupt方法：Thread.currentThread().isInterrupted()为true时调用interrupt\n7.给我说说线程池的种类 \u0026amp; 特点 \u0026amp; 内部原理 \u0026amp; 平时当中使用案例。 线程池种类：\nJava通过Executors提供四种线程池，分别为： Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适用：执行很多短期异步的小程序或者负载较轻的服务器 Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。适用：执行长期的任务，性能好很多 Executors.newScheduledThreadPool 创建一个周期线程池，支持定时及周期性任务执行。适用：周期性执行任务的场景 Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。适用：一个任务一个任务执行的场景\n使用线程池的原因：\n​\t降低资源损耗\n​\t提高响应速度\n​\t提高线程可管理性\n线程池的内部原理：\n先看一下ThreadPoolExecutor类的execute方法：\npublic void execute(Runnable command) { if (command == null) throw new NullPointerException(); //获取clt，clt记录着线程池状态和运行线程数。 int c = ctl.get(); //运行线程数小于核心线程数时，创建线程放入线程池中，并且运行当前任务。 if (workerCountOf(c) \u0026lt; corePoolSize) { if (addWorker(command, true)) return; //创建线程失败，重新获取clt。 c = ctl.get(); } //线程池是运行状态并且运行线程大于核心线程数时，把任务放入队列中。 if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { int recheck = ctl.get(); //重新检查线程池不是运行状态时， //把任务移除队列，并通过拒绝策略对该任务进行处理。 if (! isRunning(recheck) \u0026amp;\u0026amp; remove(command)) reject(command); //当前运行线程数为0时，创建线程加入线程池中。 else if (workerCountOf(recheck) == 0) addWorker(null, false); } //运行线程大于核心线程数时并且队列已满时， //创建线程放入线程池中，并且运行当前任务。 else if (!addWorker(command, false)) //运行线程大于最大线程数时，失败则拒绝该任务 reject(command); } 在execute方法中，多次调用的addWorker方法，再看一下这个方法：\nprivate boolean addWorker(Runnable firstTask, boolean core) { retry: for (;;) { //获取clt，clt记录着线程池状态和运行线程数。 int c = ctl.get(); //获取线程池的运行状态。 int rs = runStateOf(c); //线程池处于关闭状态，或者当前任务为null //或者队列不为空，则直接返回失败。 if (rs \u0026gt;= SHUTDOWN \u0026amp;\u0026amp; ! (rs == SHUTDOWN \u0026amp;\u0026amp; firstTask == null \u0026amp;\u0026amp; ! workQueue.isEmpty())) return false; for (;;) { //获取线程池中的线程数 int wc = workerCountOf(c); //线程数超过CAPACITY，则返回false； //这里的core是addWorker方法的第二个参数， //如果为true则根据核心线程数进行比较， //如果为false则根据最大线程数进行比较。 if (wc \u0026gt;= CAPACITY || wc \u0026gt;= (core ? corePoolSize : maximumPoolSize)) return false; //尝试增加线程数，如果成功，则跳出第一个for循环 if (compareAndIncrementWorkerCount(c)) break retry; //如果增加线程数失败，则重新获取ctl c = ctl.get(); //如果当前的运行状态不等于rs，说明状态已被改变， //返回第一个for循环继续执行 if (runStateOf(c) != rs) continue retry; } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { //根据当前任务来创建Worker对象 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { //获得锁以后，重新检查线程池状态 int rs = runStateOf(ctl.get()); if (rs \u0026lt; SHUTDOWN || (rs == SHUTDOWN \u0026amp;\u0026amp; firstTask == null)) { if (t.isAlive()) throw new IllegalThreadStateException(); //把刚刚创建的线程加入到线程池中 workers.add(w); int s = workers.size(); //记录线程池中出现过的最大线程数量 if (s \u0026gt; largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { //启动线程，开始运行任务 t.start(); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; } 8.给我谈谈你是如何保证线程数据安全问题的？ 保证线程安全以是否需要同步手段分类，分为同步方案和无需同步方案。\n1、互斥同步（阻塞同步）：ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性。\n互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。\n2、非阻塞同步\n随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。\n​ 非阻塞的实现CAS（compare and swap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。\n​ CAS缺点：\n​ ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。\n​ ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3A。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。\n​ 3、无需同步方案\n​ *要保证线程安全，并不是一定就要进行同步*，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。\n​ 1）可重入代码\n​ 可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。\n​ 可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。\n​ （类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）\n2）线程本地存储\n​ 如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。\n​ 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。Android的Handler机制的Looper、AMS、ActivityThread用的ThreadLocal\ntip：线程的安全程度由强到弱：\n我们可以将java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。\n1、不可变\n​ 在java语言中，不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。如final关键字修饰的数据不可修改，可靠性最高。\n2、绝对线程安全\n绝对的线程安全完全满足Brian GoetZ给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的代价。\n3、相对线程安全\n相对线程安全就是我们通常意义上所讲的一个类是“线程安全”的。\n​ 它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。\n在java语言中，大部分的线程安全类都属于相对线程安全的，例如Vector、HashTable、Collections的synchronizedCollection（）方法保证的集合。\n4、线程兼容\n线程兼容就是我们通常意义上所讲的一个类不是线程安全的。\n线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境下可以安全地使用。Java API中大部分的类都是属于线程兼容的。如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。\n5、线程对立\n线程对立是指无论调用端是否采取了同步错误，都无法在多线程环境中并发使用的代码。由于java语言天生就具有多线程特性，线程对立这种排斥多线程的代码是很少出现的。\n一个线程对立的例子是Thread类的supend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都有死锁风险。正因此如此，这两个方法已经被废弃啦。\n9.wait()和sleep()的区别？ sleep()是使线程暂停执行一段时间的方法。wait()也是一种使线程暂停执行的方法。例如，当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。并且可以调用notify方法或者notifyAll方法通知正在等待的其他线程。notify方法仅唤醒一个线程（等待队列中的第一个线程）并允许他去获得锁。notifyAll方法唤醒所有等待这个对象的线程并允许他们去竞争获得锁。\nwait()方法必须放在同步控制方法和同步代码块中使用，sleep()方法则可以放在任何地方使用。sleep()方法必须捕获异常，而wait、notify、notifyAll不需要捕获异常。在sleep的过程中，有可能被其他对象调用他的interrupt，产生InterruptedException。由于sleep不会释放锁标志，容易导致死锁问题的发生，因此一般情况下，推荐使用wait方法。\n10.什么是公平锁\u0026amp;非公平锁\u0026amp;区别？ 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。 优点：所有的线程都能得到资源，不会饿死在队列中。 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。\n非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。\n11.给我讲讲线程间通信 ①同步\n这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。\n②while轮询的方式\n不停地通过while语句检测条件是否成立。\n③wait/notify机制\n在同步代码块使用。\nThread.join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。\n比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。\nt.join(); //调用join方法，等待线程t执行完毕 t.join(1000); //等待 t 线程，等待时间是1000毫秒。\n12.volatile关键字是如何使用的？原理是什么 volatile通常被比喻成\u0026quot;轻量级的synchronized\u0026quot;，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。\nvolatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。\n如以下代码，是一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } volatile的原理 为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。\n但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。\n但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议\n缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n所以，如果一个变量被volatile所修饰的话，**在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。**这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。\nvolatile与可见性\n可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\nJava内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。\n前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。\nvolatile与有序性\n有序性即程序执行的顺序按照代码的先后顺序执行。\n除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-\u0026gt;add-\u0026gt;save 有可能被优化成load-\u0026gt;save-\u0026gt;add 。这就是可能存在有序性问题。\n而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。\n普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。\nvolatile可以禁止指令重排，这就**保证了代码的程序会严格按照代码的先后顺序执行。**这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-\u0026gt;add-\u0026gt;save 的执行顺序就是：load、add、save。\nvolatile与原子性\n原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。\n线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。\n为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。\n所以，volatile是不能保证原子性的。\n在以下两个场景中可以使用volatile来代替synchronized：\n1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。\n2、变量不需要与其他状态变量共同参与不变约束。\n除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。\n13.说说使用5个线程去计算一个数组之和的思路。 五个线程交替累加计算数组之和，这种方法其实不如单线程直接累加快，因为交替累加需要前一个线程计算的结果。\n将数组分为5等分，让每个线程计算自己负责的那份，并发计算，最后汇总结果。这种方式比上面的速度会快些。因为线程独立计算，不依赖其他线程的结果。最后几个线程将总数累加即可。\n14.谈谈线程阻塞的原因有哪些？ 资源不足，线程获取不到资源，又不允许抢占剥夺其他线程的资源。\n15.谈谈你对notify的理解？ 会唤醒等待线程队列的其他一个线程。notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。\n16.你觉得Lock和Synchronized的区别是什么？ synchronized和lock的区别\n区别如下：\n来源： lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现； 异常是否释放锁： synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。） 是否响应中断 lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断； 是否知道获取锁 Lock可以通过trylock来知道有没有获取锁，而synchronized不能； Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离） 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度， 17.谈谈你对ReentrantLock的认识。 ReentrantLock在Java中是可重入锁 可重入锁：即递归锁，指的是在同一线程，外层函数获得锁之后，内层递归函数仍然有获得该锁的代码，但不受影响 ReentrantLock公平锁和非公平锁： ReentrantLock锁实现了Lock接口，里面具体锁的实现使用了抽象内部类Sync。Sync有两个实现类，NonfairSync和FairSync，即公平锁和非公平锁。\n18.调用run()和start()的区别？ 线程的run()方法是由java虚拟机直接调用的，如果我们没有启动线程（没有调用线程的start()方法）而是在应用代码中直接调用run()方法，那么这个线程的run()方法其实运行在当前线程（即run()方法的调用方所在的线程）之中，而不是运行在其自身的线程中，从而违背了创建线程的初衷；\n19.transient关键字的用法 \u0026amp; 作用 \u0026amp; 原理。 1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。\n2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。\n3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。\n第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的。\ntransient用于修饰不需要序列化的字段，如果一个引用类型被transient修饰，则其反序列化的值为null，如果一个基本类型被transient修饰，则其反序列化的值为0 ，如果字段的引用类型是不可序列化的类，则也应该使用transient修饰，它在序列化时会被直接跳过。\n20.ThreadPoolExecutor的工作策略有哪些？ 任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 *有界队列。*当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 被拒绝的任务\n当 Executor 已经关闭，并且 Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法 execute(java.lang.Runnable) 中提交的新任务将被 拒绝。在以上两种情况下， execute 方法都将调用其 RejectedExecutionHandler 的 RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor) 方法。下面提供了四种预定义的处理程序策略：\n在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时RejectedExecutionException。 在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 在 ThreadPoolExecutor.DiscardPolicy 中，不能执行的任务将被删除。 在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。 定义和使用其他种类的 RejectedExecutionHandler 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时。\n21.ThreadLocal了解吗？说说原理。 Threadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据，ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。见上面。\n22.权衡多线程的性能。 多线程一般需要注意同步问题，但是同步必定会牺牲性能，权衡性能不同场景需要采取不同的锁。\n23.如何理解同步和异步，阻塞和非阻塞。 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。 换句话说，就是由调用者主动等待这个调用的结果。\n而异步则是相反，调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用*发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。\n阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n24.比较一下线程和协程。 协同程序（coroutine）与多线程情况下的线程比较类似：有自己的堆栈，自己的局部变量，有自己的指令指针（IP，instruction pointer），但与其它协同程序共享全局变量等很多信息。\n协程(协同程序): 同一时间只能执行某个协程。开辟多个协程开销不大。协程适合对某任务进行分时处理。\n线程: 同一时间可以同时执行多个线程。开辟多条线程开销很大。线程适合多任务同时处理。\n1.协程，即协作式程序，其思想是，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CPU进行分时，协程可以访问和使用unity的所有方法和component\n2.线程，多线程是阻塞式的，每个IO都必须开启一个新的线程，但是对于多CPU的系统应该使用thread，尤其是有大量数据运算的时刻，但是IO密集型就不适合；而且thread中不能操作unity的很多方法和component\n线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起。\n25.从源码角度讲讲你对Thread类中run方法的理解。 如果直接调用run方法会在调用线程执行，如果调用start会在子线程执行。\n线程的实现有两种方法，第一种是继承Thread类，重写run()方法，并调用start()方法;第二种是实现Runnable接口，并实现接口中run()方法，然后调用start方法。那么从源码上来看，这两种方法有什么不同呢？\n首先，分析下Thread类中的run（）方法到底做了什么事情？\n@Override public void run() { if (target != null) { target.run(); } } run（）方法很简单，只是做了一个if判断，如果target不等于null，就调用target的run（）方法，那么target又是什么东东？我们点进去看一下：\n/* What will be run. */ private Runnable target; target 就是runnable，那么runnable又是什么呢？点进去瞅瞅：\npublic interface Runnable { public abstract void run(); } Runnable就是一个接口，在这个接口中只定了一个抽象的run()方法。\n在分析完Thread类的run()方法之后，我们回头再来分析线程的第一种实现方式——继承Thread类。\n当用继承Thead类这种方式实现线程时，必须要重写run()方法，那么为什么一定要重写run()方法呢?因为通过上面我们对Thread类的run()方法分析可知，如果不对run()方法进行重写，此时target等于null（因为没有传入target接口），跳过if判断，那就等于run()方法内什么都没有做，那我们继承Thread类有什么意义呢？只有当我们对run()方法进行重写，写入我们想让线程执行的代码，继承Thread这种方式才会有效果。\n第二种实现Runnable接口这种方式，与第一种方式的不同点就在与我们传入了一个Runnable接口，因为此时的Runnable target不再是null，所以进入if判断以后，会调用Runnable 接口中的run()方法，根据接口的定义，当我们实现一个接口时，必须要实现接口中的抽象方法，所以run()方法也必须要重写。\n通过以上的总结，大概明白了两种实现方式的区别，无非就是第一种方式调用了Thread类的参数为空的构造方法，此时targer的值为null，而第二种调用了传递参数为Runnable接口的构造方法，此时的target不等于null，进而调用Runnable接口的run()方法。\n打开Thread类源码，注意观察这两个构造函数中init方法的第二个参数target：\npublic Thread() { //target的值为null init(null, null, \u0026#34;Thread-\u0026#34; + nextThreadNum(), 0); } public Thread(Runnable target) { //传递进来了Runnable ，所以target的值不再是null init(null, target, \u0026#34;Thread-\u0026#34; + nextThreadNum(), 0); } 26.谈谈Java内存模型。 在Java语言中，采用的是共享内存模型来实现多线程之间的信息交换和数据同步的。\n线程之间通过共享程序公共的状态，通过读-写内存中公共状态的方式来进行隐式的通信。同步指的是程序在控制多个线程之间执行程序的相对顺序的机制，在共享内存模型中，同步是显式的，程序员必须显式指定某个方法/代码块需要在多线程之间互斥执行。\n主内存和工作内存：\nJava内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。\nJMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\n​ 线程1和线程2要想进行数据的交换一般要经历下面的步骤：\n1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。\n2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。\nJava内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：\n原子性（Atomicity）：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。\n基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。\n​\t**可见性：**一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。\nJava内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。\n无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。\n除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。\n使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。\n使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。\nfinal关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。\n**有序性：**对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。\nJava提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，\n在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。\n27.两次调用Thread对象的start方法会发生什么？为什么？ Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。\n关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：\n新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。\n就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。\n在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来。\n阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。\n等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。\n计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：\npublic final native void wait(long timeout) throws InterruptedException;\n终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。 在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。\n28.Thread的sleep方法会清除中断的状态吗？ Thread类的sleep(),wait()等方法，在接收到interrupt()方法中断时，会抛出异常，同时会将中断标志置为false,如果确实需要中断该线程，则应该在捕捉到异常后，继续调用interrupt()方法进行中断。\n29.为什么线程通信的方法wait,notify,notifyAll被定义于Object中，而sleep方法被定义在Thread类中？ wait是用来释放锁的。wait、notify、notifyAll被设计在Object类中的原因是，JAVA提供的锁是对象级的而不是线程级的，每个对象都有个锁，而线程是可以获得这个对象的。因此线程需要等待某些锁，那么只要调用对象中的wait()方法便可以了。而wait()方法如果定义在Thread类中的话，那么线程正在等待的是哪个锁就不明确了。这也就是说wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中是因为锁是属于对象的原因。\n对于sleep为什么被定义在Thread中，我们只要从sleep方法的作用来看就知道了，sleep的作用是：让线程在预期的时间内执行，其他时候不要来占用CPU资源。从上面的话术中，便可以理解为sleep是属于线程级别的，它是为了让线程在限定的时间后去执行。而且sleep方法是不会去释放锁的\n30.说说Thread类中提供的getState()方法作用，然后说说线程的状态有哪些以及转换过程。 新建、就绪、（运行,api中没有表示，与就绪并称Runnable）阻塞、等待、计时等待、终止\n从源码中可以看出, 线程一共有6种状态, 其状态转换关系如下图所示: 值得一提的是，从状态的定义中可以看出，RUNNABLE状态包含了我们通常所说的running和ready两种状态。\n31.用至少2种方式手写生产者消费者模式代码。 这种设计模式需要满足以下三点要求： （1）生产者生产数据到缓冲区中，消费者从缓冲区中取数据。 （2）如果缓冲区已经满了，则生产者线程阻塞； （3）如果缓冲区为空，那么消费者线程阻塞。 编写之前分析： （1）定义一个缓存队列，选择一个集合当做缓存，给予缓存上限，缓存队列只有两种行为（生产数据和消费数据）； （2）定义一个生产者线程，调用缓存队列中的生产行为； （3）定义一个消费者线程，调用缓存队列中的消费行为； 开始编写代码： 第一种方式: (双向链表LinkedHashMap和synchronized结合) 定义一个缓存队列\n/** * 公共缓存队列 * 只做两件事：（1）生产；（2）消费 */ public class PublicQueue\u0026lt;T\u0026gt; { private int putIndex = 0;//数据插入的角标 private int maxCount = 50;//缓存区最大长度 private LinkedHashMap\u0026lt;Integer, T\u0026gt; linkedHashMap = new LinkedHashMap\u0026lt;\u0026gt;();//缓冲区 public synchronized void add(T msg){ if(linkedHashMap.size() == maxCount){ //如果缓存区达到最大数量，则阻塞生产者线程 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else{ notifyAll();//唤醒所有线程 } linkedHashMap.put(putIndex, msg); System.out.println(\u0026#34;生产一个产品，当前商品角标为：\u0026#34;+putIndex+\u0026#34;===文本为：\u0026#34;+msg+\u0026#34;===缓存长度为：\u0026#34;+linkedHashMap.size()); putIndex = (putIndex + 1 \u0026gt;= maxCount) ? (putIndex + 1) % maxCount : putIndex + 1; } public synchronized T remove(){ if(linkedHashMap.size() == 0){ //如果缓存区没有数据，则阻塞消费线程 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } }else{ notifyAll();//唤醒所有线程 } Iterator it = linkedHashMap.entrySet().iterator(); T t = null; if(it.hasNext()){ Map.Entry\u0026lt;Integer, T\u0026gt; entry = (Map.Entry\u0026lt;Integer, T\u0026gt;) it.next(); t = entry.getValue(); int index = entry.getKey(); linkedHashMap.remove(index); System.out.println(\u0026#34;消费一个产品，当前商品角标为：\u0026#34;+index+\u0026#34;===文本为：\u0026#34;+ t +\u0026#34;===缓存长度为：\u0026#34;+linkedHashMap.size()); } return t; } } 定义一个生产者线程\n/** * 生产者线程 */ public class ProducerThread extends Thread { private PublicQueue publicQueue; public ProducerThread(PublicQueue publicQueue){ this.publicQueue = publicQueue; } @Override public void run() { for(int i=0;i\u0026lt;60;i++){ publicQueue.add(String.valueOf(i)); } } } 定义一个消费者线程\n/** * 消费者线程 */ public class ConsumerThread extends Thread { private PublicQueue publicQueue; public ConsumerThread(PublicQueue publicQueue){ this.publicQueue = publicQueue; } @Override public void run() { for(;;){ publicQueue.remove(); } } } 启动：\npublic class ProducerConsumerTest { public static void main(String[] args){ PublicQueue publicQueue = new PublicQueue(); ProducerThread producerThread = new ProducerThread(publicQueue); ConsumerThread consumerThread = new ConsumerThread(publicQueue); producerThread.start();//启动生产者线程 consumerThread.start();//启动消费者线程 } } 代码分析： （1）生产者/消费者设计模式顾名思义就是两个互斥线程，一个负责生产，一个负责消费，两者是线程不安全的； （2）这里选择使用LinkedHashMap作为缓存队列，LinkedHashMap是一个双向链表，用来处理线程不安全的数据，可以保证取出第一个数据，it.next()就是取出第一个数据。（LinkedHashMap可以保证遍历的顺序） （3）为了保证互斥线程的安全性，需要做对应的处理，以上代码使用了synchronized 、wait()、notifyAll()来保证。\n第二种方式： 双向链表LinkedHashMap和lock结合\n/** * 公共缓存队列 * 只做两件事：（1）生产；（2）消费 */ public class PublicQueue\u0026lt;T\u0026gt; { private int putIndex = 0;//数据插入的角标 private int maxCount = 50;//缓存区最大长度 private Lock lock; private Condition addCondition; private Condition removeCondition; public PublicQueue(){ lock = new ReentrantLock(); addCondition = lock.newCondition(); removeCondition =lock.newCondition(); } private LinkedHashMap\u0026lt;Integer, T\u0026gt; linkedHashMap = new LinkedHashMap\u0026lt;\u0026gt;();//缓冲区 public void add(T msg){ try { lock.lock(); if (linkedHashMap.size() == maxCount){ //如果缓存区达到最大数量，则阻塞生产者线程 addCondition.await();//等待 } linkedHashMap.put(putIndex, msg); System.out.println(\u0026#34;生产一个产品，当前商品角标为：\u0026#34;+putIndex+\u0026#34;===文本为：\u0026#34;+msg+\u0026#34;===缓存长度为：\u0026#34;+linkedHashMap.size()); putIndex = (putIndex + 1 \u0026gt;= maxCount) ? (putIndex + 1) % maxCount : putIndex + 1; removeCondition.signalAll();//唤醒所有线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public T remove(){ T t = null; try { lock.lock(); if (linkedHashMap.size() == 0){ //如果缓存区没有数据，则阻塞消费线程 removeCondition.await();//等待 } Iterator it = linkedHashMap.entrySet().iterator(); if(it.hasNext()){ Map.Entry\u0026lt;Integer, T\u0026gt; entry = (Map.Entry\u0026lt;Integer, T\u0026gt;) it.next(); t = entry.getValue(); int index = entry.getKey(); linkedHashMap.remove(index); System.out.println(\u0026#34;消费一个产品，当前商品角标为：\u0026#34;+index+\u0026#34;===文本为：\u0026#34;+ t +\u0026#34;===缓存长度为：\u0026#34;+linkedHashMap.size()); } addCondition.signalAll();//唤醒所有线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } return t; } } 第三种方式：（最简单的） 直接使用阻塞队列BlockingQueue\n/** * 公共缓存队列 * 只做两件事：（1）生产；（2）消费 */ public class PublicQueue\u0026lt;T\u0026gt; { private BlockingDeque\u0026lt;T\u0026gt; blockingDeque = new LinkedBlockingDeque\u0026lt;\u0026gt;(50);//缓冲区 public void add(T msg){ try { blockingDeque.put(msg); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产一个产品，当前商品角标为：\u0026#34;+\u0026#34;===文本为：\u0026#34;+msg); } public T remove(){ T t = null; try { t = blockingDeque.take(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;消费一个产品，当前商品角标为：\u0026#34;+\u0026#34;===文本为：\u0026#34;+t); return t; } } 32.interrupt、interrupted和isInterrupted方法的区别？ 1、interrupt()\ninterrupt方法用于中断线程。调用该方法的线程的状态为将被置为\u0026quot;中断\u0026quot;状态。\n注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。\n2、interrupted() 和 isInterrupted()\n首先看一下API中该方法的实现：\n该方法就是直接调用当前线程的isInterrupted(true)的方法。\npublic static boolean interrupted () { return currentThread().isInterrupted(true); } 然后再来看一下API中 isInterrupted的实现：\n该方法却直接调用当前线程的isInterrupted(false)的方法。\npublic boolean isInterrupted () { return isInterrupted(false); } 因此这两个方法有两个主要区别：\ninterrupted 是作用于当前线程，isInterrupted 是作用于调用该方法的线程对象所对应的线程。（线程对象对应的线程不一定是当前运行的线程。例如我们可以在A线程中去调用B线程对象的isInterrupted方法。） 这两个方法最终都会调用同一个方法\u0026mdash;\u0026ndash;isInterrupted( Boolean 参数````)，，只不过参数固定为一个是true，一个是false； 注意： isInterrupted( Boolean 参数````)是isInterrupted( )的重载方法。 由于第二个区别主要体现在调用的方法的参数上，让我们来看一看这个参数是什么含义\n先来看一看被调用的方法 isInterrupted(boolean arg)（Thread类中重载的方法）的定义：\n原来这是一个本地方法，看不到源码。不过没关系，通过参数名ClearInterrupted我们就能知道，这个参数代表是否要清除状态位。\n如果这个参数为true，说明返回线程的状态位后，要清掉原来的状态位（恢复成原来情况）。这个参数为false，就是直接返回线程的状态位。\n这两个方法很好区分，只有当前线程才能清除自己的中断位（对应interrupted（）方法）\n33.分别讲讲JVM内存结构,Java内存模型,Java对象模型。 在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域：\nJava虚拟机在执行Java程序的过程中，会把它管理的内存划分为几个不同的数据区域，这些区域都有各自的用途、创建时间、销毁时间。\n​ Java运行时数据区分为下面几个内存区域：\n1.PC寄存器/程序计数器：\n严格来说是一个数据结构，用于保存当前正在执行的程序的内存地址，由于Java是支持多线程执行的，所以程序执行的轨迹不可能一直都是线性执行。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存,这在某种程度上有点类似于“ThreadLocal”，是线程安全的。\n2.Java栈 Java Stack：\nJava栈总是与线程关联在一起的，每当创建一个线程，JVM就会为该线程创建对应的Java栈，在这个Java栈中又会包含多个栈帧(Stack Frame)，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向该地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧被创建，这个新创建的栈帧被放到Java栈的栈顶，变为当前的活动栈。同样现在只有这个栈的本地变量才能被使用，当这个栈帧中所有指令都完成时，这个栈帧被移除Java栈，刚才的那个栈帧变为活动栈帧，前面栈帧的返回值变为这个栈帧的操作栈的一个操作数。\n由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。\n在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。在Hot Spot虚拟机中，可以使用-Xss参数来设置栈的大小。栈的大小直接决定了函数调用的可达深度。\n​ 3.堆 Heap:\n堆是JVM所管理的内存中最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。\n4.方法区Method Area:\n方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，不像Java堆中其他部分一样会频繁被GC回收，它存储的信息相对比较稳定，在一定条件下会被GC，当方法区要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation，大小可以通过参数来设置,可以通过-XX:PermSize指定初始值，-XX:MaxPermSize指定最大值。\n5.常量池Constant Pool:\n常量池本身是方法区中的一个数据结构。常量池中存储了如字符串、final变量值、类名和方法名常量。常量池在编译期间就被确定，并保存在已编译的.class文件中。一般分为两类：字面量和引用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定为到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。\n6.本地方法栈Native Method Stack:\n本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。\n在jvm的内存结构中，对象保存在堆中，而我们在对对象进行操作时，其实操作的是对象的引用。\nJava对象包含三个部分 一个Java对象可以分为三部分存储在内存中，分别是：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。\n对象头（包含锁状态标志，线程持有的锁等标志） 实例数据 对齐填充 oop-klass model（hotspot jvm中的对象模型） Java虚拟机的底层是使用c++实现，而jvm并没有根据一个Java的实例对象去创建对应的c++对象，而是设计了一个oop-klass model ;\nOOP(Ordinary Object Pointer）：普通对象指针; 表示一个实例信息 Klass：描述对象实例的具体类型, 含了元数据和方法信息 创建目的：不想让每个对象中都含有一个vtable（虚函数表） 类就是一类事物的抽象概括。\nOOP体系： OOPs模块中包含了多个子模块，每个子模块对应一个类型，每一个类型的OOP都代表一个在JVM内部使用的特定对象的类型。 在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应的创建一个对应类型的OOP对象。 在Java中，JVM中的对象模型包含两部分：Oop和Klass，在类被加载的时候，JVM会给类创建一个instanceKlass，其中包含了类信息、常量、静态变量、即时编译器编译后的代码等，存储在方法区，用来在JVM层表示该Java类。而使用new一个对象后，JVM就会创建一个instanceOopDesc对象，该对象包含对象头和实例数据，对象头中保存的是锁的状态标志等信息，元数据则实际上是一个指针，指向instanceKlass。\nJava对象模型\u0026mdash;对象头(Mark Word) 对象自身的运行时数据\n这部分存储包括哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据被官方称为Mark Word，在32位和64位的虚拟机中的大小分别为32bit和64bit。\n由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以提高存储空间的利用率。即这部分数据会根据对象的状态来分配存储空间。\n对象的类型指针\n即指向对象的类元数据的指针。虚拟机可以通过该指针判定对象实例属于哪个类。\n在Java对象中比较特殊的是Java数组，一个数组实例的对象头中必须记录数组的长度。JVM可以通过对象头中的数组长度数据来判定数组的大小，这是访问数组类型的元数据无法得到的。\n对象的实例数据\n前面提到对象头是对象的额外开销，只有实例数据才是一个对象实例存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。这部分内容同时记录了子类从父类继承所得的各类型数据。\n填充\n对齐填充在对象数据中并不是必然的，只是起着占位符的作用，没有特别含义。HotSpot要求对象起始地址必须是8字节的整数倍。对象头的大小刚好符合要求，因此当实例数据没有对齐时，就需要通过填充来对齐数据。\n获取类的元数据\n虚拟机在加载类的时候会将类的信息、常量、静态变量和即时编译器编译后的代码等数据存储在方法区(Method Area)。类的元数据，即类的数据描述，也被存在方法区。我们知道对象头中会存有对象的类型指针，通过类型指针可以获取类的元数据。因此，对象的类型指针其实指向的是方法区的某个存有类信息的地址。\n但是，并不是每个对象实例都存有对象的类型指针。根据对象访问定位方法的不同，对象的类型指针被存放在不同的区域。\n通过句柄访问对象 对象的类型指针被存放在句柄池中； 通过Reference指针直接访问对象 对象的类型指针被存放在对象本身的数据中。 比较来说：\n使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，当对象被移动（垃圾收集时会经常移动对象）时智慧改变句柄中实例数据执政，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度快，节省了一次指针定位的时间开销（对象的访问在java中也非常频繁） 因此，Java的对象数据存储可以理解为：\n引用类型（指向对象的Reference） 存储在栈中 对象的类的元数据 （Class MetaData） 存储在方法区中 对象的实例数据 存储在堆中 对象内存布局 存储的是与对象本身定义的数据无关的额外存储成本，其数据结构不固定。 32位JVM中，对象不同装填的mark word各个比特位区间图示如下： 对象五种状态：无锁态、轻量级锁、重量级锁、GC标记和偏向锁。\nHotSpot中对象头主要包含两部分\n第一：\n用于存储对象自身的运行时数据，如上表中的对象哈希码，对象分代年龄，偏向线程id，偏向时间戳等。\n第二：\n类型指针了，我们看表中也有指针字样，那么这部分主要就是杜希昂指向它的类元数据的指针了，虚拟机就是通过这个指针来确定这个对象时那个实例。\n偏向锁和重量级锁\n偏向锁：\n主要解决无竞争下的锁性能问题\n按照HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作，CAS操作会延迟本地调用 偏向锁会偏向第一个访问锁的程序，如果接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不需要触发同步。 但是如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁 只能在单线程中起作用 ****轻量级锁：****为了在无多线程竞争的环境中使用CAS来替代synchronized。减少传统的重量级锁使用操作系统互斥量产生的性能消耗，是为了减少多线程进入互斥的几率。并非替代互斥。\n34.什么是happens-before?它的规则有哪些？ happens-before原则：\nJava内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。\n下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。\na.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。\nb.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。\nc.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。\nd.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。\ne.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。\nf.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。\ng.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。\nh.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。\n一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生 “呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与happens-before原则之间基本没有什么关系，所以衡量并发安全问题一切必须以happens-before 原则为准。\n35.什么是JMM?谈谈工作内存和主内存的关系。 在Java语言中，采用的是共享内存模型来实现多线程之间的信息交换和数据同步的。\n线程之间通过共享程序公共的状态，通过读-写内存中公共状态的方式来进行隐式的通信。同步指的是程序在控制多个线程之间执行程序的相对顺序的机制，在共享内存模型中，同步是显式的，程序员必须显式指定某个方法/代码块需要在多线程之间互斥执行。\n主内存和工作内存：\nJava内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。\nJMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。\n​ 线程1和线程2要想进行数据的交换一般要经历下面的步骤：\n1.线程1把工作内存1中的更新过的共享变量刷新到主内存中去。\n2.线程2到主内存中去读取线程1刷新过的共享变量，然后copy一份到工作内存2中去。\nJava内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：\n原子性（Atomicity）：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。\n基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。\n​\t**可见性：**一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。\nJava内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。\n无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。\n除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。\n使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。\n使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。\nfinal关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。\n**有序性：**对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。\nJava提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现，\n在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。\n36.Java重排序了解吗？谈谈重排序的3种情况。 首先我们先来了解一下什么是重排序:重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。\n从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示\n上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。\n1）数据依赖性（*针对单个处理器而已*）\n关于重排序，这里要先讲一个概念就是数据依赖性问题。如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为下列3种类型，如下表所示。\n上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。\n**2）*as-if-serial语义*\n**\nas-if-serial语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。\n为了遵守as-if-serial语义，编译器和处理器**不会对存在数据依赖关系的操作做重排序。**as-if-serial语义把单线程程序保护了起来，as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。\n3）happens-before\n​ 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。\n对happens-before关系的具体定义如下。\n① 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 ②两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。\n上面的①是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！上面的②是JMM对编译器和处理器重排序的约束原则。正如前面所言，其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。因此，happens-before关系本质上和as-if-serial语义是一回事。\n·as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。 ·as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。 as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n37.什么是可见性？为什么存在可见性问题？怎样解决可见性带来的问题？ 导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是禁用缓存和编译优化，但是这样问题虽然解决了，我们程序的性能可就堪忧了。\n合理的方案应该是按需禁用缓存以及编译优化。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。\nJava 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则，这也正是本期的重点内容。掌握这些方法，我们就可以按需地禁用缓存和编译优化了，也就掌握了Java内存模型最核心的东西。\n这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作，即被volatile修饰的变量写对读是可见的，确保线程在执行读操作时始终拿到的是新值。同时volatile禁止重排序功能，被volatile修饰的变量在进行读写时，这些变量是不能重排序；volatile变量前后的读写操作不能重排序\n38.管程是什么？谈谈它的重要性。 管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。\n管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。\n管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程利用OOP的封装特性解决了信号量在工程实践上的复杂性问题，因此java采用管理机制。\n管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。所谓管程，指的是管理共享变量以及对其操作过程，让它们支持并发访问。\n在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen 模型、Hoare 模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。所以今天我们重点介绍一下 MESA 模型。\n在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。\nsynchronized (this) { //此处自动加锁 // x是共享变量,初始值=10 if (this.x \u0026lt; 12) { this.x = 12; } } //此处自动解锁 ","date":"2021-06-05T00:00:00Z","permalink":"https://haolovelin.com/post/java8%E7%BA%BF%E7%A8%8B/","title":"Java（8）线程"},{"content":"七、集合(容器) 数据结构是以某种形式将数据组织在一起的集合，它不仅存储数据，还支持访问和处理数据的操作。JDK提供了几个能有效地组织和操作数据的数据结构（位于java.util包），这些数据结构通常称为Java集合框架。\n1.常见集合类概述 在Java容器中一共定义了2种集合, 顶层接口分别是Collection和Map。但是这2个接口都不能直接被实现使用，分别代表两种不同类型的容器。 简单来看，Collection代表的是单个元素对象的序列，（可以有序/无序，可重复/不可重复 等，具体依据具体的子接口Set，List，Queue等）；Map代表的是“键值对”对象的集合（同样可以有序/无序 等依据具体实现）\n（1）Collection 集合接口 Collection是最基本的集合接口，存储对象元素集合。一个Collection代表一组Object（元素）。有些容器允许重复元素有的不允许，有些有序有些无需。由Collection接口派生的两个接口是List和Set。这个接口的设计目的是希望能最大程度抽象出元素的操作。 定义\npublic interface Collection extends Iterable { \u0026hellip; } 泛型即该Collection中元素对象的类型，继承的Iterable是定义的一个遍历操作接口，采用hasNext next的方式进行遍历。具体实现还是放在具体类中去实现。 主要方法\nboolean add(Object o) 添加对象到集合 boolean remove(Object o) 删除指定的对象 int size() 返回当前集合中元素的数量 boolean contains(Object o) 查找集合中是否有指定的对象 boolean isEmpty() 判断集合是否为空 Iterator iterator() 返回一个迭代器 boolean containsAll(Collection c) 查找集合中是否有集合c中的元素 boolean addAll(Collection c) 将集合c中所有的元素添加给该集合 void clear() 删除集合中所有元素 void removeAll(Collection c) 从集合中删除c集合中也有的元素 void retainAll(Collection c) 从集合中删除集合c中不包含的元素\n1.1 ArrayList 1.ArrayList有用过吗？它是一个什么东西？可以用来干嘛？\n有用过，ArrayList就是数组列表，主要用来装载数据，当我们装载的是基本类型的数据int，long，boolean，short，byte…的时候我们只能存储他们对应的包装类，它的主要底层实现是数组Object[] elementData。\n与它类似的是LinkedList，和LinkedList相比，它的查找和访问元素的速度较快，但新增，删除的速度较慢。\n小结：ArrayList底层是用数组实现的存储。\n特点：查询效率高，增删效率低，线程不安全。使用频率很高。\n为啥线程 不安全还使用他呢？\n因为我们正常使用的场景中，都是用来查询，不会涉及太频繁的增删，如果涉及频繁的增删，可以使用LinkedList，如果你需要线程安全就使用Vector，这就是三者的区别了，实际开发过程中还是ArrayList使用最多的。\n不存在一个集合工具是查询效率又高，增删效率也高的，还线程安全的，至于为啥大家看代码就知道了，因为数据结构的特性就是优劣共存的，想找个平衡点很难，牺牲了性能，那就安全，牺牲了安全那就快速。\n1.2 HashMap 首先HashMap是线程不安全的，其主要体现：\n#1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。\n#2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。\n2.集合的一些相关问题 2.1 说说Java中集合的框架？ 一、Java集合框架概述\n集合可以看作是一种容器，用来存储对象信息。所有集合类都位于java.util包下，但支持多线程的集合类位于java.util.concurrent包下。\n数组与集合的区别如下：\n1）数组长度不可变化而且无法保存具有映射关系的数据；集合类用于保存数量不确定的数据，以及保存具有映射关系的数据。\n2）数组元素既可以是基本类型的值，也可以是对象；集合只能保存对象。\nJava集合类主要由两个根接口Collection和Map派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系，（注意：Map不是Collection的子接口）。\n其中List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合；Map代表的是存储key-value对的集合，可根据元素的key来访问value。\n上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类。\n二、Java集合常见接口及实现类\n1. Collection接口常见方法（来源于Java API）\n2. Set集合\nSet集合与Collection的方法相同，由于Set集合不允许存储相同的元素，所以如果把两个相同元素添加到同一个Set集合，则添加操作失败，新元素不会被加入，add()方法返回false。为了帮助理解，请看下面代码示例：\npublic class Test { public static void main(String[] args) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;String\u0026gt;(); set.add(\u0026#34;hello world\u0026#34;); set.add(\u0026#34;hello 冰湖一角\u0026#34;); set.add(\u0026#34;hello 冰湖一角\u0026#34;);//添加不进去 System.out.println(\u0026#34;集合中元素个数：\u0026#34;+set.size()); System.out.println(\u0026#34;集合中元素为：\u0026#34;+set.toString()); } } 运行结果如下：\n集合中元素个数：2 集合中元素为：[hello world, hello 冰湖一角]\n分析：由于String类中重写了hashCode()和equals()方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个\u0026quot;hello 冰湖一角\u0026quot;是加不进去的。\n下面着重介绍Set集合几个常用实现类：\n1）HashSet类\nHashSet是Set集合最常用实现类，是其经典实现。HashSet是按照hash算法来存储元素的，因此具有很好的存取和查找性能。\nHashSet具有如下特点：\n♦ 不能保证元素的顺序。\n♦ HashSet不是线程同步的，如果多线程操作HashSet集合，则应通过代码来保证其同步。\n♦ 集合元素值可以是null。\nHashSet存储原理如下：\n当向HashSet集合存储一个元素时，HashSet会调用该对象的hashCode()方法得到其hashCode值，然后根据hashCode值决定该对象的存储位置。HashSet集合判断两个元素相等的标准是(1)两个对象通过equals()方法比较返回true；(2)两个对象的hashCode()方法返回值相等。因此，如果(1)和(2)有一个不满足条件，则认为这两个对象不相等，可以添加成功。如果两个对象的hashCode()方法返回值相等，但是两个对象通过equals()方法比较返回false，HashSet会以链式结构将两个对象保存在同一位置，这将导致性能下降，因此在编码时应避免出现这种情况。\nHashSet查找原理如下：\n基于HashSet以上的存储原理，在查找元素时，HashSet先计算元素的HashCode值（也就是调用对象的hashCode方法的返回值），然后直接到hashCode值对应的位置去取出元素即可，这就是HashSet速度很快的原因。\n重写hashCode()方法的基本原则如下：\n♦ 在程序运行过程中，同一个对象的hashCode()方法返回值应相同。\n♦ 当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()方法返回值应该相等。\n♦ 对象中用作equals()方法比较标准的实例变量，都应该用于计算hashCode值。\n2）LinkedHashSet类\nLinkedHashSet是HashSet的一个子类，具有HashSet的特性，也是根据元素的hashCode值来决定元素的存储位置。但它使用链表维护元素的次序，元素的顺序与添加顺序一致。由于LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet，但在迭代访问Set里的全部元素时由很好的性能。\n3）TreeSet类\nTreeSet时SortedSet接口的实现类，TreeSet可以保证元素处于排序状态，它采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方法：自然排序和定制排序，默认采用自然排序。\n♦ 自然排序\nTreeSet会调用集合元素的compareTo(Object obj)方法来比较元素的大小关系，然后将元素按照升序排列，这就是自然排序。如果试图将一个对象添加到TreeSet集合中，则该对象必须实现Comparable接口，否则会抛出异常。当一个对象调用方法与另一个对象比较时，例如obj1.compareTo(obj2)，如果该方法返回0，则两个对象相等；如果返回一个正数，则obj1大于obj2；如果返回一个负数，则obj1小于obj2。\nJava常用类中已经实现了Comparable接口的类有以下几个：\n♦ BigDecimal、BigDecimal以及所有数值型对应的包装类：按照它们对应的数值大小进行比较。\n♦ Charchter：按照字符的unicode值进行比较。\n♦ Boolean：true对应的包装类实例大于false对应的包装类实例。\n♦ String：按照字符串中的字符的unicode值进行比较。\n♦ Date、Time：后面的时间、日期比前面的时间、日期大。\n对于TreeSet集合而言，它判断两个对象是否相等的标准是：两个对象通过compareTo(Object obj)方法比较是否返回0，如果返回0则相等。\n♦ 定制排序\n想要实现定制排序，需要在创建TreeSet集合对象时，提供一个Comparator对象与该TreeSet集合关联，由Comparator对象负责集合元素的排序逻辑。\n综上：自然排序实现的是Comparable接口，定制排序实现的是Comparator接口。（具体代码实现会在后续章节中讲解）\n4）EnumSet类\nEnumSet是一个专为枚举类设计的集合类，不允许添加null值。EnumSet的集合元素也是有序的，它以枚举值在Enum类内的定义顺序来决定集合元素的顺序。\n5）各Set实现类的性能分析\nHashSet的性能比TreeSet的性能好（特别是添加，查询元素时），因为TreeSet需要额外的红黑树算法维护元素的次序，如果需要一个保持排序的Set时才用TreeSet，否则应该使用HashSet。\nLinkedHashSet是HashSet的子类，由于需要链表维护元素的顺序，所以插入和删除操作比HashSet要慢，但遍历比HashSet快。\nEnumSet是所有Set实现类中性能最好的，但它只能 保存同一个枚举类的枚举值作为集合元素。\n以上几个Set实现类都是线程不安全的，如果多线程访问，必须手动保证集合的同步性，这在后面的章节中会讲到。\n3. List集合\nList集合代表一个有序、可重复集合，集合中每个元素都有其对应的顺序索引。List集合默认按照元素的添加顺序设置元素的索引，可以通过索引（类似数组的下标）来访问指定位置的集合元素。\n实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。\n1）ArrayList\nArrayList是一个动态数组，也是我们最常用的集合，是List类的典型实现。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。\nArrayList擅长于随机访问。同时ArrayList是非同步的。\n2）LinkedList\nLinkedList是List接口的另一个实现，除了可以根据索引访问集合元素外，LinkedList还实现了Deque接口，可以当作双端队列来使用，也就是说，既可以当作“栈”使用，又可以当作队列使用。\nLinkedList的实现机制与ArrayList的实现机制完全不同，ArrayLiat内部以数组的形式保存集合的元素，所以随机访问集合元素有较好的性能；LinkedList内部以链表的形式保存集合中的元素，所以随机访问集合中的元素性能较差，但在插入删除元素时有较好的性能。\n3）Vector\n与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。\n4）Stack\nStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。\n5）Iterator接口和ListIterator接口\nIterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口如下：\n♦ boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 ♦ Object next()：返回集合里下一个元素。 ♦ void remove()：删除集合里上一次next方法返回的元素。\nListIterator接口继承Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的基础上增加了以下几个方法：\n♦ boolean hasPrevious()：判断集合里是否存在上一个元素。如果有，该方法返回 true。 ♦ Object previous()：返回集合里上一个元素。 ♦ void add(Object o)：在指定位置插入一个元素。\n以上两个接口相比较，不难发现，ListIterator增加了向前迭代的功能（Iterator只能向后迭代），ListIterator还可以通过add()方法向List集合中添加元素（Iterator只能删除元素）。\n4. Map集合\nMap接口采用键值对Map\u0026lt;K,V\u0026gt;的存储方式，保存具有映射关系的数据，因此，Map集合里保存两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value，key和value可以是任意引用类型的数据。key值不允许重复，可以为null。如果添加key-value对时Map中已经有重复的key，则新添加的value会覆盖该key原来对应的value。常用实现类有HashMap、LinkedHashMap、TreeMap等。\nMap常见方法（来源于API）如下：\n1）HashMap与Hashtable\nHashMap与Hashtable是Map接口的两个典型实现，它们之间的关系完全类似于ArrayList与Vertor。HashTable是一个古老的Map实现类，它提供的方法比较繁琐，目前基本不用了，HashMap与Hashtable主要存在以下两个典型区别：\n♦ HashMap是线程不安全，HashTable是线程安全的。\n♦ HashMap可以使用null值最为key或value；Hashtable不允许使用null值作为key和value，如果把null放进HashTable中，将会发生空指针异常。\n为了成功的在HashMap和Hashtable中存储和获取对象，用作key的对象必须实现hashCode()方法和equals()方法。\nHashMap工作原理如下：\nHashMap基于hashing原理，通过put()和get()方法存储和获取对象。当我们将键值对传递给put()方法时，它调用建对象的hashCode()方法来计算hashCode值，然后找到bucket位置来储存值对象。当获取对象时，通过建对象的equals()方法找到正确的键值对，然后返回对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会存储在链表的下一个节点中。\n2）LinkedHashMap实现类\nLinkedHashMap使用双向链表来维护key-value对的次序（其实只需要考虑key的次序即可），该链表负责维护Map的迭代顺序，与插入顺序一致，因此性能比HashMap低，但在迭代访问Map里的全部元素时有较好的性能。\n3）Properties\nProperties类时Hashtable类的子类，它相当于一个key、value都是String类型的Map，主要用于读取配置文件。\n4）TreeMap实现类\nTreeMap是SortedMap的实现类，是一个红黑树的数据结构，每个key-value对作为红黑树的一个节点。TreeMap存储key-value对时，需要根据key对节点进行排序。TreeMap也有两种排序方式：\n♦ 自然排序：TreeMap的所有key必须实现Comparable接口，而且所有的key应该是同一个类的对象，否则会抛出ClassCastException。\n♦ 定制排序：创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。\n5）各Map实现类的性能分析\n♦ HashMap通常比Hashtable（古老的线程安全的集合）要快\n♦ TreeMap通常比HashMap、Hashtable要慢，因为TreeMap底层采用红黑树来管理key-value。\n♦ LinkedHashMap比HashMap慢一点，因为它需要维护链表来爆出key-value的插入顺序。\n2.2 Collection \u0026amp; Map区别 Collection 元素是单列的，Map是以键值对存在。\n2.3 谈谈你常用的集合 \u0026amp; 它们底层的实现方式 \u0026amp; 优缺点 \u0026amp; 使用场景。 ArrayList和Vector: ArrayList和Vector是List的两个典型实现类。它们底层的实现方案相同。都是采用动态数组的方式实现的。特点是元素有序并且可以重复。ArrayList本身是线程不安全的，Vector是线程安全的。但是Vector比较古老，所以绝大多数情况下应该使用ArrayList。 LinkedList: LinkedList也是List的一个具有代表性的实现类。底层采用的是双向链表。从中间插入和删除元素的效率更高。 HashMap: HashMap的是Map集合的常用实现类，底层采用的是哈希表的数据结构存放数据的。特点是插入和查询速度很快。但是随着元素个数越来越多，效率会有所下降，但是仍然是效率很高的一种数据结构。HashMap的key值是无序且不重复的。 LinkedHashMap: LinkedHashMap底层采用的是哈希表 + 链表的形式存放数据的。因为需要额外的维护一个链表，所谓元素的操作速度会比HashMap略慢。但是因为有链表的存在，遍历元素的速度反而会比HashMap快，并且可以按照元素的插入顺序遍历出来。 TreeMap: 底层采用的是红-黑树实现的。相对于哈希表，红黑树的插入和查询速度要慢，但是红-黑树可以维护元素本身的字典顺序，所以当需要对key进行大小排序的时候，才应该使用TreeMap，否则都应该选择HashMap HashSet/LinkedHashSet/TreeSet: Set集合的底层其实就是Map集合实现的。Set集合中包含一个Map集合，每个元素插入到Set集合中时，其实就是插入到底层的Map集合的key的位置，value是一个固定的Object对象，没有任何意义。因此可以发现Set和Map的实现类几乎是一一对应的。 2.4 Map的遍历方式有哪些？ 在java中所有的map都实现了Map接口，因此所有的Map（如HashMap, TreeMap, LinkedHashMap, Hashtable等）都可以用以下的方式去遍历。\n方法一：在for循环中使用entries实现Map的遍历：\n/** * 最常见也是大多数情况下用的最多的，一般在键值对都需要使用 */ Map \u0026lt;String,String\u0026gt;map = new HashMap\u0026lt;String,String\u0026gt;(); map.put(\u0026#34;熊大\u0026#34;, \u0026#34;棕色\u0026#34;); map.put(\u0026#34;熊二\u0026#34;, \u0026#34;黄色\u0026#34;); for(Map.Entry\u0026lt;String, String\u0026gt; entry : map.entrySet()){ String mapKey = entry.getKey(); String mapValue = entry.getValue(); System.out.println(mapKey+\u0026#34;:\u0026#34;+mapValue); } 方法二：在for循环中遍历key或者values，一般适用于只需要map中的key或者value时使用，在性能上比使用entrySet较好；\nMap \u0026lt;String,String\u0026gt;map = new HashMap\u0026lt;String,String\u0026gt;(); map.put(\u0026#34;熊大\u0026#34;, \u0026#34;棕色\u0026#34;); map.put(\u0026#34;熊二\u0026#34;, \u0026#34;黄色\u0026#34;); //key for(String key : map.keySet()){ System.out.println(key); } //value for(String value : map.values()){ System.out.println(value); } 方法三：通过Iterator遍历；\nIterator\u0026lt;Entry\u0026lt;String, String\u0026gt;\u0026gt; entries = map.entrySet().iterator(); while(entries.hasNext()){ Entry\u0026lt;String, String\u0026gt; entry = entries.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\u0026#34;:\u0026#34;+value); } 方法四：通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作；\nfor(String key : map.keySet()){ String value = map.get(key); System.out.println(key+\u0026#34;:\u0026#34;+value); } 2.5 给我说说ArrayList的扩容机制. 默认容量10，1.5倍扩容。\n1、add(E e)方法中\n① ensureCapacityInternal(size+1),确保内部容量，size是添加前数组内元素的数量\n② elementData[size++] = e 添加元素到相应位置，元素数量加1\n2、 ensureCapacityInternal(size+1)确保内部容量\n① 计算最小需要空间（如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值）\n② 判断是否需要扩容（如果最小需要空间比elementData的内存空间要大，则扩容）\n3、扩容 grow(int minCapacity)\nnewCapacity=oldCapacity + (oldCapacity \u0026raquo; 1),原来容量的1.5倍\n再与最小需要空间比较，与最大数组长度比较。\n2.6 什么是深拷贝 \u0026amp; 浅拷贝 \u0026amp; 如何深拷贝一个List集合. 对于基本数据类型，实际上是拷贝它的值，而对于引用数据类型，拷贝的就是它的引用，并没有创建一个新的对象，即没有分配新的内存空间。这样的拷贝就称作浅拷贝。\n深拷贝就是在引用类型进行拷贝时，创建了新的对象，即分配了新的内存空间给拷贝对象。下面就来具体看看浅拷贝和深拷贝的区别。\nList浅拷贝 众所周知，list本质上是数组，而数组的是以地址的形式进行存储。 如上图将list A浅拷贝给list B，由于进行的是浅拷贝，所以直接将A的内容复制给了B，java中相同内容的数组指向同一地址，即进行浅拷贝后A与B指向同一地址。造成的后果就是，改变B的同时也会改变A，因为改变B就是改变B所指向地址的内容，由于A也指向同一地址，所以A与B一起改变。\n几种浅拷贝\n1、遍历循环复制\n1 List\u0026lt;Person\u0026gt; destList = new ArrayList\u0026lt;Person\u0026gt;(srcList.size()); 2 for(Person p : srcList){ 3 destList.add(p); 4 } 2、使用List实现类的构造方法\nList\u0026lt;Person\u0026gt; destList = new ArrayList\u0026lt;Person\u0026gt;(srcList); 3、使用list.addAll()方法\nList\u0026lt;Person\u0026gt; destList = new ArrayList\u0026lt;Person\u0026gt;(); destList.addAll(srcList); 4、使用System.arraycopy()方法\n1 Person[] srcPersons=srcList.toArray(new Person[0]); 2 Person[] destPersons=new Person[srcPersons.length]; 3 System.arraycopy(srcPersons, 0, destPersons, 0, srcPersons.length); 5、使用Stream的方式copy\nList\u0026lt;Person\u0026gt; destList = srcList.stream().collect(Collectors.toList()); List深拷贝 如图，深拷贝就是将A复制给B的同时，给B创建新的地址，再将地址A的内容传递到地址B。ListA与ListB内容一致，但是由于所指向的地址不同，所以改变相互不受影响。\n深拷贝的方法\n1.使用序列化方法\n/** * 对集合进行深拷贝 * 注意需要岁泛型类进行序列化（实现serializable） * * @param src * @param \u0026lt;T\u0026gt; * @return * @throws IOException * @throws ClassNotFoundException */ public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; deepCopy(List\u0026lt;T\u0026gt; src) { try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(byteOut); ) { outputStream.writeObject(src); try (ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream inputStream = new ObjectInputStream(byteIn); ) { return (List\u0026lt;T\u0026gt;) inputStream.readObject(); } } catch (Exception e) { ThrowableUtils.getString(e); } return Collections.emptyList(); } 2.clone方法\npublic class A implements Cloneable { public String name[]; public A(){ name=new String[2]; } public Object clone() { A o = null; try { o = (A) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } for(int i=0;i\u0026lt;n;i+=){ copy.add((A)src.get(i).clone()); } Java对对象和基本的数据类型的处理是不一样的。在Java中用对象的作为入口参数的传递则缺省为”引用传递”，也就是说仅仅传递了对象的一个”引用”，这个”引用”的概念同C语言中的指针引用是一样的。当函数体内部对输入变量改变时，实质上就是在对这个对象的直接操作。 除了在函数传值的时候是”引用传递”，在任何用”＝”向对象变量赋值的时候都是”引用传递”。\n2.7 Set是如何确保它的唯一性的。 set保证里面元素的唯一性其实是靠两个方法，一是equals()和hashCode()方法\n往set里面添加数据的时候一般会有隐式的操作\n先是判断set集合中是否有与新添加数据的hashcode值一致的数据，\n如果有，那么将再进行第二步调用equals方法再进行一次判断，\n假如集合中没有与新添加数据hashcode值一致的数据，那么将不调用eqauls方法。\n只有hashcode和equals都相等的时候才是同一个元素。\n2.8 你觉得HashMap的元素顺序和什么有关？ HashMap散列图、Hashtable散列表是按“有利于随机查找的散列(hash)的顺序”。并非按输入顺序。遍历时只能全部输出，而没有顺序。甚至可以rehash()重新散列，来获得更利于随机存取的内部顺序。\n需要顺序可以用java.util.LinkedHashMap 就是按加入时的顺序遍历了。\n2.9 Java中HashMap如何解决哈希碰撞的？ 插入链表中，1.7.头插，1.8尾插。\n2.10 ConcurrentHashMap如何实现并发访问的？ 在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。\n正是基于这个前提，ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。\n总结\nConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。\n相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。\n在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。\n在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：\n减小请求同一个锁的频率。 减少持有锁的时间。 ConcurrentHashMap 的高并发性主要来自于三个方面：\n用分离锁实现多个线程间的更深层次的共享访问。 用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。 使用分离锁，减小了请求 同一个锁的频率。\n通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读 / 写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。\n通过减小请求同一个锁的频率和尽量减少持有锁的时间 ，使得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高。\n2.11 谈谈Java集合中那些线程安全的集合 \u0026amp; 实现原理。 HashTable、Vector\nVector的方法都是同步的(Synchronized),是线程安全的(thread-safe)。\nHashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。\nHashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。\nHashMap和Hashtable的区别 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。\nHashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。\nHashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。\n另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。\n由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。\nHashMap不能保证随着时间的推移Map中的元素次序是不变的。\nHashSet和HashMap的区别\nHashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 注意\nsychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。\nFail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。\n结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。\n2.12 说说有哪些集合能加入null,哪些不能加入null,为什么？ List 以索引来存取元素，有序的，元素是允许重复的，可以插入多个null。 Set 不能存放重复元素，无序的，只允许一个null Map 保存键值对映射，映射关系可以一对一、多对一 List 有基于数组、链表实现两种方式ArrayList、LinkedList Set、Map 容器有基于哈希存储和红黑树两种方式实现Hash、Tree Set 基于 Map 实现，Set 里的元素值就是 Map的键值 2.13 说说LinkedHashMap原理。 对于linkedHashMap的基本操作还是和HashMap一样，在其上面加了两个属性，也就是为了记录前一个插入的元素和记录后一个插入的元素。也就是只要和hashmap一样进行操作之后把这两个属性的值设置好，就OK了。注意一点，会有一个header的实体，目的是为了记录第一个插入的元素是谁，在遍历的时候能够找到第一个元素。\n实际上的存储方式是和hashMap一样，但是同时增加了一个新的东西就是 双向循环链表。就是因为有了这个双向循环链表，LinkedHashMap才和HashMap不一样。\n2.14 Collection 和 Collections的区别？ 1.Collection:\n是集合类的上层接口。本身是一个Interface，里面包含了一些集合的基本操作。\nCollection接口是Set接口和List接口的父接口\n2.Collections\nCollections是一个集合框架的帮助类，里面包含一些对集合的排序，搜索以及序列化的操作。最根本的是Collections是一个类,\n2.15 比较一下ArrayMap和HashMap。 HashMap内部是使用一个默认容量为16的数组来存储数据的，而数组中每一个元素却又是一个链表的头结点或者红黑树的根节点，所以，更准确的来说，HashMap内部存储结构是使用哈希表的数组+链表+红黑树。如图：\n这些Entry数据是按什么规则进行存储的呢？就是通过计算元素key的hash值，然后对HashMap中数组长度取余得到该元素存储的位置，计算公式为(key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026raquo;\u0026gt; 16);\n2.16 说说HashMap的原理。 HashMap是以键值对存储数据的集合容器 HashMap是非线程安全的。 HashMap底层数据结构：数组+(链表、红黑树)，jdk8之前是用数组+链表的方式实现，jdk8引进了红黑树 Hashmap数组的默认初始长度是16，key和value都允许null的存在 HashMap的内部实现数组是Node[]数组，上面存放的是key-value键值对的节点。HashMap通过put和get方法存储和获取。 HashMap的put方法，首先计算key的hashcode值，定位到对应的数组索引，然后再在该索引的单向链表上进行循环遍历，用equals比较key是否存在，如果存在则用新的value覆盖原值，如果没有则向后追加。 jdk8中put方法：先判断Hashmap是否为空，为空就扩容，不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值threshold，大于就扩容，否则直接结束。 Hashmap解决hash冲突，使用的是链地址法，即数组+链表的形式来解决。put执行首先判断table[i]位置，如果为空就直接插入，不为空判断和当前值是否相等，相等就覆盖，如果不相等的话，判断是否是红黑树节点，如果不是，就从table[i]位置开始遍历链表，相等覆盖，不相等插入。 HashMap的get方法就是计算出要获取元素的hash值，去对应位置获取即可。 HashMap的扩容机制，Hashmap的扩容中主要进行两步，第一步把数组长度变为原来的两倍，第二步把旧数组的元素重新计算hash插入到新数组中，jdk8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。 HashMap大小为什么是2的幂次方？效率高+空间分布均匀，因为初始是16，每次都扩容成原来的2倍，必然是2的幂次方 2.17 从源码角度剖析ArrayList,LinkedList List代表一种线性表的数据结构，ArrayList则是一种顺序存储的线性表。ArrayList底层采用数组来保存每个集合的元素，LinkedList则是一种链式存储的线性表。其本质上就是一个双向链表，但它不仅实现了List接口，还是想了Deque接口。也就是说LinkedList既可以当成双向链表使用，也可以当成队列使用，还可以当成栈来适用于（Deque代表双端队列，即具有队列的特征，也具有栈的特征）。\nArrayList底层采用一个elementData数组来保存所有集合的元素，因此ArrayList在插入元素时需要完成下面两件事情。\n保证ArrayList底层封装的数组长度大于集合元素的个数； 将插入位置之后的所有数组元素“整体搬家”，向后移动一“格”。 LinkedList本质上是一个双向链表，因此它可以非常方便地在指定节点之前插入新节点，LinkedList在指定位置添加新节点就是通过这种方式来实现的。\nnode(int index):搜索指定索引处的元素。 linkBefore(E e, Node succ):在succ节点之前插入element新节点。 node(int index实际上就是get(int index)方法的底层实现。对于ArrayList来说，由于它底层采用数组来保存集合元素，因此可以直接根据数组索引取出index位置的元素；但是对于LinkedList就比较麻烦了，LinkedList必须要一个一个元素的搜索，直到找到第index个元素为止。\n当程序需要以get(int index)方法获取指定索引处的元素时，ArrayList性能大大地优于Linkedlist.因为Arraylist底层以数组来保存集合元素，所示调用get(int index)方法来获取指定索引处的元素时，底层实际上调用 elementdata［index］来返回该元素，因此性能非常好。\n当程序调用 add(int index， Object obj)向List集合中添加元素时， Arraylist必须对底层数组元素进行“整体搬家”，如果添加元素导致集合长度将要超过底层数组长度，ArrayList必须创建一个长度为原来长度1.5倍的数组，再由垃圾回收机制回收原有数组，因此 开销比较大。对于 LinkedList而言，它的主要开销集中在 node(index)方法上，该方法必須一个个地搜索过去，直到找到index处的元素，然后再在该元素之前插入新元索。即使如此，执行该方法的时候 LinkedList方法的性能依然高于ArrayList\n当程序调用 remove（int index）方法删除 index索引处的元素时， Arraylist同样也需要对底层数组元素进行“整体搬家”。但调用 remove（int index）方法別除集合元素时， Arraylist无需考虑创建新数组，因此执行 ArrayList的 remove（int index）方法比执行add（ int index， Object o)方法略快一点。当 Linkedlist调用 remove（ int index）方法删除集合元素时，与调用 add（int index,Oject obj）方法添加元素的系统开销几乎完全相同。\n当程序调用add(Object obj）方法向List集合尾端添加一个元素时，大部分时候 ArrayList无需对底层数组元素进行“整体搬家”，因此也可以获得很好的性能（甚至比 Linkedlist的add(Object obj)方法的性能更好;但如果添加这个元素导致集合长度将要超过底层数组长度，那么 ArrayList必须创建一个长度为原来长度1.5倍的数组，再由垃圾回收机制回收原有数组一一这样系统开销就比较大了。但 Linkedlist调用add(Object obj）方法添加元系时总可以获得较好的性能。\n2.18 你如何看待Java 8中HashMap引入红黑树？ 在jdk1.8版本后，java对HashMap做了改进，在链表长度大于8的时候，将后面的数据存在红黑树中，以加快检索速度，我们接下来讲一下红黑树。\n红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。加快检索速率。\n红黑树的5个性质：\n1.每个结点要么是红的要么是黑的。\n2.根结点是黑的。\n3.每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。\n4.如果一个结点是红的，那么它的两个儿子都是黑的。\n5.对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 红黑树还可以描述成： ⑴红链接均为左链接。 ⑵没有任何一个结点同时和两条红链接相连。 ⑶该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。\n红黑树 一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的节点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。\n性质\n每个节点不是红色就是黑色 不可能有连在一起的红色节点 根节点是黑色 叶子节点（null）都是黑色 变换规则\n改变颜色 左旋 右旋 变色的情况：当前结点的父亲是红色，且他的祖父节点的另一个子节点（叔叔节点）也是红色： a、把父节点设置为黑色 b、把叔叔节点也设置为黑色 c、把父亲的父节点（祖父节点）设置为红色 d、把指针定义到祖父节点设为当前要操作的节点，目的是为了平衡修改颜色其它节点不满足红黑树原则的情况（通过更改颜色或左旋右旋平衡，以此类推） 颜色变换示例 (给0005新增一个大于它的子节点)： 旋转示例（新增节点、父节点、祖父节点同一条直线） a、以最短路径旋转(顺时针为右旋，逆时针为左旋) b、以父节点为旋转中心，旋转祖父节点 c、父节点变成黑色，祖父节点变成红色 d、当前操作节点为变成红色的祖父节点（递归他坐在的父节点是否满足红黑树原则） 旋转示例（新增节点5，以父节点4为旋转中心旋转祖父节点，该示例为左旋操作） 旋转示例（新增节点、父节点、祖父节点同呈三角关系） a、以最短路径旋转(顺时针为右旋，逆时针为左旋) b、首先以新增节点为旋转中心，旋转父节点，使新增节点、父节点、祖父节点在同一条直线上 c、然后再参考上面同一条直线的情况进行旋转（递归处理，以此类推） 旋转示例： 新增节点48，以48为圆心旋转47节点——左旋 然后变成在同一条线上的情况，以48为圆心，旋转父节点50——右旋 红黑树详细变换图解 红黑树相比avl树，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多。红黑树不像avl树一样追求绝对的平衡，他允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，avl树调平衡有时候代价较大，所以效率不如红黑树。\n2.19 HashMap为什么线程不安全？ 首先HashMap是线程不安全的，其主要体现：\n#1.在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。\n#2.在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。\n","date":"2021-06-04T00:00:00Z","permalink":"https://haolovelin.com/post/java7%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/","title":"Java（7）集合（容器）"},{"content":"六、NIO BIO AIO 1.NIO是什么 \u0026amp; BIO是什么 \u0026amp; AIO是什么 \u0026amp; 它们之间的区别？ IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。\nbio:同步阻塞，服务器实现模式是一个连接一个线程，当客户端发来连接时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，当然线程池机制可以改善。\nnio:同步非阻塞，服务器实现模式为多个请求一个线程，即客户端发来的请求都会注册到多路复用器上，多路复用器轮训的连接有io请求时才开启一个线程进行处理。\naio:异步非阻塞，服务器实现模式为多个有效请求一个线程。即客户端发来的请求由os处理完成才会通知服务器应用启动线程进行处理。\n2.IO按照方向和数据类型划分能划分为哪些数据流？ 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 3.能给我说说NIO有什么特点？平常开发中使用过吗？ Java NIO的高效得益于其两大\u0026quot;助手\u0026quot;：Channel(管道)和Buffer(缓冲器)。\n1)Non-blocking IO（非阻塞IO）\nIO流是阻塞的，NIO流是不阻塞的。\nJava NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\nJava IO的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了\n2)Buffer(缓冲区)\nIO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。\nBuffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。\n在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。\n最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。\n3)Channel (通道)\nNIO 通过Channel（通道） 进行读写。\n通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。\n4)Selectors(选择器)\nNIO有选择器，而IO没有。\n选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。\n4.为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？ 从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：\nJDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100% 项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug ","date":"2021-06-02T00:00:00Z","permalink":"https://haolovelin.com/post/java6niobioaio/","title":"Java（6）NIO、BIO、AIO"},{"content":"五、Java异常体系 Java异常以Throwable开始，扩展出Error和Exception。 Error是程序代码无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止退出，其表示程序在运行期间出现了十分严重、不可恢复的错误，应用程序只能中止运行。 Exception分运行时异常和非运行时异常。运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常也是不检查异常，程序代码中自行选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序代码应该从逻辑角度尽可能避免这类异常的发生。所有继承Exception且不是RuntimeException的异常都是非运行时异常，也称检查异常，如上图中的IOException和ClassNotFoundException，编译器会对其作检查，故程序中一定会对该异常进行处理，处理方法要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。\n1.说说Java异常体系主要用来干什么的 \u0026amp; 异常体系？ 无论何时，代码都能可靠运行，即使发生异常，程序也能执行而不是停止；\n异常处理使代码的阅读、编写和调试工作更加方便。\nJava语言规定Exception对象可以捕获并处理掉。\n常见的异常种类 ERROR类： java.lang.OutOfMemoryError：最可怕的错误之一，JVM内存不足导致的Error，程序直接停止运行。 java.lang.StackOverflowError：最可怕的错误之一，JVM栈溢出错误，程序直接停止运行。 java.lang.NoClassDefFoundError：未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 注意：NoClassDefFoundError和ClassNotFoundException的区别。\nRuntimeException类： java.lang.ClassCastException：强制类型转换异常，一般发生在向下类型转换过程中。 java.lang.IndexOutOfBoundsException：索引越界异常。 java.lang.NullPointerException：空指针异常。 java.lang.NumberFormatException：数字格式异常。 java.lang.ArithmeticException：算术条件异常。比如：除数为零时。 java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。 java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 java.lang.InterruptedException：线程阻塞异常。\n受检查异常类： java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPATH之后找不到对应名称的class文件时，抛出该异常。 java.lang.NoSuchMethodException：找不到方法异常。 注意：上面两个很容易被理解为RuntimeException，如果你去看了源码就会知道他们是受检查的异常。\n2.Error和Exception的区别？ Exception和Error都是继承了Throwable类 Error是指正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序（比如JVM自身）处于非正常状态，不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。 Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应的处理。 Exception又分为可检查（checked）异常和不检查（unchecked）异常。\n可检查异常在源码里必须显示的进行捕获处理，这里是编译期检查的一部分。前面我们介绍的不可查的Error，是Throwable不是Exception。 不检查异常就是所谓的运行时异常，类似NullPointerException,ArrayIndexOutOfBoundsExceptin之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。\n3.说说运行时异常和非运行时异常的区别？ 运行时异常（RuntimeException）和非编译时异常，非受检查时异常等同。运行时异常，比如“数组越界”，“空指针”，“算数异常”，“类型转换异常”，这些时不时都是因为我们程序的逻辑不够严谨而造成。\n受检查时异常，编译异常，非运行时异常，描述可以理解为同一个意思。是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不要自定义检查异常。\n4.如何自定义一个异常？ 为这个找一个近似的类作为父类。 在该类中编写两个构造器: 默认构造器; 带String message参数的构造器且在该构造器中使用 super(message); 语句来调用父类的构造器完成异常原因的更改。\n5.throw和throws 的区别？ throw：\n作用在方法内，表示抛出具体异常，由方法体内的语句处理。 具体向外抛出的动作，所以它抛出的是一个异常实体类。若执行了Throw一定是抛出了某种异常。 throws：\n作用在方法的声明上，表示如果抛出异常，则由该方法的调用者来进行异常处理。\n主要的声明这个方法会抛出会抛出某种类型的异常，让它的使用者知道捕获异常的类型。\n出现异常是一种可能性，但不一定会发生异常。\n实例：\nvoid testException(int a) throws IOException{ try{ ...... }catch(Exception1 e){ throw e; }catch(Exception2 e){ System.out.println(\u0026#34;出错了！\u0026#34;); } if(a!=b) throw new Exception3(\u0026#34;自定义异常\u0026#34;); } 6.try{ }catch{ }finally{ }可以没有finally吗？ 可以，三种搭配，try{ }catch{ }、try{ }finally{ }、try{ }catch{ }finally{ }\n7.finally语块有什么特点？ 被finally控制的语句体一定会执行,特殊情况：在执行finally之前，jvm退出了,例如System.exit(0)\nfinally的作用： 用于释放资源，在IO操作和数据库操作中会见到\n8.return在try{}catch{}finally{}中执行具有哪些规则？ 在一般情况下，finally控制的语句体一定会执行 如果catch里面有return语句，finally的代码还会执行，在return前执行。\n9.给我例举至少5个常见的运行时异常。 ClassCastException(类转换异常)、IndexOutOfBoundsException(数组越界异常)、NullPointerException(空指针异常)、ArrayStoreException(数据存储异常，操作数组时类型不一致)、BufferOverflowException(还有IO操作的,缓冲溢出异常)。\n","date":"2021-06-01T00:00:00Z","permalink":"https://haolovelin.com/post/java5java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","title":"Java（5）Java异常体系"},{"content":"四、Java字符编码方式 1.字节与字符 字节（Byte）=8bit 默认数据的最小单位 字符（Character）=2byte=16bit（Java默认UTF-16编码）\n2.为何要编码——如何让计算机表示人类能够理解的符号 1、计算机中存储信息的最小单元是1byte即8bit，所以能表示的字符范围是 0~255 个 2、人类要表示的符号太多，无法用一个字节来完全表示 3、需要一个新的数据结构char来表示这些字符。char与byte之间转换需要编码与解码 编码：字节与字符的转换方式\n3.各类编码规范 3.1 ASCII 我们知道，在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。 ASCII码一共规定了128个字符的编码，比如空格\u0026quot;SPACE\u0026quot;是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。\n3.2 ISO-8858-1 但西方世界不光只有英语一门语言。包括德语，法语，西班牙语都有自己的特殊字母。每个国家都可以定义属于自己语言的特殊编码标准，而且大小照样不超过256。因为ASCII码中本身就有很多空码位没有使用。 128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。\n3.3 GB2312 信息交换用汉字编码字符集 基本集 双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。\n3.4 GBK 汉字内码扩展规范 扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。 这也是很多文件默认使用的编码，有时候打开文件中文变乱码了，这时候就需要规定编码方式为GBK。\n3.5 Unicode Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 在出现Unicode之前，几乎每一种文字都有一套自己的编码方式。同一段“字节流”，在美帝可能是\u0026quot;hello world\u0026quot;，到我们天朝就变成“锟斤拷” ，“烫烫烫”了。 ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。故这本字典很复杂。最初，每个字符占用2个字节，总共65535个字符空间。从第四版开始加入的“扩展字符集”开始使用4个字节（32 bit）编码。目前Unicode收录的字符规模大概在12万左右。 Unicode只是一套符号的编码，计算机对Unicode字符具体存取方式有:UTF-16（字符用2字节表示）、UTF-32（字符用4字节表示）、UTF-8（字符不定长）\n3.5.1 UTF-16 UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。 UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，但是这对于存储来说是极大的浪费，可以看到补了很多的0，文本文件的大小会因此大出二三倍，这是无法接受的。\n3.5.2 UTF-8 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有二条： 1、对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。 2、对于n字节的符号（n\u0026gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。\n4.几种编码格式的比较 4.1 GB2312 与 GBK GB2312 与 GBK编码规则类似，但是 GBK 范围更大，它能处理所有汉字字符，所以 GB2312 与 GBK 比较应该选择 GBK。\n4.2 UTF-16 与 UTF-8 UTF-16 与 UTF-8都是处理 Unicode 编码，它们的编码规则不太相同，相对来说 UTF-16 编码效率最高，字符到字节相互转换更简单，进行字符串操作也更好。它适合在本地磁盘和内存之间使用，可以进行字符和字节之间快速切换，如 Java 的内存编码就是采用 UTF-16 编码。但是它不适合在网络之间传输，因为网络传输容易损坏字节流，一旦字节流损坏将很难恢复，想比较而言 UTF-8 更适合网络传输，对 ASCII 字符采用单字节存储，另外单个字符损坏也不会影响后面其它字符，在编码效率上介于 GBK 和 UTF-16 之间，所以 UTF-8 在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。\n5.Java对字符的处理 5.1 IO操作中存在的编码 我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口：\nReader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。 写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。如下图所示：\n同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。 如下面一段代码，实现了文件的读写功能：\nString file = \u0026#34;c:/stream.txt\u0026#34;; String charset = \u0026#34;UTF-8\u0026#34;; // 写字符换转成字节流 FileOutputStream outputStream = new FileOutputStream(file); OutputStreamWriter writer = new OutputStreamWriter( outputStream, charset); try { writer.write(\u0026#34;这是要保存的中文字符\u0026#34;); } finally { writer.close(); } // 读取字节转换成字符 FileInputStream inputStream = new FileInputStream(file); InputStreamReader reader = new InputStreamReader( inputStream, charset); StringBuffer buffer = new StringBuffer(); char[] buf = new char[64]; int count = 0; try { while ((count = reader.read(buf)) != -1) { buffer.append(buffer, 0, count); } } finally { reader.close(); } 5.2 内存中操作中的编码 在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例：\ngetBytes（charset） 这是java字符串处理的一个标准函数，其作用是将字符串所表示的字符按照charset编码，并以字节方式表示。注意字符串在java内存中总是按unicode编码存储的。比如\u0026quot;中文\u0026quot;，正常情况下（即没有错误的时候）存储为\u0026quot;4e2d 6587\u0026quot;，如果charset为\u0026quot;gbk\u0026quot;，则被编码为\u0026quot;d6d0 cec4\u0026quot;，然后返回字节\u0026quot;d6 d0 ce c4\u0026quot;.如果charset为\u0026quot;utf8\u0026quot;则最后是\u0026quot;e4 b8 ad e6 96 87\u0026quot;.如果是\u0026quot;iso8859-1\u0026quot;，则由于无法编码，最后返回 “3f 3f”（两个问号）。 java.class类的编码为：unicode; windows默认的编码为：中文：gb2312; 英文：iso8859;\nString str = \u0026#34;张三\u0026#34; ; byte[] jiema= str.getBytes(\u0026#34;gb2312\u0026#34;) ; //解码 String bianma = new String(jiema,\u0026#34;UTF-8\u0026#34;);//编码 如果上面的解码不对 可能出现问题 new String(charset) 这是java字符串处理的另一个标准函数，和上一个函数的作用相反，将字节数组按照charset编码进行组合识别，最后转换为unicode存储。参考上述getBytes的例子，“gbk” 和\u0026quot;utf8\u0026quot;都可以得出正确的结果\u0026quot;4e2d 6587\u0026quot;，但iso8859-1最后变成了\u0026quot;003f 003f\u0026quot;（两个问号）。 因为utf8可以用来表示/编码所有字符，所以new String（ str.getBytes（ “utf8” ）， “utf8” ） === str，即完全可逆。\nsetCharacterEncoding() 该函数用来设置http请求或者相应的编码。 对于request，是指提交内容的编码，指定后可以通过getParameter（）则直接获得正确的字符串，如果不指定，则默认使用iso8859-1编码，需要进一步处理。参见下述\u0026quot;表单输入\u0026quot;.值得注意的是在执行setCharacterEncoding（）之前，不能执行任何getParameter（）。java doc上说明：This method must be called prior to reading request parameters or reading input using getReader（）。而且，该指定只对POST方法有效，对GET方法无效。分析原因，应该是在执行第一个getParameter（）的时候，java将会按照编码分析所有的提交内容，而后续的getParameter（）不再进行分析，所以setCharacterEncoding（）无效。而对于GET方法提交表单是，提交的内容在URL中，一开始就已经按照编码分析所有的提交内容，setCharacterEncoding（）自然就无效。 对于response，则是指定输出内容的编码，同时，该设置会传递给浏览器，告诉浏览器输出内容所采用的编码。\n6.总结 总而言之，一切都是字节流，其实没有字符流这个东西。字符只是根据编码集对字节流翻译之后的产物。而编码集是人为规定的产物。\n","date":"2021-05-30T00:00:00Z","permalink":"https://haolovelin.com/post/java4%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/","title":"Java（4）字符编码方式"},{"content":"三、Java常用语法 1.==、equals、hashCode 1.1 == 1.1.1 介绍 java中的数据类型，可分为两类： 1.基本数据类型，也称原始数据类型（byte,short,char,int,long,float,double,boolean） 基本数据类型用==比较的是数据的值。 2.引用类型(类、接口、数组) 引用类型用==进行比较的是他们在内存中的存放地址。 所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见’==\u0026lsquo;是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写equals方法了。\n1.1.2 实例 public static void main(String[] args) { int int1 = 12; int int2 = 12; Integer Integer1 = new Integer(12); Integer Integer2 = new Integer(12); Integer Integer3 = new Integer(127); Integer a1 = 127; Integer b1 = 127; Integer a = 128; Integer b = 128; String s1 = \u0026#34;str\u0026#34;; String s2 = \u0026#34;str\u0026#34;; String str1 = new String(\u0026#34;str\u0026#34;); String str2 = new String(\u0026#34;str\u0026#34;); System.out.println(\u0026#34;int1==int2:\u0026#34; + (int1 == int2));//true System.out.println(\u0026#34;int1==Integer1:\u0026#34; + (int1 == Integer1));//true，Integer会自动拆箱为int，所以为true System.out.println(\u0026#34;Integer1==Integer2:\u0026#34; + (Integer1 == Integer2));//false,不同对象，在内存中存放位置不同 System.out.println(\u0026#34;Integer3==b1:\u0026#34; + (Integer3 == b1));//false，Integer3指向new的对象地址,b1指向缓存中127的地址 System.out.println(\u0026#34;a1==b1:\u0026#34; + (a1 == b1));//true,a1,b1均指向缓存中127的地址 System.out.println(\u0026#34;a==b:\u0026#34; + (a == b));//false，根据源码，a1,b1在127与-127范围之外时会指向new的对象地址 System.out.println(\u0026#34;s1==s2:\u0026#34; + (s1 == s2));//true System.out.println(\u0026#34;s1==str1:\u0026#34; + (s1 == str1));//false System.out.println(\u0026#34;str1==str2:\u0026#34; + (str1 == str2));//false } 1.2 equals 1.2.1 默认情况（没有重写equals方法） Object的equals方法主要用于判断对象内存地址引用是不是同一个 地址（是不是同一个对象） 定义的equals与==等效：\npublic boolean equals(Object obj) { return (this == obj); } 1.2.2 重写equals方法 根据具体的代码确定equlas方法，重写后一般都是通过对象的内容是否相等来判断对象是否相等。下面是String类对equals方法进行重写：\n//String类equals方法的判断步骤： //1.若A==B 即是同一个String对象 返回true //2.若对比对象是String类型则继续，否则返回false //3.判断A、B长度是否一样，不一样的话返回false //4.逐个字符比较，若有不相等字符，返回false public boolean equals(Object anObject) { if (this == anObject) {//参数是否为这个对象的引用 return true; } if (anObject instanceof String) {//参数是否为正确的类型 String anotherString = (String)anObject; //获取关键域，判断关键域是否匹配 int n = count; if (n == anotherString.count) { char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) { if (v1[i++] != v2[j++]) return false; } return true; } } return false; } 1.3 hashCode 1.3.1 定义 public native int hashCode(); hashCode()方法返回的就是一个hash码（int类型）。 hash码的主要用途就是在对对象进行散列的时候作为key输入，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能（将数据按特定算法指定到一个地址上）。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。\n1.3.2 作用 hashCode只有在集合中用到，相当于集合的key，利用下标访问可以提高查找效率 Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ Java采用了哈希表的原理。当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；（放入对象的hashcode与集合中任一元素的hashcode不相等） 如果这个位置上已经有元素了（hashcode相等），就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。 所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。\n1.4 equals与hashCode 1.4.1 equals与hashCode关系 同一对象上多次调用hashCode()方法，总是返回相同的整型值。 如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。 如果!a.equals(b)，则a.hashCode() 不一定等于 b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 a.hashCode()==b.hashCode() 则 a.equals(b)可真可假 a.hashCode()！= b.hashCode() 则 a.equals(b)为假。\n1.4.2 实例 同时覆盖hashcode与equals方法：\n//学生类 public class Student { private int age; private String name; public Student() { } public Student(int age, String name) { super(); this.age = age; this.name = name; } public int getAge() { return age; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public void setName(String name) { this.name = name; } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); System.out.println(\u0026#34;hashCode : \u0026#34;+ result); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } 运行结果： stu1 == stu2 : false stu1.equals(stu2) :true list size:2 hashCode :775943 hashCode :775943 set size:1 结果分析： 重写equals保证姓名、年龄相等为同一对象 重写hashCode保证相同的对象不重复存入集合 stu1和stu2通过equals方法比较相等，而且返回的hashCode值一样，所以放入set集合中时只放入了一个对象。\n1.4.3 equals与hashCode重写规范 （1）如果两个对象相同，那么他们的hashcode应该相等 若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。 （2）如果两个对象不相同，他们的hashcode可能相同 如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。\n为了满足上述规范，覆盖equals方法时总要覆盖hashCode，这样该类才能结合所有基于散列的集合（如HashMap、HashSet、HashTable）一起正常运作\n2.序列化 2.1 什么是序列化？ 对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序；从字节流创建对象的相反的过程称为反序列化。 序列化以特定的方式对类实例的瞬时状态进行编码保存的一种操作.序列化作用的对象是类的实例.对实例进行序列化,就是保存实例当前在内存中的状态.包括实例的每一个属性的值和引用等.反序列化的作用便是将序列化后的编码解码成类实例的瞬时状态.申请等同的内存保存该实例. 序列化的作用就是为了保存java的类对象的状态，并将对象转换成可存储或者可传输的状态，用于不同jvm之间进行类实例间的共享。\n2.2 为什么JAVA对象需要实现序列化？ 序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。我们可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间(注：要想将对象传输于网络必须进行流化)因为在对对象流进行读写操作时会引发一些问题，而序列化机制正是用来解决这些问题的。 （若对象不进行序列化，则无法跨平台传输，安全性也无法得到保证）\n2.3 序列化的方式？ 2.3.1 方式1：要传递的类实现Serializable接口传递对象（Java自带） 2.3.1.1 Serializable接口 Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。用于保存在内存中各种对象的状态，并且可以把保存的对象状态再读出来。 序列化后的对象可以在网络上进行传输，也可以存储到本地。对于任何需要被序列化的对象，都必须要实现接口Serializable,它只是一个标识接口，本身没有任何成员，只是用来标识说明当前的实现类的对象可以被序列化.\n2.3.1.2 Java序列化应用场景 a.把内存中的对象状态保存到一个文件中或者数据库中时候； b.用套接字在网络上传送对象的时候； c.通过RMI传输对象的时候；…\n2.3.1.3 实例 使用Java序列化把对象存储到文件中，再从文件中读出来创建序列化对象：\npublic class Box implements Serializable{ private int width; private int height; public Box(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } @Override public String toString() { return \u0026#34;Child{\u0026#34; + \u0026#34;width=\u0026#34; + width + \u0026#34;, height=\u0026#34; + height + \u0026#39;}\u0026#39;; } } 读写测试 使用ObjectOutputStream对象的writeObject()方法来进行对象的写入。 使用ObjectInputStream对象的readObject()方法来读取对象。\npublic class SerializableTest { public static void main(String args[]) throws Exception{ File file = new File(\u0026#34;box.out\u0026#34;); FileOutputStream fos = new FileOutputStream(file); ObjectOutputStream out = new ObjectOutputStream(fos); Box oldBox = new Box(10,20); out.writeObject(oldBox); out.close(); FileInputStream fis = new FileInputStream(file); ObjectInputStream in = new ObjectInputStream(fis); Box newBox = (Box)in.readObject(); in.close(); System.out.println(newBox.toString()); } } 输出结果\nChild{width=10, height=20} 2.3.2 方式2：要传递的类实现Parcelable接口传递对象（android专用） 2.3.2.1 Parcelable接口 进行Android开发的时候，无法将对象的引用传给Activities或者Fragments，我们需要将这些对象放到一个Intent或者Bundle里面，然后再传递 不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。 Parcelable作用： 1）永久性保存对象，保存对象的字节序列到本地文件中； 2）通过序列化对象在网络中传递对象； 3）通过序列化在进程间传递对象。\n2.3.2.2 Android序列化应用场景 需要在多个部件(Activity或Service)之间通过Intent传递一些数据，简单类型（如：数字、字符串）的可以直接放入Intent。复杂类型必须实现Parcelable接口。 1）在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。 2）Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。 3）Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。\n2.3.2.3 实现 写实体类，实现Parcelable接口 1、复写describeContents方法和writeToParcel方法 2、实例化静态内部对象CREATOR，实现接口Parcelable.Creator 3、自定义构造方法，私有变量的set与get\npublic class Pen implements Parcelable{ private String color; private int size; // 系统自动添加，给createFromParcel里面用 protected Pen(Parcel in) { color = in.readString(); size = in.readInt(); } public static final Creator\u0026lt;Pen\u0026gt; CREATOR = new Creator\u0026lt;Pen\u0026gt;() { /** * * @param in * @return * createFromParcel()方法中我们要去读取刚才写出的name和age字段， * 并创建一个Person对象进行返回，其中color和size都是调用Parcel的readXxx()方法读取到的， * 注意这里读取的顺序一定要和刚才写出的顺序完全相同。 * 读取的工作我们利用一个构造函数帮我们完成了 */ @Override public Pen createFromParcel(Parcel in) { return new Pen(in); // 在构造函数里面完成了 读取 的工作 } //供反序列化本类数组时调用的 @Override public Pen[] newArray(int size) { return new Pen[size]; } }; @Override public int describeContents() { return 0; // 内容接口描述，默认返回0即可。 } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(color); // 写出 color dest.writeInt(size); // 写出 size } // ======分割线，写写get和set //个人自己添加 public Pen() { } //个人自己添加 public Pen(String color, int size) { this.color = color; this.size = size; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public int getSize() { return size; } public void setSize(int size) { this.size = size; } } MainActivity与SecondActivity之间传递实体Bean\n//MainActivity public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.mTvOpenNew).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent open = new Intent(MainActivity.this, SecondActivity.class); Person person = new Person(); person.setName(\u0026#34;一去二三里\u0026#34;); person.setAge(18); // 传输方式一，intent直接调用putExtra // public Intent putExtra(String name, Serializable value) open.putExtra(\u0026#34;put_ser_test\u0026#34;, person); // 传输方式二，intent利用putExtras（注意s）传入bundle /** Bundle bundle = new Bundle(); bundle.putSerializable(\u0026#34;bundle_ser\u0026#34;,person); open.putExtras(bundle); */ startActivity(open); } }); // 采用Parcelable的方式 findViewById(R.id.mTvOpenThird).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent mTvOpenThird = new Intent(MainActivity.this,ThirdActivity.class); Pen tranPen = new Pen(); tranPen.setColor(\u0026#34;big red\u0026#34;); tranPen.setSize(98); // public Intent putExtra(String name, Parcelable value) mTvOpenThird.putExtra(\u0026#34;parcel_test\u0026#34;,tranPen); startActivity(mTvOpenThird); } }); } } //SecondActivity public class SecondActivity extends Activity{ private TextView mTvSecondDate; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); mTvSecondDate = (TextView) findViewById(R.id.mTvSecondDate); // Intent intent = getIntent(); // Pen pen = (Pen)intent.getParcelableExtra(\u0026#34;parcel_test\u0026#34;); Pen pen = (Pen)getIntent().getParcelableExtra(\u0026#34;parcel_test\u0026#34;); mTvSecondDate = (TextView) findViewById(R.id.mTvSecondDate); mTvSecondDate.setText(\u0026#34;颜色:\u0026#34;+pen.getColor()+\u0026#34;\\\\n\u0026#34; +\u0026#34;大小:\u0026#34;+pen.getSize()); } } Serializable 和Parcelable的对比 android上应该尽量采用Parcelable，效率至上 （1）编码上： Serializable代码量少，写起来方便；Parcelable代码多一些 （2）效率上： Parcelable的速度比高十倍以上；serializable的迷人之处在于你只需要对某个类以及它的属性实现Serializable 接口即可。Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。 这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。 Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了\n3.内部类 3.1 什么是内部类 定义在类内部的类就被称为内部类。外部类按常规的类访问方式使用内部类，唯一的差别是内部类可以访问外部类的所有方法与属性，包括私有方法与属性。 内部类是一个编译时的概念。外部类outer.java内定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件，分别是outer.class和outer$inner.class。\n3.2 为什么要设计内部类 内部类是为了更好的封装，把内部类封装在外部类里，不允许同包其他类访问 内部类中的属性和方法即使是外部类也不能直接访问，相反内部类可以直接访问外部类的属性和方法，即使private 实现多继承：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 匿名内部类用于实现回调\n3.3 内部类分类 3.3.1 静态内部类 定义在类内部的静态类：\npublic class Out { private static int a; private int b; public static class Inner { public void print() { System.out.println(a); } } } Inner是静态内部类。静态内部类可以访问外部类所有静态变量和方法。静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。\nOut.Inner inner = new Out.Inner(); inner.print(); public class Out$Inner { public Out$Inner() { } public void print() { System.out.println(Out.access$000()); } } Out.java编译后会生成两个class文件，分别是Out.class和Out$Inner.class。因为这两个类处于同一个包下，所以静态内部类自然可以访问外部类的非私有成员。对外部类私有变量的访问则通过外部类的access$000()方法。\n应用场景\n与外部类关系密切且不依赖外部类实例。 Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap内部维护Entry数组用了存放元素，但是Entry对使用者是透明的。\n3.3.2 成员内部类 定义在类内部的非静态类称为成员内部类。\npublic class Out { private static int a; private int b; public class Inner { public void print() { System.out.println(a); System.out.println(b); } } } 成员内部类可以访问外部类所有的变量和方法，包括静态和实例，私有和非私有。和静态内部类不同的是，每一个成员内部类的实例都依赖一个外部类的实例（成员内部类是依附外部类而存在的）。其它类使用内部类必须要先创建一个外部类的实例。\nOut out = new Out(); Out.Inner inner = out.new Inner(); inner.print(); 注： （1）成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。 （2）成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 （3）成员内部类与外部类可以拥有同名的成员变量或方法，默认情况下访问的是成员内部类的成员。如果要外部类的同名成员，需用下面的形式访问：\nOutterClass(外部类).this.成员 Out.java编译后会生成两个class文件，分别是Out.class和Out$Inner.class。成员内部类的代码如下：\npublic class Out$Inner { public Out$Inner(Out var1) { this.this$0 = var1; } public void print() { System.out.println(Out.access$000()); } } 成员内部类访问外部类的私有变量和方法也是通过编译时生成的代码访问的。区别是，成员内部类的构造方法会添加一个外部类的参数。 解释：为什么Java中成员内部类可以访问外部类成员？ 总结为2点：1、内部类对象的创建依赖于外部类对象；2、内部类对象持有指向外部类对象的引用。 编译器自动为内部类添加一个类型为Outer，名字为this$0的成员变量，这个成员变量就是指向外部类对象的引用； 编译器自动为内部类的构造方法添加一个类型为Outer的参数，在构造方法内部使用这个参数为内部类中添加的成员变量赋值； 在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。 应用场景 静态内部类\u0026amp;成员内部类对比 3.3.3 局部内部类\u0026amp;闭包 局部内部类 定义在外部类方法中的类，叫局部类\npublic class Out { private static int a; private int b; public void test(final int c) { final int d = 1; class Inner { public void print() { System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); } } } public static void testStatic(final int c) { final int d = 1; class Inner { public void print() { System.out.println(a); //定义在静态方法中的局部类不可以访问外部类的实例变量 //System.out.println(b); System.out.println(c); System.out.println(d); } } } } 局部类只能在定义该局部类的方法中使用。定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。同时局部类还可以访问方法的参数和方法中的局部变量，这些参数和变量必须要声明为final的。否则会报错：Cannot refer to a non-final variable x inside an inner class defined in a different method Out.java编译后局部类会生成相应的class文件。\nclass Out$1Inner { Out$1Inner(Out var1, int var2) { this.this$0 = var1; this.val$c = var2; } public void print() { System.out.println(Out.access$000()); System.out.println(Out.access$100(this.this$0)); System.out.println(this.val$c); System.out.println(1); } } 和成员内部类类似，生成的局部类的构造方法包含了外部类的参数，并且还包含了定义局部类方法的参数。 解释了为什么局部类访问的变量需要final修饰？ 基本知识：内部类和外部类是处于同一个级别的，方法内部的类不是在调用方法时才会创建的，它们一样也被事先编译了,内部类也不会因为定义在方法中就会随着方法的执行完毕就被销毁。（内部类只有没有引用指向该对象时，才回被GC回收） 问题1：外部类方法结束时候，局部变量就会销毁，但内部类对象可能还存在，并指向一个不存在的局部变量。 问题2：局部变量复制为内部类的成员变量时，必须保证两个变量一致。在内部类修改成员变量，方法中局部变量也会跟着改变。 解决：将局部变量设置为final 这样编译器会将final局部变量\u0026quot;复制\u0026quot;作为局部内部类中的数据成员（且此时为常量） 使内部类无法去修改这个变量。保证复制的数据成员与原始变量一致。 仿佛局部变量的\u0026quot;生命周期\u0026quot;延长了 应用场景 局部内部类是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，但又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。\n闭包 闭包就是把函数以及变量包起来，使得变量的生存周期延长。闭包跟面向对象是一棵树上的两条枝，实现的功能是等价的。 闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。JAVA并不能显式地支持闭包，但是在JAVA中，闭包可以通过“接口+内部类”（接口实例化）来实现。 闭包是实现回调的一种很灵活的方式\npublic class OutClass { private void readBook(){ System.out.println(\u0026#34;read book\u0026#34;); } public InnerClass getInnerClass(){ return new InnerClass(); } public class InnerClass{ public void read(){ readBook(); } } } 匿名函数里的变量引用，也叫做变量引用泄露，会导致线程安全问题，因此如果在匿名类内部引用函数局部变量，必须将其声明为final，即不可变对象。\n3.3.4 匿名内部类 匿名内部类需要提前定义（必须存在）\npublic class Out { private static int a; private int b; private Object obj = new Object() { private String name = \u0026#34;匿名内部类\u0026#34;; @Override public String toString() { return name; } }; public void test() { Object obj = new Object() { @Override public String toString() { System.out.println(b); return String.valueOf(a); } }; System.out.println(obj.toString()); } } Out.java编译后匿名内部类会生成相应的class文件。\nclass Out$1 { private String name; Out$1(Out var1) { this.this$0 = var1; this.name = \u0026#34;匿名内部类\u0026#34;; } public String toString() { return this.name; } } 匿名内部类可以访问外部类所有的变量和方法。 应用场景 匿名内部类常用于回调函数，比如我们常用的绑定监听的时候。\npublic interface OnClickListener { /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v); } view.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(v.getContext(),\u0026#34;click\u0026#34;,Toast.LENGTH_SHORT).show(); } }); 3.4 内部类总结 3.4.1 内部类特点 1.非静态内部类对象不仅指向该内部类，还指向实例化该内部类的外部类对象的内存。 2.内部类和普通类一样可以重写Object类的方法，如toString方法；并且有构造函数，执行顺序依旧是先初始化属性，再执行构造函数 3.在编译完之后，会出现（外部类.class）和（外部类﹩内部类.class）两个类文件名。 4.内部类可以被修饰为private，只能被外部类所访问。事实上一般也都是如此书写。 5.内部类可以被写在外部类的任意位置，如成员位置，方法内。\n3.4.2 内部类访问外部类 静态时，静态内部类只能访问外部类静态成员;非静态内部类都可以直接访问。（原因是：内部类有一个外部类名.this的指引）当访问外部类静态成员出现重名时，通过(外部类名.静态成员变量名)访问。如，Out.show(); 重名情况下，非静态时，内部类访问自己内部类通过this.变量名。访问外部类通过（外部类名.this.变量名）访问 。如Out.this.show(); 在没有重名的情况下，无论静态非静态，内部类直接通过变量名访问外部成员变量。\n3.4.3 外部类访问内部类 内部类为非静态时，外部类访问内部类，必须建立内部类对象。建立对象方法，如前所述。 内部类为静态时，外部类访问非静态成员，通过（外部类对象名.内部类名.方法名）访问，如new Out().In.function(); 内部类为静态时，外部类访问静态成员时，直接通过（外部类名.内部类名.方法名），如 Out.In.funchtion(); 当内部类中定义了静态成员时，内部类必须是静态的；当外部静态方法访问内部类时，内部类也必须是静态的才能访问。\n","date":"2021-05-29T00:00:00Z","permalink":"https://haolovelin.com/post/java3%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","title":"Java（3）常用语法"},{"content":"二、基本数据类型和引用类型 基本数据类型 对应的引用类型（封装类型） 占用的字节 取值范围 默认值 boolean Boolean 《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。 true/false false char Character 2B 0~2^16-1（0 ~ 65535无符号） \\u0000 byte Byte 1B -128~127 0 short Short 2B -2^15 ~ 2^15-1（-32768～32767） 0 int Integer 4B -2^31 ~ 2^31-1（-2147483648～2147483647） 0 long Long 8B -2^63 ~ 2^63-1（-9223372036854775808 ~ 9223372036854775807） 0 float Float 4B -2^128 ~ 2^128 0.0F double Double 8B -2^1024 ~ 2^1024 0.0D 1.基础数据类型与封装类型的区别 1.1 传递方式不同 基本类型（原始数据类型）在传递参数时都是按值传递。 封装类型是引用类型，按引用传递的(其实“引用也是按值传递的”，传递的是对象的地址)。由于包装类型都是不可变量，因此没有提供改变它值的方法，增加了对“按引用传递”的理解难度。 int是基本类型，直接存放数值；Integer是类，产生对象时用一个引用指向这个对象。\n1.2 封装类可以有方法和属性 封装类可以有方法和属性，利用这些方法和属性来处理数据，如Integer.parseInt(Strings)。基本数据类型都是final修饰的，不能继承扩展新的类、新的方法。\n1.3 默认值不同 基本类型跟封装类型的默认值是不一样的。如int i,i的预设为0；Integer j，j的预设为null,因为封装类产生的是对象，对象默认值为null。\n1.4 存储位置 基本类型在内存中是存储在栈中，引用类型的引用（值的地址）存储在栈中，而实际的对象（值）是存在堆中。 虽然基本类型在栈上分配内存效率高，但是在堆栈上分配内存可能有内存泄漏的问题。\n1.5 基础类型与封装类型对比 基本数据类型的好处就是速度快（不涉及到对象的构造和回收），封装类的目的主要是更好的处理数据之间的转换。\nJDK5.0开始可以自动装箱了，基本数据类型可以自动封装成封装类。 比如集合List，往里添加对象Object，在JDK5.0 之前，需要将数字封装成封装类型对象，再存到List中。\n2.自动装箱和拆箱 自动装箱就是：自动将基本数据类型转换为包装器类型；\n自动拆箱就是：自动将包装器类型转换为基本数据类型。\n装箱是通过调用包装器类的 valueOf 方法实现的 拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。 如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。\nInteger i = 10; //自动装箱，执行时实际上系统执行了：Integer i = Integer.valueOf(10); int n = i; //自动拆箱，实际上执行了 int t = i.intValue(); Integer的valueOf源码：\npublic static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high)//low = -128; high默认是127，可以配置，但不会低于127 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 对于–128到127（默认是127）之间的值，Integer.valueOf(int i) 返回的是缓存的Integer对象（并不是新建对象），而其他值，执行Integer.valueOf(int i) 返回的是一个新建的 Integer对象。装箱的过程会创建对应的对象，这个会消耗内存，所以装箱的过程会增加内存的消耗，影响性能。\nInteger的intValue源码：\npublic int intValue() { return value; } 3.关于Integer和int的比较 3.1 new生成的Integer变量比较 由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。\nInteger i = new Integer(100); Integer j = new Integer(100); System.out.print(i == j); //false 3.2 Integer变量和int变量比较 Integer变量和int变量比较时，只要两个变量的值是相等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆箱为int，然后进行比较，实际上就变为两个int变量的比较）\nInteger i = new Integer(100); int j = 100； System.out.print(i == j); //true 3.3 非new生成的Integer变量和new生成的变量比较 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）\nInteger i = new Integer(100); Integer j = 100; System.out.print(i == j); //false 3.4 两个非new生成的Integer对象比较 两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false\nInteger i = 100; Integer j = 100; System.out.print(i == j); //true Integer i = 128; Integer j = 128; System.out.print(i == j); //false 原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；根据上文提及的，java API中对Integer类型的valueOf的定义如下：\npublic static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high)//low = -128; high默认是127，可以配置，但不会低于127 return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } java对于-128到127之间的数，会直接从缓存中取，故相等。否则创建一个新的对象，所以后面两个不是同一个对象，故不等。\n4.数值在计算机中存储方式？ 4.1 带符号数（正数/负数）在计算机中存储方式 原码：原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。 补码：正数的补码就是其本身。负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 补码是计算机存储带符号数的方式，可以解决0的符号问题以及两个编码问题。 为什么byte类型（8位二进制表示）的取值范围为-128~127？ 0用[0000 0000]表示，-128用[1000 0000]表示。byte类型1个字节，8位二进制，范围为[1000 0000]~[0111 1111]\n4.2 浮点数（小数）在计算机中存储方式（遵循IEEE754标准） 在计算机中，保存这个数使用的是浮点表示法，分为三大部分： 第一部分用来存储符号位（sign），用来区分正负，这里是 0，表示正数 第二部分用来存储指数（exponent） 第三部分用来存储小数（fraction）\nfloat类型是32位，是单精度浮点表示法： 符号位占用1位，指数位占用 8 位，小数位占用 23 位。 float 的小数位只有 23 位，即二进制的 23 位，能表示的最大的十进制数为 2 的 23 次方，即 8388608，即十进制的 7 位，严格点，精度只能百分百保证十进制的 6 位运算。 double 类型是 64 位，是双精度浮点表示法： 符号位占用 1 位，指数位占用 11 位，小数位占用 52 位。 double 的小数位有 52 位，对应十进制最大值为 4 503 599 627 370 496，这个数有 16 位，所以计算精度只能百分百保证十进制的 15 位运算。\n4.3 float和double类型为什么会出现精度丢失的情况 将十进制浮点数转换为二进制浮点数时，小数的二进制有时也是不可能精确的。 就如同十进制不能准确表示1/3，二进制也无法准确表示1/10，而double类型存储尾数部分最多只能存储52位，于是，计算机在存储该浮点型数据时，便出现了精度丢失。\n商业运算中应用场景：例如某用户有10块钱，买了一件商品花了8.8，理应剩下1.2元。但却无法继续购买价格为1.2元的商品。\n数值1.2在计算机中的存储，实际上为无限接近于1.2的1.1999999999999993\n解决方法1 在设计数据库表的时候可以将price字段类型设置为int(oracle应设置为number)类型，而在实体中对应的属性单位应该表示为分（即精确到0.00）或者角(即0.0),但一般情况下money会精确到分。 如：商品的价格为12.53元(精确到分)，在数据库中price字段对应的数据为应该为1253。使用这种方法需要编程人员自己在程序中收懂转换，当然也可以封装为一个工具类。\n解决方法2 使用java提供的BigDecimal类。该类封装在java.math.BigDecimal中。该类的构造器有很多，但在使用浮点类型计算时一定要使用String构造器来实例BigDecimal对象。\n5.String字符串类型 5.1 String、StringBuffer、StringBuilder简介 5.1.1 String 字符串常量，字符串长度不可变。Java中String是immutable（不可变）的。 /** The value is used for character storage. */ private final char value[]; 用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。如果我们通过 = 对String类型的变量再次赋值，实质上引用指向的对象已经改变了，不是原来的String。\n但是我们可用反射获取修改，这样的修改方式还是原来的对象。\n//反射修改字符串的值 public static void reflectString() throws Exception{ String s = \u0026#34;ABCDEF\u0026#34;; System.out.println(\u0026#34;s = \u0026#34; + s);//ABCDEF Field valueField = s.getClass().getDeclaredField(\u0026#34;value\u0026#34;); valueField.setAccessible(true); char[] value = (char[]) valueField.get(s); value[0] = \u0026#39;a\u0026#39;; value[2] = \u0026#39;c\u0026#39;; value[4] = \u0026#39;e\u0026#39;; System.out.println(\u0026#34;s = \u0026#34; + s);//aBcDeF } 5.1.2 StringBuffer （JDK1.0）字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果想转成String类型，可以调用StringBuffer的toString()方法。 Java.lang.StringBuffer线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。\n5.1.3 StringBuilder （JDK5.0）字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。 java.lang.StringBuilder是一个可变的字符序列，是JDK5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n5.2 String、StringBuilder、StringBuffer区别 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 这三个类在运行速度和线程安全这两方面的区别。\n首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder \u0026gt; StringBuffer \u0026gt; String String最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。以下面一段代码为例：\nString str=\u0026#34;abc\u0026#34;; System.out.println(str); str=str+\u0026#34;de\u0026#34;; System.out.println(str); 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。\n而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。\n另外，有时候我们会这样对字符串进行赋值：\nString str=\u0026#34;abc\u0026#34;+\u0026#34;de\u0026#34;; StringBuilder stringBuilder=new StringBuilder().append(\u0026#34;abc\u0026#34;).append(\u0026#34;de\u0026#34;); System.out.println(str); System.out.println(stringBuilder.toString()); 这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作会发生常量折叠，这个操作和String str = ”abcde”; 是完全一样的，所以会很快，而如果写成下面这种形式：\nString str1=\u0026#34;abc\u0026#34;; String str2=\u0026#34;de\u0026#34;; String str=str1+str2; 那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。\n再来说线程安全，在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。\n总结一下 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况\nStringBuffer：适用多线程下在字符缓冲区进行大量操作的情况\n5.3 String创建的两种方式 一是new型：String s = new String(“abc”)； 另一种是双引号型：String s = “abc”; 那么这两种方式有什么区别呢？ 答:这两种方法生成的字符串对象，在内存中的存取机制不同。 Java为String类型提供了缓冲池机制，当使用双引号定义对象时，Java环境首先去字符串缓冲池（在堆中）寻找相同内容的字符串，如果存在就直接拿出来应用，如果不存在则创建一个新的字符串放在缓冲池中。示例代码如下： String a = “tom”; String b = “tom”; 在上诉代码中，变量a和b使用的是缓冲区中的同一个存储对象。 在使用String构造方法定义对象时，Java环境会和创建其他类型的对象一样，每次调用时，都会去创建一个新的对象。示例代码如下： String a = new String(“tom”); String b = new String(“tom”); 在上述代码中，变量a 和b 使用的是两个不同的存储对象，只是对象中的内容相同。 通常情况下，建议使用string a=”tom”;\nnew就是在堆中创建一个新的String对象，不管\u0026quot;abc\u0026quot;在内存中是否存在，都会在堆中开辟新空间。\n5.4 String a = “a”+“b”+“c”;在内存中创建了几个对象？ 1个对象 String a = “a”+“b”+\u0026ldquo;c\u0026quot;经过编译器优化后得到的效果为String a = “abc” java编译期会进行常量折叠，全字面量字符串相加是可以折叠为一个字面常量，而且是进入常量池的。 在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。 对于String a=“abc”;，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为\u0026quot;abc\u0026quot;的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。 字符串内部拼接：只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，\n5.5 String s=new String(“abc”)创建了几个对象？ 2个对象\nnew String(“abc”)可看成\u0026quot;abc\u0026rdquo;（创建String对象）和new String(String original)（String构造器，创建String对象）2个对象。 我们正是使用new调用了String类的上面那个构造器方法创建了一个对象，并将它的引用赋值给了str变量。同时我们注意到，被调用的构造器方法接受的参数也是一个String对象，这个对象正是\u0026quot;abc\u0026quot;。\n5.6 StringBuffer和StringBuilder的扩容机制 初始长度（16+new的字符串的长度），如果容量不够则进行扩容，扩容后的大小为（n+1）*2\n5.7 StringBuffer和StringBuilder的equals()有坑 这两个类未重写equals方法而且声明为final类，无法继承去重写，所以要比较字符串的字面值的时候要先toString()再equals才行。\n6.JAVA的四种引用类型 6.1 finalize()方法 对象**被垃圾收集器回收的时候（GC的时候）**就会调用finalize()，注意：不要重写，重写容易OOM，垃圾回收在子线程。\n6.2 强引用 最常用的引用，一个对象在没有引用的时候，一旦发生gc则会被回收\n6.3 软引用(SoftReference) 调用get()获取，一般用作缓存机制，如果内存足够的时候，发生gc是不会回收掉软引用的，但是如果内存不够的时候，软引用会被垃圾收集器回收，加载大图放在内存可以使用软引用。（图片缓存）\n6.4 弱引用(WeakReference) 调用get()获取，一旦发生gc，则立即被垃圾回收器回收掉。(可以用于防止内存泄漏)\n6.5 虚引用(PhantomReference) 一般写类库的人才会使用，平常一般不会使用到，什么时候调用get()都get不到，new的时候会把对象的引用放到引用队列（ReferenceQueue）里面，解决的问题：在垃圾回收的时候，被回收的对象会放到回收队列，gc的时候，一般不会真正回收，会先去回收队列检查，Cleaner去检查看看有没有这个对象，就是回收检查的作用，只有在队列找到虚引用的对象，才会回收。虚引用最大作用：管理直接内存（堆外内存） 使用：\nByteBuffer bb = new ByteBuffer.allocateDirect(1024);//分配堆外内存 7.数组 在java中数组也是对象。因此，对象存放在内存中的原理同样适用于数组。 当创建一个数组时，在堆中会为数组对象分配一段内存空间，并返回一个引用。数组对象的引用存放在栈中，实际的数组对象存放在堆中。\n7.1 多维数组在内存中存储方式 7.2 对数组二次封装，模仿ArrayList的API /** * 通过对数组封装实现自己的Array类 */ public class MyArrayList\u0026lt;E\u0026gt; { private E[] data; // 定义一个整型的一维数组的成员变量 private int size; // 数组中元素个数 // 获取数组中元素的个数 public int getSize() { return size; } // 判断数组是否为空 public boolean isEmpty() { return size == 0; } // 向数组的第index位置插入元素e public void add(int index, E e) { if (index \u0026lt; 0 || index \u0026gt; size) throw new IllegalArgumentException(\u0026#34;Add failed. Require index \u0026gt;= 0 and index \u0026lt;= size.\u0026#34;); if (size - data.length \u0026gt;= 0) { int newCapacity = data.length + (data.length \u0026gt;\u0026gt; 1);\t// 扩容1.5倍 resize(newCapacity); } for (int i = size - 1; i \u0026gt;= index; i--) data[i + 1] = data[i]; data[index] = e; size++; } // 动态数组扩容 newCapacity 扩容长度 private void resize(int newCapactity) { E[] newData = (E[]) new Object[newCapactity]; for (int i = 0; i \u0026lt; size; i++) { newData[i] = data[i]; } data = newData; newData = null; } } 7.3 定义一个int型数组 public class ArrayDemo { public static void main(String args[]) { int data[] = new int[3]; /*开辟了一个长度为3的数组*/ data[0] = 10; // 第一个元素 data[1] = 20; // 第二个元素 data[2] = 30; // 第三个元素 for(int x = 0; x \u0026lt; data.length; x++) { System.out.println(data[x]); //通过循环控制索引 } } } 7.4 采用静态初始化定义数组 public class ArrayDemo { public static void main(String args[]) { int data[] = {1, 2, 4, 545, 11, 32, 13131, 4444}; for(int i = 0; i \u0026lt; data.length; i++) { System.out.println(data[i]); } } } 7.5 定义一个二维数组 public class ArrayDemo { public static void main(String args[]) { //此时的数组并不是一个等列数组 int data[][] = new int[][] { {1, 2, 3}, {4, 5}, {6, 7, 8, 9}}; //如果在进行输出的时候一定要使用双重循环， //外部的循环控制输出的行数，而内部的循环控制输出列数 for(int i = 0; i \u0026lt; data.length; i++) { for(int j = 0; j \u0026lt; data[i].length; j++) { System.out.print(\u0026#34;data[\u0026#34; + i + \u0026#34;][\u0026#34; + j + \u0026#34;]=\u0026#34; + data[i][j] + \u0026#34;、\u0026#34;); } System.out.println(); } } } ","date":"2021-05-28T00:00:00Z","permalink":"https://haolovelin.com/post/java2%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","title":"Java（2）基本类型和引用类型"},{"content":"一、Java的一些基础知识 1.Java的环境以及跨平台 Java是一门面向对象编程语言，具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。那么我将先从JavaSE的基础开始重新梳理和学习。\n1.1 JDK \u0026amp; JVM \u0026amp; JRE分别是什么以及它们的区别？ JDK（Java Development Kit）是Java开发工具包，是针对Java开发者的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。\nJRE（Java Runtime Environment）是Java运行环境，是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。\nJVM（Java Virtual Machine）Java虚拟机的缩写，是整个Java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。\n因此我们可以得出个简单的结论：JDK \u0026gt; JRE \u0026gt; JVM，我们开发Java重新要下载JDK，运行Java程序需要JRE，而程序是在JVM上运行的。\nJDK的下载地址：https://www.oracle.com/java/technologies/javase-downloads.html\n如果是在windows平台，我们下载并安装JDK后还需要配置环境变量才能开始编程：\n配置环境变量可以参考：\n右键桌面上\u0026quot;我的电脑\u0026quot;\u0026ndash;\u0026gt;\u0026ldquo;属性\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;高级系统设置\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;高级\u0026rdquo;\u0026ndash;\u0026gt;\u0026ldquo;环境变量\u0026rdquo;。在弹出的\u0026quot;环境变量\u0026quot;窗口中的\u0026quot;系统变量\u0026quot;中点击\u0026quot;新建\u0026quot;按钮，在弹出的窗口中，新建一个名为\u0026quot;JAVA_HOME\u0026quot;的环境变量，变量值为Java的安装路径：我的是在D:\\JavaSE_14 然后设置Path环境变量，该变量已经存在，所以在列表中选择Path，点击下方的“编辑”按钮，在弹出的窗口中添加如下信息：%JAVA_HOME%\\bin;然后点击“确定”按钮即可。\n1.2 为什么Java可以跨平台？ 我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。\n也就是如下： ① Java源文件 —\u0026gt; 编译器 —\u0026gt; 字节码文件（xxx.Class） ② 字节码文件 —\u0026gt; JVM —\u0026gt; 机器码\n虽然每一种平台的解释器是不同的，但是虚拟机JVM是不同平台都可以使用的，程序运行在JVM上，这也就是Java程序能够跨平台的原因了。当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。\n2.面向对象三大特性(封装、继承、多态) 2.1 封装 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。\n封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。\n要访问该类的代码和数据，必须通过严格的接口控制。\n封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n封装的优点：\n良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 总结：说人话就是，我把具体怎么做的隐藏起来，不给外部看，外部需要使用我提供的功能时，是不需要关心我是怎么做的，只需要调用接口（类似于父母叫我去买东西，但是我是走路去还是骑车去，他们是不关心的，最后我只要买回来就行）\n对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问:\npublic class Person{ private String name; private int age; public int getAge(){ return age; } public String getName(){ return name; } public void setAge(int age){ this.age = age; } public void setName(String name){ this.name = name; } } 2.2 继承 继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n兔子和羊属于食草动物类，狮子和豹属于食肉动物类。\n食草动物和食肉动物又是属于动物类。\n所以继承需要符合的关系是：is-a（兔子是一个动物），父类更通用，子类更具体。\n虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。\n继承的作用：一般来说，所有父类能够使用的场景，子类应该是可以代替的，比如：自行车、汽车都属于陆地交通工具，陆地交通工具可以用于旅行，那么这样的场景，子类可以代替父类来使用，也就是，自行车、汽车都可以用于旅行。\nclass Transportation {//父类：交通工具 public String travel(){ return (\u0026#34;使用交通工具旅游\u0026#34;); } } class Car extends Transportation {//汽车 @Override public String travel(){//重写travel方法 return (\u0026#34;使用汽车旅游\u0026#34;); } } class Bike extends Transportation{//自行车 @Override public String travel(){//重写travel方法 return (\u0026#34;使用自行车旅游\u0026#34;); } } public class Test1 { public static void main(String[] args) { Transportation a = new Transportation(); Transportation b = new Car(); Transportation c = new Bike(); System.out.println(\u0026#34;a--\u0026#34; + a.travel());//使用交通工具旅游 System.out.println(\u0026#34;b--\u0026#34; + b.travel());//使用汽车旅游 System.out.println(\u0026#34;c--\u0026#34; + c.travel());//使用自行车旅游 } } 2.3 多态 2.3.1 定义 多态是同一个行为具有多个不同表现形式或形态的能力。\n多态就是同一个接口，使用不同的实例而执行不同操作。\n2.3.2 三要素 （1）继承 （2）重写 （3）父类引用指向子类对象Parent p = new Child();\n2.3.3 好处 1.可替换性（substitutability） 多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 2.可扩充性（extensibility） 多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 3.接口性（interface-ability） 多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。 4.灵活性（flexibility） 它在应用中体现了灵活多样的操作，提高了使用效率。 5.简化性（simplicity） 多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。\n2.3.4 Java中多态实现方式 方式一：重写 方式二：接口\n生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。\njava中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。\n方式三：抽象类和抽象方法\n2.3.5 向上转型 Father father=new Son(); //多态，父类指向子类的引用 如果Father类型方法表中没有方法f1，那么即使Son类型中方法表有，编译的时候也通过不了。因为调用方法f1的类的对象father的声明为Father类型。\n2.3.6 绑定（多态） 将一个方法调用同一个方法主体关联起来被称为绑定.\n静态绑定 在编译阶段就能够确定调用哪个方法的方式，我们叫做 静态绑定机制 。 除了被static 修饰的静态方法，所有被private 修饰的私有方法、被final 修饰的禁止子类覆盖的方法。JVM会采用静态绑定机制来顺利的调用这些方法。\n动态绑定 在程序运行过程中，通过动态创建的对象的方法表来定位方法的方式，我们叫做 动态绑定机制 。 类对象方法的调用必须在运行过程中采用动态绑定机制。 首先，根据对象的声明类型(对象引用的类型)找到“合适”的方法。具体步骤如下： ① 如果能在声明类型中匹配到方法签名完全一样(参数类型一致)的方法，那么这个方法是最合适的。 ② 在第①条不能满足的情况下，寻找可以“凑合”的方法。标准就是通过将参数类型进行自动转型之后再进行匹配。（根据继承树从叶子向上找）如果匹配到多个自动转型后的方法签名f(A)和f(B)，则用下面的标准来确定合适的方法：传递给f(A)方法的参数都可以传递给f(B)，则f(A)最合适。反之f(B)最合适 。 ③ 如果仍然在声明类型中找不到“合适”的方法，则编译阶段就无法通过。\n2.3.7 静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？ 静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。\njava中，static修饰符修饰的方法就是静态方法。所谓静态就是指：在编译之后所分配的内存会一直存在（不会被回收），直到程序退出内存才会释放这个空间。 在java中，所有的东西都是对象，对象的抽象就是类，对于一个类而言，如果要使用他的成员（类中的属性，方法等），一般情况下，必须先实例化对象后，通过对象的引用才能访问这些成员。但是，如果要使用的成员使用了static修饰，就可以不通过实例化获得该成员。 因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。\n非静态方法可以被继承和重写，因此可以实现多态。\nclass A { //父类 public static String staticStr = \u0026#34;A静态属性\u0026#34;; public String nonStaticStr = \u0026#34;A非静态属性\u0026#34;; public static void staticMethod(){ System.out.println(\u0026#34;A静态方法\u0026#34;); } public void nonStaticMethod(){ System.out.println(\u0026#34;A非静态方法\u0026#34;); } } class B extends A{//子类B public static String staticStr = \u0026#34;B改写后的静态属性\u0026#34;; public String nonStaticStr = \u0026#34;B改写后的非静态属性\u0026#34;; public static void staticMethod(){ System.out.println(\u0026#34;B改写后的静态方法\u0026#34;); } public void nonStaticMethod(){ System.out.println(\u0026#34;B改写后的非静态方法\u0026#34;); } public class Test2 { public static void main(String[] args) { A a = new B(); B b = new B(); System.out.println(a.nonStaticStr); // A非静态属性 System.out.println(a.staticStr);\t// A静态属性 a.staticMethod();\t// A静态方法 a.nonStaticMethod(); // B改写后的非静态方法 System.out.println(b.nonStaticStr); // B改写后的非静态属性 System.out.println(b.staticStr);\t// B改写后的静态属性 b.staticMethod();\t// B改写后的静态方法 b.nonStaticMethod(); // B改写后的非静态方法 } } 2.3.8 重写与重载的区别 方法的重写(Overriding)和重载(Overloading)\n重写是多态的一种表现，如：子类重写父类的方法。\n重载是方法名相同，而参数不同的方法。\n2.3.9 对this和super的认识 this：就是类中指向对象本身的一个特殊引用。 super：指向自己超（父）类对象的一个引用，而这个超类指的是离自己最近的一个父类。\n3.抽象类（Abstract Class） 3.1 定义 如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类。抽象类用abstract修饰。\n3.2 特点 （1）不能实例化，因为抽象类中含有无法具体实现的方法。 （2）可在抽象类中定义公共成员变量、成员方法、构造方法等。 （3）只要包含一个抽象方法的类，该类必须要定义成抽象类（抽象方法是一种特殊的方法，它只有声明但没有具体的实现，抽象方法必须为public或protected）。故可理解为抽象类是在普通类结构里增加抽象方法的组成部分。 （4）如果子类继承于一个抽象类，则该子类可以有选择性决定是否覆写父类的抽象方法，如果子类没有实现父类的抽象方法，则必须将子类也定义为抽象类（抽象类可以继承抽象类）。 （5）继承只能单继承，一个子类只能继承一个抽象类。\n3.3 目的 抽象类本质上是为了继承而存在，为子类提供一个公共特性的通用模板，是子类的抽象。\n4.接口（Interface） 4.1 定义 接口在java中是一个抽象类型，是抽象方法的集合。一个类通过继承接口的方式，从而继承接口的抽象方法。它是对行为的抽象。\n4.2 特点 （1）从定义上看，接口是个集合，并不是类。类描述了属性和方法，而接口只包含方法（未实现的方法），是抽象方法的集合。接口和抽象类一样不能被实例化，因为不是类。但是接口可以被实现（使用 implements 关键字）。实现某个接口的类必须在类中实现该接口的全部方法。虽然接口内的方法都是抽象的（和抽象方法很像，没有实现）但是不需要abstract关键字。 （2）接口没有构造方法（接口不是类） （3）接口中的方法必须是抽象的（不能实现） （4）接口中除了static、final变量，不能有其他变量 （5）接口支持多继承（一个类可以实现多个接口）\n4.3 目的 提供一组抽象方法的集合，供子类实现。\n4.4 抽象类与接口区别 （1）结构 抽象类中可以有自己的方法实现。也可以有抽象方法。接口只有抽象方法。 抽象类中有自己的成员变量，成员方法。接口只有常量和抽象方法。 抽象类可以用public,protected,private等修饰。接口只能用public修饰。\n（2）继承方式 子类使用extends关键字继承抽象类。子类可以选择性重写抽象类中需要使用的方法，如果子类没有实现抽象类中所有声明的方法的实现，则子类也是抽象类。 子类使用implements关键字实现接口。子类需要提供接口中所有声明的方法的实现。\n（3）构造方法 抽象类可以有构造方法，但接口没有构造方法。但抽象类的构造器不用于创造对象，而是让其子类调用这些构造器完成抽象类的初始化操作。\n（4）多/单继承 一个子类只能继承一个父类，但可以实现多个接口。\n（5）速度 抽象方法比接口速度快。接口需要时间去寻找在类中实现的方法，故速度较慢。\n（6）设计 抽象类是对事物的一种抽象，描述的是某一类特性的事物。表示 这个对象是什么。（is-a关系——强调所属关系） 接口是对行为功能的抽象，描述是否具备某种行为特征。表示 这个对象能做什么。（has-a关系——强调功能实现）\n（7）举例 门和警报的案例：门都有open和close两个动作，现在为门增加一个警报功能，如何实现？ 思路1：将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 思路2：将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。\n从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。\n5. 总结 5.1 什么是面向过程 \u0026amp; 什么是面向对象 \u0026amp; 区别？ 面向过程：就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。\n面向对象：是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。\n5.2 面向对象的特性：简述封装、继承、多态 封装的思想保证了类内部数据结构的完整性，使用户无法轻易直接操作类的内部数据，这样降低了对内部数据的影响，提高了程序的安全性和可维护性。\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或类从父类继承方法，使得子类具有父类相同的行为。\n多态指的就是在应用程序中出现的“重名”现象。多态性允许以统一的风格编写程序，以处理种类繁多的已存在的类及其相关类。这样既降低了维护难度，又节省了时间。多以重写、重载、实现接口或者抽象类的方式体现。\n5.3 THIS和SUPER 通俗的讲，this指的是当前对象，super则指父类的。\n5.4 接口和抽象类的区别 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。 一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。\n接口的成员变量，默认也只能是public static final修饰的。\n抽象类的成员变量可以是非静态的。\n5.5 静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？ 父类的静态属性和方法可以被子类继承。\n当父类的引用指向子类时，使用对象调用静态方法或者静态变量，是调用的父类中的方法或者变量。并没有被子类改写。 所以静态变量和方法不能被重写。\n原因：static修饰函数/变量时，其实是全局函数/变量，它只是因为java强调对象的要挂，它与任何类都没有关系。靠这个类的好处就是这个类的成员函数调用static方法不用带类名。\n注意：static关键字可以用修饰代码块.static代码块可以置于类中的任何一个位置，并可以有多个static代码块。在类初次被加载时，会按照静态代码块的顺序来执行，并且只会执行一次。\n5.6 权限修饰符 修饰符 同类中 同一个包中(子类和无关类) 不同包(子类) 不同包(无关类) public Y Y Y Y protected Y Y Y N 默认 Y Y N N private Y N N N 5.7 JAVA中的内部类 可以将一个类的定义放在里另一个类的内部，这就是内部类。广义上我们将内部类分为四种：成员内部类、静态内部类、局部（方法）内部类、匿名内部类。\n在实际问题中我们会遇到一些接口无法解决或难以解决的问题，此时我们可以使用内部类继承某个具体的或抽象的类，间接解决类无法多继承引起的一系列问题。\n5.8 闭包和内部类的区别？ 内部类使用外部的局部变量，实际上形成了闭包，也就是捕获了所在方法内的变量，这个被捕获的变量不能随着方法的执行完毕而消失，因为内部类的实例可能还会用到这个变量，所以需要 final 关键字来让这个变量不消失（final 修饰的变量会转为常量，因此不会随着方法的执行完毕而消失）。 如果在内部类中使用到了外部方法的变量，需要使用 final 修饰，否则无法编译通过，但如果使用的是 JDK8，那么即便你不加final 修饰，也是可以编译过的，因为编译器替你加上了。\n5.9 JAVA多态的实现机制是什么？ 子类继承父类（extends），类实现接口（implements）\n5.10 对象生命周期的认识 如果从表层去看的话，我觉得对象的生命周期主要分创建阶段，应用阶段，不可视阶段，不可达阶段，回收释放阶段。\n先是代码里面定义类，然后通过强引用，软引用，进行应用阶段并在jvm的堆区创建对象，然后在超过对象的作用域后，对象不可见，也就可以被GC回收。不可达阶段，是不再有引用指向对象，这类就会被回收。然后就是被GC回收释放对象空间。\n5.11 STATIC关键字的作用？ 修饰成员变量，类加载时就被分配空间，可以通过类直接访问，存储在静态存储区。\n修饰成员方法，类直接调用，不用new。\n单例。\n静态导入包，导入类中的静态方法。\n5.12 FINAL关键字的作用 final关键字可以用来修饰引用、方法和类：\n1.用来修饰一个引用：\n如果引用为基本数据类型，则该引用为常量，该值无法修改； 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。 如果引用是类的成员变量，则必须当场赋值，否则编译会报错。 2.用来修饰一个方法：\n当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。\n3.用来修饰类：\n当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。比如常用的String类就是最终类。\n","date":"2021-05-27T00:00:00Z","permalink":"https://haolovelin.com/post/java1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"Java（1）基础知识以及环境搭建"},{"content":"markdown文件（.md）的基本常用编写语法,是一种快速标记、快速排版语言，现在很多前段项目中的说明文件readme等都是用.md文件编写的\n一、标题 1.方式一\n# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 2.方式二\n# 一级标题 # ## 二级标题 ## ### 三级标题 ### #### 四级标题 #### ##### 五级标题 ##### ###### 六级标题 ##### 二、列表 无序列表 //如下 + a + b + c //或 - a - b - c //或 * a * b * c 有序列表 //如下 1. xxx 2. xxx 3. xxx 嵌套使用 //如下 + xxx + abc + bcd + cde + xxx + xxx 三、引用说明区块 对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。\n正常形式 \u0026gt; 引用内容 嵌套区块 \u0026gt; 一级引用 \u0026gt;\u0026gt; 二级引用 \u0026gt;\u0026gt;\u0026gt; 三级引用 \u0026gt;\u0026gt;\u0026gt;\u0026gt; 四级引用 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 五级引用 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 六级引用 四、代码块 在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。\n少量代码，单行使用，内容 ` xxx ` 大量代码，需要多行使用，用```包裹起来 ``` xxx xxx xxx ``` 五、链接 行内式 链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来 [示例](https://www.baidu.com \u0026#34;百度\u0026#34;), 参数式 链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来 [示例]: https://www.baidu.com \u0026#34;百度\u0026#34; [示例]: https://www.baidu.com \u0026#39;百度\u0026#39; [示例]: https://www.baidu.com (百度) [示例]: \u0026lt;https://www.baidu.com\u0026gt; \u0026#34;百度\u0026#34; 六、图片 行内式 和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上! ![my-logo.png](https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \u0026#34;my-logo\u0026#34;) 参数式 图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上! [my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \u0026#34;my-logo\u0026#34; [my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 \u0026#39;my-logo\u0026#39; [my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 (my-logo) [my-logo.png]: \u0026lt;https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\u0026gt; \u0026#34;my-logo\u0026#34; 七、分割线 分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以\n--- - - - ------ *** * * * ****** ___ _ _ _ ______ 八、其他 强调字体 一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗 *md* **md** _md_ __md__ 转义 \\\\ \\* \\+ \\- \\` \\_ 删除线 用~~把需要显示删除线的字符包裹起来 ~~删除~~ 九、表格 //例子一 |123|234|345| |:-|:-:|-:| |abc|bcd|cde| |abc|bcd|cde| |abc|bcd|cde| //例子二 |123|234|345| |:---|:---:|---:| |abc|bcd|cde| |abc|bcd|cde| |abc|bcd|cde| //例子三 123|234|345 :-|:-:|-: abc|bcd|cde abc|bcd|cde abc|bcd|cde 上面三个例子的效果一样，由此可得： \\1. 表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的 \\2. 分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中\n","date":"2021-05-22T00:00:00Z","permalink":"https://haolovelin.com/post/markdown%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","title":"Markdown使用方法"},{"content":"“说来也是笑话，我读过小学、中学，也当过兵，却不曾看见过世界地图，因此就不知道世界有多大。湖南省图书馆的墙壁土，挂有一张世界大地图，我每天经过那里，总是站着看一看。 过去我认为湘潭县大，湖南省更大，中国自古就称为天下，当然大得了不得。但从这个地图上看来，中国只占世界的一小部分，湖南省更小，湘潭县在地图上没有看见，韶山当然更没有影子了。世界原来有这么大！ 世界既大，人就一定特别多。这样多的人怎样过生活，难道不值得我们注意吗？从韶山冲的情形来看，那里的人大都过着痛苦的生活，不是挨饿，就是挨冻。有无钱治病看着病死的；还有家庭里、乡邻间，为着大大小小的纠纷，吵嘴、打架，闹得鸡犬不宁，甚至弄得投塘、吊颈的；至于没有书读，做一世睁眼瞎子的就更多了。在韶山冲里，我就没有看见几个生活过得快活的人。韶山冲的情形是这样，全湘潭县、全湖南省、全中国、全世界的情形，恐怕也差不多！ 我真怀疑，人生在世间，难道都注定要过痛苦的生活吗？决不！为什么会有这种现象呢？ 这是制度不好，政治不好，是因为世界上存在人剥削人、人压迫人的制度，所以使世界大多数的人都陷入痛苦的深潭。这种不合理的现象，是不应该永远存在的，是应该彻底推翻、彻底改造的！总有一天，世界会起变化，一切痛苦的人，都会变成快活的人！幸福的人！ 世界的变化，不会自己发生，必须通过革命，通过人的努力。我因此想到，我们青年的责任真是重大，我们应该做的事情真多，要走的道路真长。 从这时候起，我就决心要为全中国痛苦的人、全世界痛苦的人贡献自己全部的力量。”\n——1951年 教员的回忆\n","date":"2021-05-22T00:00:00Z","permalink":"https://haolovelin.com/post/%E6%95%99%E5%91%98%E7%9A%84%E5%9B%9E%E5%BF%86/","title":"教员的回忆"},{"content":"愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。此后如竟没有炬火：我便是唯一的光。倘若有了炬火，出了太阳，我们自然心悦诚服的消失。不但毫无不平，而且还要随喜赞美这炬火或太阳；因为他照了人类，连我都在内。\n——鲁迅\n","date":"2021-05-22T00:00:00Z","permalink":"https://haolovelin.com/post/%E9%B2%81%E8%BF%85%E5%85%88%E7%94%9F%E7%9A%84%E8%AF%9D/","title":"鲁迅先生的话"}]